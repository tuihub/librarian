// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/account"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/app"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/appbinary"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/appinfo"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/appinst"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/appinstruntime"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/deviceinfo"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/feed"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/feedactionset"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/feedconfig"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/feedconfigaction"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/feeditem"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/feeditemcollection"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/file"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/image"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/notifyflow"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/notifyflowsource"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/notifyflowtarget"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/notifysource"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/notifytarget"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/porterinstance"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/porterprivilege"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/predicate"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/systemnotification"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/tag"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/user"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/userdevice"
	"github.com/tuihub/librarian/app/sephirah/internal/data/internal/ent/usersession"
	"github.com/tuihub/librarian/app/sephirah/internal/model/modeltiphereth"
	"github.com/tuihub/librarian/internal/model"
	"github.com/tuihub/librarian/internal/model/modelfeed"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount            = "Account"
	TypeApp                = "App"
	TypeAppBinary          = "AppBinary"
	TypeAppInfo            = "AppInfo"
	TypeAppInst            = "AppInst"
	TypeAppInstRunTime     = "AppInstRunTime"
	TypeDeviceInfo         = "DeviceInfo"
	TypeFeed               = "Feed"
	TypeFeedActionSet      = "FeedActionSet"
	TypeFeedConfig         = "FeedConfig"
	TypeFeedConfigAction   = "FeedConfigAction"
	TypeFeedItem           = "FeedItem"
	TypeFeedItemCollection = "FeedItemCollection"
	TypeFile               = "File"
	TypeImage              = "Image"
	TypeNotifyFlow         = "NotifyFlow"
	TypeNotifyFlowSource   = "NotifyFlowSource"
	TypeNotifyFlowTarget   = "NotifyFlowTarget"
	TypeNotifySource       = "NotifySource"
	TypeNotifyTarget       = "NotifyTarget"
	TypePorterInstance     = "PorterInstance"
	TypePorterPrivilege    = "PorterPrivilege"
	TypeSystemNotification = "SystemNotification"
	TypeTag                = "Tag"
	TypeUser               = "User"
	TypeUserDevice         = "UserDevice"
	TypeUserSession        = "UserSession"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                   Op
	typ                  string
	id                   *model.InternalID
	platform             *string
	platform_account_id  *string
	name                 *string
	profile_url          *string
	avatar_url           *string
	updated_at           *time.Time
	created_at           *time.Time
	clearedFields        map[string]struct{}
	purchased_app        map[model.InternalID]struct{}
	removedpurchased_app map[model.InternalID]struct{}
	clearedpurchased_app bool
	bind_user            *model.InternalID
	clearedbind_user     bool
	done                 bool
	oldValue             func(context.Context) (*Account, error)
	predicates           []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id model.InternalID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlatform sets the "platform" field.
func (m *AccountMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *AccountMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *AccountMutation) ResetPlatform() {
	m.platform = nil
}

// SetPlatformAccountID sets the "platform_account_id" field.
func (m *AccountMutation) SetPlatformAccountID(s string) {
	m.platform_account_id = &s
}

// PlatformAccountID returns the value of the "platform_account_id" field in the mutation.
func (m *AccountMutation) PlatformAccountID() (r string, exists bool) {
	v := m.platform_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformAccountID returns the old "platform_account_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPlatformAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformAccountID: %w", err)
	}
	return oldValue.PlatformAccountID, nil
}

// ResetPlatformAccountID resets all changes to the "platform_account_id" field.
func (m *AccountMutation) ResetPlatformAccountID() {
	m.platform_account_id = nil
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetProfileURL sets the "profile_url" field.
func (m *AccountMutation) SetProfileURL(s string) {
	m.profile_url = &s
}

// ProfileURL returns the value of the "profile_url" field in the mutation.
func (m *AccountMutation) ProfileURL() (r string, exists bool) {
	v := m.profile_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileURL returns the old "profile_url" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldProfileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileURL: %w", err)
	}
	return oldValue.ProfileURL, nil
}

// ResetProfileURL resets all changes to the "profile_url" field.
func (m *AccountMutation) ResetProfileURL() {
	m.profile_url = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *AccountMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *AccountMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *AccountMutation) ResetAvatarURL() {
	m.avatar_url = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddPurchasedAppIDs adds the "purchased_app" edge to the AppInfo entity by ids.
func (m *AccountMutation) AddPurchasedAppIDs(ids ...model.InternalID) {
	if m.purchased_app == nil {
		m.purchased_app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.purchased_app[ids[i]] = struct{}{}
	}
}

// ClearPurchasedApp clears the "purchased_app" edge to the AppInfo entity.
func (m *AccountMutation) ClearPurchasedApp() {
	m.clearedpurchased_app = true
}

// PurchasedAppCleared reports if the "purchased_app" edge to the AppInfo entity was cleared.
func (m *AccountMutation) PurchasedAppCleared() bool {
	return m.clearedpurchased_app
}

// RemovePurchasedAppIDs removes the "purchased_app" edge to the AppInfo entity by IDs.
func (m *AccountMutation) RemovePurchasedAppIDs(ids ...model.InternalID) {
	if m.removedpurchased_app == nil {
		m.removedpurchased_app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.purchased_app, ids[i])
		m.removedpurchased_app[ids[i]] = struct{}{}
	}
}

// RemovedPurchasedApp returns the removed IDs of the "purchased_app" edge to the AppInfo entity.
func (m *AccountMutation) RemovedPurchasedAppIDs() (ids []model.InternalID) {
	for id := range m.removedpurchased_app {
		ids = append(ids, id)
	}
	return
}

// PurchasedAppIDs returns the "purchased_app" edge IDs in the mutation.
func (m *AccountMutation) PurchasedAppIDs() (ids []model.InternalID) {
	for id := range m.purchased_app {
		ids = append(ids, id)
	}
	return
}

// ResetPurchasedApp resets all changes to the "purchased_app" edge.
func (m *AccountMutation) ResetPurchasedApp() {
	m.purchased_app = nil
	m.clearedpurchased_app = false
	m.removedpurchased_app = nil
}

// SetBindUserID sets the "bind_user" edge to the User entity by id.
func (m *AccountMutation) SetBindUserID(id model.InternalID) {
	m.bind_user = &id
}

// ClearBindUser clears the "bind_user" edge to the User entity.
func (m *AccountMutation) ClearBindUser() {
	m.clearedbind_user = true
}

// BindUserCleared reports if the "bind_user" edge to the User entity was cleared.
func (m *AccountMutation) BindUserCleared() bool {
	return m.clearedbind_user
}

// BindUserID returns the "bind_user" edge ID in the mutation.
func (m *AccountMutation) BindUserID() (id model.InternalID, exists bool) {
	if m.bind_user != nil {
		return *m.bind_user, true
	}
	return
}

// BindUserIDs returns the "bind_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BindUserID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) BindUserIDs() (ids []model.InternalID) {
	if id := m.bind_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBindUser resets all changes to the "bind_user" edge.
func (m *AccountMutation) ResetBindUser() {
	m.bind_user = nil
	m.clearedbind_user = false
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.platform != nil {
		fields = append(fields, account.FieldPlatform)
	}
	if m.platform_account_id != nil {
		fields = append(fields, account.FieldPlatformAccountID)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.profile_url != nil {
		fields = append(fields, account.FieldProfileURL)
	}
	if m.avatar_url != nil {
		fields = append(fields, account.FieldAvatarURL)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldPlatform:
		return m.Platform()
	case account.FieldPlatformAccountID:
		return m.PlatformAccountID()
	case account.FieldName:
		return m.Name()
	case account.FieldProfileURL:
		return m.ProfileURL()
	case account.FieldAvatarURL:
		return m.AvatarURL()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldPlatform:
		return m.OldPlatform(ctx)
	case account.FieldPlatformAccountID:
		return m.OldPlatformAccountID(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldProfileURL:
		return m.OldProfileURL(ctx)
	case account.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case account.FieldPlatformAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformAccountID(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldProfileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileURL(v)
		return nil
	case account.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldPlatform:
		m.ResetPlatform()
		return nil
	case account.FieldPlatformAccountID:
		m.ResetPlatformAccountID()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldProfileURL:
		m.ResetProfileURL()
		return nil
	case account.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.purchased_app != nil {
		edges = append(edges, account.EdgePurchasedApp)
	}
	if m.bind_user != nil {
		edges = append(edges, account.EdgeBindUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgePurchasedApp:
		ids := make([]ent.Value, 0, len(m.purchased_app))
		for id := range m.purchased_app {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeBindUser:
		if id := m.bind_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpurchased_app != nil {
		edges = append(edges, account.EdgePurchasedApp)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgePurchasedApp:
		ids := make([]ent.Value, 0, len(m.removedpurchased_app))
		for id := range m.removedpurchased_app {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpurchased_app {
		edges = append(edges, account.EdgePurchasedApp)
	}
	if m.clearedbind_user {
		edges = append(edges, account.EdgeBindUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgePurchasedApp:
		return m.clearedpurchased_app
	case account.EdgeBindUser:
		return m.clearedbind_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeBindUser:
		m.ClearBindUser()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgePurchasedApp:
		m.ResetPurchasedApp()
		return nil
	case account.EdgeBindUser:
		m.ResetBindUser()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op              Op
	typ             string
	id              *model.InternalID
	name            *string
	description     *string
	public          *bool
	updated_at      *time.Time
	created_at      *time.Time
	clearedFields   map[string]struct{}
	owner           *model.InternalID
	clearedowner    bool
	app_info        *model.InternalID
	clearedapp_info bool
	done            bool
	oldValue        func(context.Context) (*App, error)
	predicates      []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id model.InternalID) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AppMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AppMutation) ResetDescription() {
	m.description = nil
}

// SetPublic sets the "public" field.
func (m *AppMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *AppMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *AppMutation) ResetPublic() {
	m.public = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *AppMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *AppMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *AppMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AppMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AppMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AppMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetAppInfoID sets the "app_info" edge to the AppInfo entity by id.
func (m *AppMutation) SetAppInfoID(id model.InternalID) {
	m.app_info = &id
}

// ClearAppInfo clears the "app_info" edge to the AppInfo entity.
func (m *AppMutation) ClearAppInfo() {
	m.clearedapp_info = true
}

// AppInfoCleared reports if the "app_info" edge to the AppInfo entity was cleared.
func (m *AppMutation) AppInfoCleared() bool {
	return m.clearedapp_info
}

// AppInfoID returns the "app_info" edge ID in the mutation.
func (m *AppMutation) AppInfoID() (id model.InternalID, exists bool) {
	if m.app_info != nil {
		return *m.app_info, true
	}
	return
}

// AppInfoIDs returns the "app_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppInfoID instead. It exists only for internal usage by the builders.
func (m *AppMutation) AppInfoIDs() (ids []model.InternalID) {
	if id := m.app_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppInfo resets all changes to the "app_info" edge.
func (m *AppMutation) ResetAppInfo() {
	m.app_info = nil
	m.clearedapp_info = false
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.description != nil {
		fields = append(fields, app.FieldDescription)
	}
	if m.public != nil {
		fields = append(fields, app.FieldPublic)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldName:
		return m.Name()
	case app.FieldDescription:
		return m.Description()
	case app.FieldPublic:
		return m.Public()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldDescription:
		return m.OldDescription(ctx)
	case app.FieldPublic:
		return m.OldPublic(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case app.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldDescription:
		m.ResetDescription()
		return nil
	case app.FieldPublic:
		m.ResetPublic()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, app.EdgeOwner)
	}
	if m.app_info != nil {
		edges = append(edges, app.EdgeAppInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeAppInfo:
		if id := m.app_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, app.EdgeOwner)
	}
	if m.clearedapp_info {
		edges = append(edges, app.EdgeAppInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeOwner:
		return m.clearedowner
	case app.EdgeAppInfo:
		return m.clearedapp_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	case app.EdgeOwner:
		m.ClearOwner()
		return nil
	case app.EdgeAppInfo:
		m.ClearAppInfo()
		return nil
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeOwner:
		m.ResetOwner()
		return nil
	case app.EdgeAppInfo:
		m.ResetAppInfo()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AppBinaryMutation represents an operation that mutates the AppBinary nodes in the graph.
type AppBinaryMutation struct {
	config
	op              Op
	typ             string
	id              *model.InternalID
	name            *string
	size_bytes      *int64
	addsize_bytes   *int64
	public_url      *string
	sha256          *[]byte
	updated_at      *time.Time
	created_at      *time.Time
	clearedFields   map[string]struct{}
	app_info        *model.InternalID
	clearedapp_info bool
	done            bool
	oldValue        func(context.Context) (*AppBinary, error)
	predicates      []predicate.AppBinary
}

var _ ent.Mutation = (*AppBinaryMutation)(nil)

// appbinaryOption allows management of the mutation configuration using functional options.
type appbinaryOption func(*AppBinaryMutation)

// newAppBinaryMutation creates new mutation for the AppBinary entity.
func newAppBinaryMutation(c config, op Op, opts ...appbinaryOption) *AppBinaryMutation {
	m := &AppBinaryMutation{
		config:        c,
		op:            op,
		typ:           TypeAppBinary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppBinaryID sets the ID field of the mutation.
func withAppBinaryID(id model.InternalID) appbinaryOption {
	return func(m *AppBinaryMutation) {
		var (
			err   error
			once  sync.Once
			value *AppBinary
		)
		m.oldValue = func(ctx context.Context) (*AppBinary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppBinary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppBinary sets the old AppBinary of the mutation.
func withAppBinary(node *AppBinary) appbinaryOption {
	return func(m *AppBinaryMutation) {
		m.oldValue = func(context.Context) (*AppBinary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppBinaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppBinaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppBinary entities.
func (m *AppBinaryMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppBinaryMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppBinaryMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppBinary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AppBinaryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppBinaryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppBinary entity.
// If the AppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppBinaryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppBinaryMutation) ClearName() {
	m.name = nil
	m.clearedFields[appbinary.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppBinaryMutation) NameCleared() bool {
	_, ok := m.clearedFields[appbinary.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppBinaryMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, appbinary.FieldName)
}

// SetSizeBytes sets the "size_bytes" field.
func (m *AppBinaryMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *AppBinaryMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the AppBinary entity.
// If the AppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppBinaryMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *AppBinaryMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *AppBinaryMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeBytes clears the value of the "size_bytes" field.
func (m *AppBinaryMutation) ClearSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	m.clearedFields[appbinary.FieldSizeBytes] = struct{}{}
}

// SizeBytesCleared returns if the "size_bytes" field was cleared in this mutation.
func (m *AppBinaryMutation) SizeBytesCleared() bool {
	_, ok := m.clearedFields[appbinary.FieldSizeBytes]
	return ok
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *AppBinaryMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	delete(m.clearedFields, appbinary.FieldSizeBytes)
}

// SetPublicURL sets the "public_url" field.
func (m *AppBinaryMutation) SetPublicURL(s string) {
	m.public_url = &s
}

// PublicURL returns the value of the "public_url" field in the mutation.
func (m *AppBinaryMutation) PublicURL() (r string, exists bool) {
	v := m.public_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicURL returns the old "public_url" field's value of the AppBinary entity.
// If the AppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppBinaryMutation) OldPublicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicURL: %w", err)
	}
	return oldValue.PublicURL, nil
}

// ClearPublicURL clears the value of the "public_url" field.
func (m *AppBinaryMutation) ClearPublicURL() {
	m.public_url = nil
	m.clearedFields[appbinary.FieldPublicURL] = struct{}{}
}

// PublicURLCleared returns if the "public_url" field was cleared in this mutation.
func (m *AppBinaryMutation) PublicURLCleared() bool {
	_, ok := m.clearedFields[appbinary.FieldPublicURL]
	return ok
}

// ResetPublicURL resets all changes to the "public_url" field.
func (m *AppBinaryMutation) ResetPublicURL() {
	m.public_url = nil
	delete(m.clearedFields, appbinary.FieldPublicURL)
}

// SetSha256 sets the "sha256" field.
func (m *AppBinaryMutation) SetSha256(b []byte) {
	m.sha256 = &b
}

// Sha256 returns the value of the "sha256" field in the mutation.
func (m *AppBinaryMutation) Sha256() (r []byte, exists bool) {
	v := m.sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldSha256 returns the old "sha256" field's value of the AppBinary entity.
// If the AppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppBinaryMutation) OldSha256(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha256: %w", err)
	}
	return oldValue.Sha256, nil
}

// ClearSha256 clears the value of the "sha256" field.
func (m *AppBinaryMutation) ClearSha256() {
	m.sha256 = nil
	m.clearedFields[appbinary.FieldSha256] = struct{}{}
}

// Sha256Cleared returns if the "sha256" field was cleared in this mutation.
func (m *AppBinaryMutation) Sha256Cleared() bool {
	_, ok := m.clearedFields[appbinary.FieldSha256]
	return ok
}

// ResetSha256 resets all changes to the "sha256" field.
func (m *AppBinaryMutation) ResetSha256() {
	m.sha256 = nil
	delete(m.clearedFields, appbinary.FieldSha256)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppBinaryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppBinaryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppBinary entity.
// If the AppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppBinaryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppBinaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppBinaryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppBinaryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppBinary entity.
// If the AppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppBinaryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppBinaryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAppInfoID sets the "app_info" edge to the AppInfo entity by id.
func (m *AppBinaryMutation) SetAppInfoID(id model.InternalID) {
	m.app_info = &id
}

// ClearAppInfo clears the "app_info" edge to the AppInfo entity.
func (m *AppBinaryMutation) ClearAppInfo() {
	m.clearedapp_info = true
}

// AppInfoCleared reports if the "app_info" edge to the AppInfo entity was cleared.
func (m *AppBinaryMutation) AppInfoCleared() bool {
	return m.clearedapp_info
}

// AppInfoID returns the "app_info" edge ID in the mutation.
func (m *AppBinaryMutation) AppInfoID() (id model.InternalID, exists bool) {
	if m.app_info != nil {
		return *m.app_info, true
	}
	return
}

// AppInfoIDs returns the "app_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppInfoID instead. It exists only for internal usage by the builders.
func (m *AppBinaryMutation) AppInfoIDs() (ids []model.InternalID) {
	if id := m.app_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppInfo resets all changes to the "app_info" edge.
func (m *AppBinaryMutation) ResetAppInfo() {
	m.app_info = nil
	m.clearedapp_info = false
}

// Where appends a list predicates to the AppBinaryMutation builder.
func (m *AppBinaryMutation) Where(ps ...predicate.AppBinary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppBinaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppBinaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppBinary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppBinaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppBinaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppBinary).
func (m *AppBinaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppBinaryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, appbinary.FieldName)
	}
	if m.size_bytes != nil {
		fields = append(fields, appbinary.FieldSizeBytes)
	}
	if m.public_url != nil {
		fields = append(fields, appbinary.FieldPublicURL)
	}
	if m.sha256 != nil {
		fields = append(fields, appbinary.FieldSha256)
	}
	if m.updated_at != nil {
		fields = append(fields, appbinary.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, appbinary.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppBinaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appbinary.FieldName:
		return m.Name()
	case appbinary.FieldSizeBytes:
		return m.SizeBytes()
	case appbinary.FieldPublicURL:
		return m.PublicURL()
	case appbinary.FieldSha256:
		return m.Sha256()
	case appbinary.FieldUpdatedAt:
		return m.UpdatedAt()
	case appbinary.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppBinaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appbinary.FieldName:
		return m.OldName(ctx)
	case appbinary.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case appbinary.FieldPublicURL:
		return m.OldPublicURL(ctx)
	case appbinary.FieldSha256:
		return m.OldSha256(ctx)
	case appbinary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appbinary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppBinary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppBinaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appbinary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appbinary.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case appbinary.FieldPublicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicURL(v)
		return nil
	case appbinary.FieldSha256:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha256(v)
		return nil
	case appbinary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appbinary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppBinary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppBinaryMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, appbinary.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppBinaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appbinary.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppBinaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appbinary.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown AppBinary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppBinaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appbinary.FieldName) {
		fields = append(fields, appbinary.FieldName)
	}
	if m.FieldCleared(appbinary.FieldSizeBytes) {
		fields = append(fields, appbinary.FieldSizeBytes)
	}
	if m.FieldCleared(appbinary.FieldPublicURL) {
		fields = append(fields, appbinary.FieldPublicURL)
	}
	if m.FieldCleared(appbinary.FieldSha256) {
		fields = append(fields, appbinary.FieldSha256)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppBinaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppBinaryMutation) ClearField(name string) error {
	switch name {
	case appbinary.FieldName:
		m.ClearName()
		return nil
	case appbinary.FieldSizeBytes:
		m.ClearSizeBytes()
		return nil
	case appbinary.FieldPublicURL:
		m.ClearPublicURL()
		return nil
	case appbinary.FieldSha256:
		m.ClearSha256()
		return nil
	}
	return fmt.Errorf("unknown AppBinary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppBinaryMutation) ResetField(name string) error {
	switch name {
	case appbinary.FieldName:
		m.ResetName()
		return nil
	case appbinary.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case appbinary.FieldPublicURL:
		m.ResetPublicURL()
		return nil
	case appbinary.FieldSha256:
		m.ResetSha256()
		return nil
	case appbinary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appbinary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppBinary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppBinaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.app_info != nil {
		edges = append(edges, appbinary.EdgeAppInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppBinaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appbinary.EdgeAppInfo:
		if id := m.app_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppBinaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppBinaryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppBinaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapp_info {
		edges = append(edges, appbinary.EdgeAppInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppBinaryMutation) EdgeCleared(name string) bool {
	switch name {
	case appbinary.EdgeAppInfo:
		return m.clearedapp_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppBinaryMutation) ClearEdge(name string) error {
	switch name {
	case appbinary.EdgeAppInfo:
		m.ClearAppInfo()
		return nil
	}
	return fmt.Errorf("unknown AppBinary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppBinaryMutation) ResetEdge(name string) error {
	switch name {
	case appbinary.EdgeAppInfo:
		m.ResetAppInfo()
		return nil
	}
	return fmt.Errorf("unknown AppBinary edge %s", name)
}

// AppInfoMutation represents an operation that mutates the AppInfo nodes in the graph.
type AppInfoMutation struct {
	config
	op                          Op
	typ                         string
	id                          *model.InternalID
	internal                    *bool
	source                      *string
	source_app_id               *string
	source_url                  *string
	name                        *string
	_type                       *appinfo.Type
	short_description           *string
	description                 *string
	icon_image_url              *string
	background_image_url        *string
	cover_image_url             *string
	release_date                *string
	developer                   *string
	publisher                   *string
	version                     *string
	updated_at                  *time.Time
	created_at                  *time.Time
	clearedFields               map[string]struct{}
	purchased_by_account        map[model.InternalID]struct{}
	removedpurchased_by_account map[model.InternalID]struct{}
	clearedpurchased_by_account bool
	purchased_by_user           map[model.InternalID]struct{}
	removedpurchased_by_user    map[model.InternalID]struct{}
	clearedpurchased_by_user    bool
	app                         map[model.InternalID]struct{}
	removedapp                  map[model.InternalID]struct{}
	clearedapp                  bool
	app_binary                  map[model.InternalID]struct{}
	removedapp_binary           map[model.InternalID]struct{}
	clearedapp_binary           bool
	bind_internal               *model.InternalID
	clearedbind_internal        bool
	bind_external               map[model.InternalID]struct{}
	removedbind_external        map[model.InternalID]struct{}
	clearedbind_external        bool
	done                        bool
	oldValue                    func(context.Context) (*AppInfo, error)
	predicates                  []predicate.AppInfo
}

var _ ent.Mutation = (*AppInfoMutation)(nil)

// appinfoOption allows management of the mutation configuration using functional options.
type appinfoOption func(*AppInfoMutation)

// newAppInfoMutation creates new mutation for the AppInfo entity.
func newAppInfoMutation(c config, op Op, opts ...appinfoOption) *AppInfoMutation {
	m := &AppInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeAppInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppInfoID sets the ID field of the mutation.
func withAppInfoID(id model.InternalID) appinfoOption {
	return func(m *AppInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *AppInfo
		)
		m.oldValue = func(ctx context.Context) (*AppInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppInfo sets the old AppInfo of the mutation.
func withAppInfo(node *AppInfo) appinfoOption {
	return func(m *AppInfoMutation) {
		m.oldValue = func(context.Context) (*AppInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppInfo entities.
func (m *AppInfoMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppInfoMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppInfoMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInternal sets the "internal" field.
func (m *AppInfoMutation) SetInternal(b bool) {
	m.internal = &b
}

// Internal returns the value of the "internal" field in the mutation.
func (m *AppInfoMutation) Internal() (r bool, exists bool) {
	v := m.internal
	if v == nil {
		return
	}
	return *v, true
}

// OldInternal returns the old "internal" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldInternal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternal: %w", err)
	}
	return oldValue.Internal, nil
}

// ResetInternal resets all changes to the "internal" field.
func (m *AppInfoMutation) ResetInternal() {
	m.internal = nil
}

// SetSource sets the "source" field.
func (m *AppInfoMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *AppInfoMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *AppInfoMutation) ResetSource() {
	m.source = nil
}

// SetSourceAppID sets the "source_app_id" field.
func (m *AppInfoMutation) SetSourceAppID(s string) {
	m.source_app_id = &s
}

// SourceAppID returns the value of the "source_app_id" field in the mutation.
func (m *AppInfoMutation) SourceAppID() (r string, exists bool) {
	v := m.source_app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceAppID returns the old "source_app_id" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldSourceAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceAppID: %w", err)
	}
	return oldValue.SourceAppID, nil
}

// ResetSourceAppID resets all changes to the "source_app_id" field.
func (m *AppInfoMutation) ResetSourceAppID() {
	m.source_app_id = nil
}

// SetSourceURL sets the "source_url" field.
func (m *AppInfoMutation) SetSourceURL(s string) {
	m.source_url = &s
}

// SourceURL returns the value of the "source_url" field in the mutation.
func (m *AppInfoMutation) SourceURL() (r string, exists bool) {
	v := m.source_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceURL returns the old "source_url" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldSourceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceURL: %w", err)
	}
	return oldValue.SourceURL, nil
}

// ClearSourceURL clears the value of the "source_url" field.
func (m *AppInfoMutation) ClearSourceURL() {
	m.source_url = nil
	m.clearedFields[appinfo.FieldSourceURL] = struct{}{}
}

// SourceURLCleared returns if the "source_url" field was cleared in this mutation.
func (m *AppInfoMutation) SourceURLCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldSourceURL]
	return ok
}

// ResetSourceURL resets all changes to the "source_url" field.
func (m *AppInfoMutation) ResetSourceURL() {
	m.source_url = nil
	delete(m.clearedFields, appinfo.FieldSourceURL)
}

// SetName sets the "name" field.
func (m *AppInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppInfoMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *AppInfoMutation) SetType(a appinfo.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AppInfoMutation) GetType() (r appinfo.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldType(ctx context.Context) (v appinfo.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AppInfoMutation) ResetType() {
	m._type = nil
}

// SetShortDescription sets the "short_description" field.
func (m *AppInfoMutation) SetShortDescription(s string) {
	m.short_description = &s
}

// ShortDescription returns the value of the "short_description" field in the mutation.
func (m *AppInfoMutation) ShortDescription() (r string, exists bool) {
	v := m.short_description
	if v == nil {
		return
	}
	return *v, true
}

// OldShortDescription returns the old "short_description" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldShortDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortDescription: %w", err)
	}
	return oldValue.ShortDescription, nil
}

// ClearShortDescription clears the value of the "short_description" field.
func (m *AppInfoMutation) ClearShortDescription() {
	m.short_description = nil
	m.clearedFields[appinfo.FieldShortDescription] = struct{}{}
}

// ShortDescriptionCleared returns if the "short_description" field was cleared in this mutation.
func (m *AppInfoMutation) ShortDescriptionCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldShortDescription]
	return ok
}

// ResetShortDescription resets all changes to the "short_description" field.
func (m *AppInfoMutation) ResetShortDescription() {
	m.short_description = nil
	delete(m.clearedFields, appinfo.FieldShortDescription)
}

// SetDescription sets the "description" field.
func (m *AppInfoMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppInfoMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AppInfoMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[appinfo.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AppInfoMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AppInfoMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, appinfo.FieldDescription)
}

// SetIconImageURL sets the "icon_image_url" field.
func (m *AppInfoMutation) SetIconImageURL(s string) {
	m.icon_image_url = &s
}

// IconImageURL returns the value of the "icon_image_url" field in the mutation.
func (m *AppInfoMutation) IconImageURL() (r string, exists bool) {
	v := m.icon_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconImageURL returns the old "icon_image_url" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldIconImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconImageURL: %w", err)
	}
	return oldValue.IconImageURL, nil
}

// ClearIconImageURL clears the value of the "icon_image_url" field.
func (m *AppInfoMutation) ClearIconImageURL() {
	m.icon_image_url = nil
	m.clearedFields[appinfo.FieldIconImageURL] = struct{}{}
}

// IconImageURLCleared returns if the "icon_image_url" field was cleared in this mutation.
func (m *AppInfoMutation) IconImageURLCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldIconImageURL]
	return ok
}

// ResetIconImageURL resets all changes to the "icon_image_url" field.
func (m *AppInfoMutation) ResetIconImageURL() {
	m.icon_image_url = nil
	delete(m.clearedFields, appinfo.FieldIconImageURL)
}

// SetBackgroundImageURL sets the "background_image_url" field.
func (m *AppInfoMutation) SetBackgroundImageURL(s string) {
	m.background_image_url = &s
}

// BackgroundImageURL returns the value of the "background_image_url" field in the mutation.
func (m *AppInfoMutation) BackgroundImageURL() (r string, exists bool) {
	v := m.background_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundImageURL returns the old "background_image_url" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldBackgroundImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundImageURL: %w", err)
	}
	return oldValue.BackgroundImageURL, nil
}

// ClearBackgroundImageURL clears the value of the "background_image_url" field.
func (m *AppInfoMutation) ClearBackgroundImageURL() {
	m.background_image_url = nil
	m.clearedFields[appinfo.FieldBackgroundImageURL] = struct{}{}
}

// BackgroundImageURLCleared returns if the "background_image_url" field was cleared in this mutation.
func (m *AppInfoMutation) BackgroundImageURLCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldBackgroundImageURL]
	return ok
}

// ResetBackgroundImageURL resets all changes to the "background_image_url" field.
func (m *AppInfoMutation) ResetBackgroundImageURL() {
	m.background_image_url = nil
	delete(m.clearedFields, appinfo.FieldBackgroundImageURL)
}

// SetCoverImageURL sets the "cover_image_url" field.
func (m *AppInfoMutation) SetCoverImageURL(s string) {
	m.cover_image_url = &s
}

// CoverImageURL returns the value of the "cover_image_url" field in the mutation.
func (m *AppInfoMutation) CoverImageURL() (r string, exists bool) {
	v := m.cover_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImageURL returns the old "cover_image_url" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldCoverImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImageURL: %w", err)
	}
	return oldValue.CoverImageURL, nil
}

// ClearCoverImageURL clears the value of the "cover_image_url" field.
func (m *AppInfoMutation) ClearCoverImageURL() {
	m.cover_image_url = nil
	m.clearedFields[appinfo.FieldCoverImageURL] = struct{}{}
}

// CoverImageURLCleared returns if the "cover_image_url" field was cleared in this mutation.
func (m *AppInfoMutation) CoverImageURLCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldCoverImageURL]
	return ok
}

// ResetCoverImageURL resets all changes to the "cover_image_url" field.
func (m *AppInfoMutation) ResetCoverImageURL() {
	m.cover_image_url = nil
	delete(m.clearedFields, appinfo.FieldCoverImageURL)
}

// SetReleaseDate sets the "release_date" field.
func (m *AppInfoMutation) SetReleaseDate(s string) {
	m.release_date = &s
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *AppInfoMutation) ReleaseDate() (r string, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldReleaseDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ClearReleaseDate clears the value of the "release_date" field.
func (m *AppInfoMutation) ClearReleaseDate() {
	m.release_date = nil
	m.clearedFields[appinfo.FieldReleaseDate] = struct{}{}
}

// ReleaseDateCleared returns if the "release_date" field was cleared in this mutation.
func (m *AppInfoMutation) ReleaseDateCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldReleaseDate]
	return ok
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *AppInfoMutation) ResetReleaseDate() {
	m.release_date = nil
	delete(m.clearedFields, appinfo.FieldReleaseDate)
}

// SetDeveloper sets the "developer" field.
func (m *AppInfoMutation) SetDeveloper(s string) {
	m.developer = &s
}

// Developer returns the value of the "developer" field in the mutation.
func (m *AppInfoMutation) Developer() (r string, exists bool) {
	v := m.developer
	if v == nil {
		return
	}
	return *v, true
}

// OldDeveloper returns the old "developer" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldDeveloper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeveloper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeveloper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeveloper: %w", err)
	}
	return oldValue.Developer, nil
}

// ClearDeveloper clears the value of the "developer" field.
func (m *AppInfoMutation) ClearDeveloper() {
	m.developer = nil
	m.clearedFields[appinfo.FieldDeveloper] = struct{}{}
}

// DeveloperCleared returns if the "developer" field was cleared in this mutation.
func (m *AppInfoMutation) DeveloperCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldDeveloper]
	return ok
}

// ResetDeveloper resets all changes to the "developer" field.
func (m *AppInfoMutation) ResetDeveloper() {
	m.developer = nil
	delete(m.clearedFields, appinfo.FieldDeveloper)
}

// SetPublisher sets the "publisher" field.
func (m *AppInfoMutation) SetPublisher(s string) {
	m.publisher = &s
}

// Publisher returns the value of the "publisher" field in the mutation.
func (m *AppInfoMutation) Publisher() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisher returns the old "publisher" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldPublisher(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisher: %w", err)
	}
	return oldValue.Publisher, nil
}

// ClearPublisher clears the value of the "publisher" field.
func (m *AppInfoMutation) ClearPublisher() {
	m.publisher = nil
	m.clearedFields[appinfo.FieldPublisher] = struct{}{}
}

// PublisherCleared returns if the "publisher" field was cleared in this mutation.
func (m *AppInfoMutation) PublisherCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldPublisher]
	return ok
}

// ResetPublisher resets all changes to the "publisher" field.
func (m *AppInfoMutation) ResetPublisher() {
	m.publisher = nil
	delete(m.clearedFields, appinfo.FieldPublisher)
}

// SetVersion sets the "version" field.
func (m *AppInfoMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *AppInfoMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *AppInfoMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[appinfo.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *AppInfoMutation) VersionCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *AppInfoMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, appinfo.FieldVersion)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddPurchasedByAccountIDs adds the "purchased_by_account" edge to the Account entity by ids.
func (m *AppInfoMutation) AddPurchasedByAccountIDs(ids ...model.InternalID) {
	if m.purchased_by_account == nil {
		m.purchased_by_account = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.purchased_by_account[ids[i]] = struct{}{}
	}
}

// ClearPurchasedByAccount clears the "purchased_by_account" edge to the Account entity.
func (m *AppInfoMutation) ClearPurchasedByAccount() {
	m.clearedpurchased_by_account = true
}

// PurchasedByAccountCleared reports if the "purchased_by_account" edge to the Account entity was cleared.
func (m *AppInfoMutation) PurchasedByAccountCleared() bool {
	return m.clearedpurchased_by_account
}

// RemovePurchasedByAccountIDs removes the "purchased_by_account" edge to the Account entity by IDs.
func (m *AppInfoMutation) RemovePurchasedByAccountIDs(ids ...model.InternalID) {
	if m.removedpurchased_by_account == nil {
		m.removedpurchased_by_account = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.purchased_by_account, ids[i])
		m.removedpurchased_by_account[ids[i]] = struct{}{}
	}
}

// RemovedPurchasedByAccount returns the removed IDs of the "purchased_by_account" edge to the Account entity.
func (m *AppInfoMutation) RemovedPurchasedByAccountIDs() (ids []model.InternalID) {
	for id := range m.removedpurchased_by_account {
		ids = append(ids, id)
	}
	return
}

// PurchasedByAccountIDs returns the "purchased_by_account" edge IDs in the mutation.
func (m *AppInfoMutation) PurchasedByAccountIDs() (ids []model.InternalID) {
	for id := range m.purchased_by_account {
		ids = append(ids, id)
	}
	return
}

// ResetPurchasedByAccount resets all changes to the "purchased_by_account" edge.
func (m *AppInfoMutation) ResetPurchasedByAccount() {
	m.purchased_by_account = nil
	m.clearedpurchased_by_account = false
	m.removedpurchased_by_account = nil
}

// AddPurchasedByUserIDs adds the "purchased_by_user" edge to the User entity by ids.
func (m *AppInfoMutation) AddPurchasedByUserIDs(ids ...model.InternalID) {
	if m.purchased_by_user == nil {
		m.purchased_by_user = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.purchased_by_user[ids[i]] = struct{}{}
	}
}

// ClearPurchasedByUser clears the "purchased_by_user" edge to the User entity.
func (m *AppInfoMutation) ClearPurchasedByUser() {
	m.clearedpurchased_by_user = true
}

// PurchasedByUserCleared reports if the "purchased_by_user" edge to the User entity was cleared.
func (m *AppInfoMutation) PurchasedByUserCleared() bool {
	return m.clearedpurchased_by_user
}

// RemovePurchasedByUserIDs removes the "purchased_by_user" edge to the User entity by IDs.
func (m *AppInfoMutation) RemovePurchasedByUserIDs(ids ...model.InternalID) {
	if m.removedpurchased_by_user == nil {
		m.removedpurchased_by_user = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.purchased_by_user, ids[i])
		m.removedpurchased_by_user[ids[i]] = struct{}{}
	}
}

// RemovedPurchasedByUser returns the removed IDs of the "purchased_by_user" edge to the User entity.
func (m *AppInfoMutation) RemovedPurchasedByUserIDs() (ids []model.InternalID) {
	for id := range m.removedpurchased_by_user {
		ids = append(ids, id)
	}
	return
}

// PurchasedByUserIDs returns the "purchased_by_user" edge IDs in the mutation.
func (m *AppInfoMutation) PurchasedByUserIDs() (ids []model.InternalID) {
	for id := range m.purchased_by_user {
		ids = append(ids, id)
	}
	return
}

// ResetPurchasedByUser resets all changes to the "purchased_by_user" edge.
func (m *AppInfoMutation) ResetPurchasedByUser() {
	m.purchased_by_user = nil
	m.clearedpurchased_by_user = false
	m.removedpurchased_by_user = nil
}

// AddAppIDs adds the "app" edge to the App entity by ids.
func (m *AppInfoMutation) AddAppIDs(ids ...model.InternalID) {
	if m.app == nil {
		m.app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.app[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppInfoMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppInfoMutation) AppCleared() bool {
	return m.clearedapp
}

// RemoveAppIDs removes the "app" edge to the App entity by IDs.
func (m *AppInfoMutation) RemoveAppIDs(ids ...model.InternalID) {
	if m.removedapp == nil {
		m.removedapp = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.app, ids[i])
		m.removedapp[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "app" edge to the App entity.
func (m *AppInfoMutation) RemovedAppIDs() (ids []model.InternalID) {
	for id := range m.removedapp {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
func (m *AppInfoMutation) AppIDs() (ids []model.InternalID) {
	for id := range m.app {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppInfoMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
	m.removedapp = nil
}

// AddAppBinaryIDs adds the "app_binary" edge to the AppBinary entity by ids.
func (m *AppInfoMutation) AddAppBinaryIDs(ids ...model.InternalID) {
	if m.app_binary == nil {
		m.app_binary = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.app_binary[ids[i]] = struct{}{}
	}
}

// ClearAppBinary clears the "app_binary" edge to the AppBinary entity.
func (m *AppInfoMutation) ClearAppBinary() {
	m.clearedapp_binary = true
}

// AppBinaryCleared reports if the "app_binary" edge to the AppBinary entity was cleared.
func (m *AppInfoMutation) AppBinaryCleared() bool {
	return m.clearedapp_binary
}

// RemoveAppBinaryIDs removes the "app_binary" edge to the AppBinary entity by IDs.
func (m *AppInfoMutation) RemoveAppBinaryIDs(ids ...model.InternalID) {
	if m.removedapp_binary == nil {
		m.removedapp_binary = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.app_binary, ids[i])
		m.removedapp_binary[ids[i]] = struct{}{}
	}
}

// RemovedAppBinary returns the removed IDs of the "app_binary" edge to the AppBinary entity.
func (m *AppInfoMutation) RemovedAppBinaryIDs() (ids []model.InternalID) {
	for id := range m.removedapp_binary {
		ids = append(ids, id)
	}
	return
}

// AppBinaryIDs returns the "app_binary" edge IDs in the mutation.
func (m *AppInfoMutation) AppBinaryIDs() (ids []model.InternalID) {
	for id := range m.app_binary {
		ids = append(ids, id)
	}
	return
}

// ResetAppBinary resets all changes to the "app_binary" edge.
func (m *AppInfoMutation) ResetAppBinary() {
	m.app_binary = nil
	m.clearedapp_binary = false
	m.removedapp_binary = nil
}

// SetBindInternalID sets the "bind_internal" edge to the AppInfo entity by id.
func (m *AppInfoMutation) SetBindInternalID(id model.InternalID) {
	m.bind_internal = &id
}

// ClearBindInternal clears the "bind_internal" edge to the AppInfo entity.
func (m *AppInfoMutation) ClearBindInternal() {
	m.clearedbind_internal = true
}

// BindInternalCleared reports if the "bind_internal" edge to the AppInfo entity was cleared.
func (m *AppInfoMutation) BindInternalCleared() bool {
	return m.clearedbind_internal
}

// BindInternalID returns the "bind_internal" edge ID in the mutation.
func (m *AppInfoMutation) BindInternalID() (id model.InternalID, exists bool) {
	if m.bind_internal != nil {
		return *m.bind_internal, true
	}
	return
}

// BindInternalIDs returns the "bind_internal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BindInternalID instead. It exists only for internal usage by the builders.
func (m *AppInfoMutation) BindInternalIDs() (ids []model.InternalID) {
	if id := m.bind_internal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBindInternal resets all changes to the "bind_internal" edge.
func (m *AppInfoMutation) ResetBindInternal() {
	m.bind_internal = nil
	m.clearedbind_internal = false
}

// AddBindExternalIDs adds the "bind_external" edge to the AppInfo entity by ids.
func (m *AppInfoMutation) AddBindExternalIDs(ids ...model.InternalID) {
	if m.bind_external == nil {
		m.bind_external = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.bind_external[ids[i]] = struct{}{}
	}
}

// ClearBindExternal clears the "bind_external" edge to the AppInfo entity.
func (m *AppInfoMutation) ClearBindExternal() {
	m.clearedbind_external = true
}

// BindExternalCleared reports if the "bind_external" edge to the AppInfo entity was cleared.
func (m *AppInfoMutation) BindExternalCleared() bool {
	return m.clearedbind_external
}

// RemoveBindExternalIDs removes the "bind_external" edge to the AppInfo entity by IDs.
func (m *AppInfoMutation) RemoveBindExternalIDs(ids ...model.InternalID) {
	if m.removedbind_external == nil {
		m.removedbind_external = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.bind_external, ids[i])
		m.removedbind_external[ids[i]] = struct{}{}
	}
}

// RemovedBindExternal returns the removed IDs of the "bind_external" edge to the AppInfo entity.
func (m *AppInfoMutation) RemovedBindExternalIDs() (ids []model.InternalID) {
	for id := range m.removedbind_external {
		ids = append(ids, id)
	}
	return
}

// BindExternalIDs returns the "bind_external" edge IDs in the mutation.
func (m *AppInfoMutation) BindExternalIDs() (ids []model.InternalID) {
	for id := range m.bind_external {
		ids = append(ids, id)
	}
	return
}

// ResetBindExternal resets all changes to the "bind_external" edge.
func (m *AppInfoMutation) ResetBindExternal() {
	m.bind_external = nil
	m.clearedbind_external = false
	m.removedbind_external = nil
}

// Where appends a list predicates to the AppInfoMutation builder.
func (m *AppInfoMutation) Where(ps ...predicate.AppInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppInfo).
func (m *AppInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppInfoMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.internal != nil {
		fields = append(fields, appinfo.FieldInternal)
	}
	if m.source != nil {
		fields = append(fields, appinfo.FieldSource)
	}
	if m.source_app_id != nil {
		fields = append(fields, appinfo.FieldSourceAppID)
	}
	if m.source_url != nil {
		fields = append(fields, appinfo.FieldSourceURL)
	}
	if m.name != nil {
		fields = append(fields, appinfo.FieldName)
	}
	if m._type != nil {
		fields = append(fields, appinfo.FieldType)
	}
	if m.short_description != nil {
		fields = append(fields, appinfo.FieldShortDescription)
	}
	if m.description != nil {
		fields = append(fields, appinfo.FieldDescription)
	}
	if m.icon_image_url != nil {
		fields = append(fields, appinfo.FieldIconImageURL)
	}
	if m.background_image_url != nil {
		fields = append(fields, appinfo.FieldBackgroundImageURL)
	}
	if m.cover_image_url != nil {
		fields = append(fields, appinfo.FieldCoverImageURL)
	}
	if m.release_date != nil {
		fields = append(fields, appinfo.FieldReleaseDate)
	}
	if m.developer != nil {
		fields = append(fields, appinfo.FieldDeveloper)
	}
	if m.publisher != nil {
		fields = append(fields, appinfo.FieldPublisher)
	}
	if m.version != nil {
		fields = append(fields, appinfo.FieldVersion)
	}
	if m.updated_at != nil {
		fields = append(fields, appinfo.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, appinfo.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appinfo.FieldInternal:
		return m.Internal()
	case appinfo.FieldSource:
		return m.Source()
	case appinfo.FieldSourceAppID:
		return m.SourceAppID()
	case appinfo.FieldSourceURL:
		return m.SourceURL()
	case appinfo.FieldName:
		return m.Name()
	case appinfo.FieldType:
		return m.GetType()
	case appinfo.FieldShortDescription:
		return m.ShortDescription()
	case appinfo.FieldDescription:
		return m.Description()
	case appinfo.FieldIconImageURL:
		return m.IconImageURL()
	case appinfo.FieldBackgroundImageURL:
		return m.BackgroundImageURL()
	case appinfo.FieldCoverImageURL:
		return m.CoverImageURL()
	case appinfo.FieldReleaseDate:
		return m.ReleaseDate()
	case appinfo.FieldDeveloper:
		return m.Developer()
	case appinfo.FieldPublisher:
		return m.Publisher()
	case appinfo.FieldVersion:
		return m.Version()
	case appinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case appinfo.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appinfo.FieldInternal:
		return m.OldInternal(ctx)
	case appinfo.FieldSource:
		return m.OldSource(ctx)
	case appinfo.FieldSourceAppID:
		return m.OldSourceAppID(ctx)
	case appinfo.FieldSourceURL:
		return m.OldSourceURL(ctx)
	case appinfo.FieldName:
		return m.OldName(ctx)
	case appinfo.FieldType:
		return m.OldType(ctx)
	case appinfo.FieldShortDescription:
		return m.OldShortDescription(ctx)
	case appinfo.FieldDescription:
		return m.OldDescription(ctx)
	case appinfo.FieldIconImageURL:
		return m.OldIconImageURL(ctx)
	case appinfo.FieldBackgroundImageURL:
		return m.OldBackgroundImageURL(ctx)
	case appinfo.FieldCoverImageURL:
		return m.OldCoverImageURL(ctx)
	case appinfo.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case appinfo.FieldDeveloper:
		return m.OldDeveloper(ctx)
	case appinfo.FieldPublisher:
		return m.OldPublisher(ctx)
	case appinfo.FieldVersion:
		return m.OldVersion(ctx)
	case appinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appinfo.FieldInternal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternal(v)
		return nil
	case appinfo.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case appinfo.FieldSourceAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceAppID(v)
		return nil
	case appinfo.FieldSourceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceURL(v)
		return nil
	case appinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appinfo.FieldType:
		v, ok := value.(appinfo.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case appinfo.FieldShortDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortDescription(v)
		return nil
	case appinfo.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case appinfo.FieldIconImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconImageURL(v)
		return nil
	case appinfo.FieldBackgroundImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundImageURL(v)
		return nil
	case appinfo.FieldCoverImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImageURL(v)
		return nil
	case appinfo.FieldReleaseDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case appinfo.FieldDeveloper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeveloper(v)
		return nil
	case appinfo.FieldPublisher:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisher(v)
		return nil
	case appinfo.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case appinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appinfo.FieldSourceURL) {
		fields = append(fields, appinfo.FieldSourceURL)
	}
	if m.FieldCleared(appinfo.FieldShortDescription) {
		fields = append(fields, appinfo.FieldShortDescription)
	}
	if m.FieldCleared(appinfo.FieldDescription) {
		fields = append(fields, appinfo.FieldDescription)
	}
	if m.FieldCleared(appinfo.FieldIconImageURL) {
		fields = append(fields, appinfo.FieldIconImageURL)
	}
	if m.FieldCleared(appinfo.FieldBackgroundImageURL) {
		fields = append(fields, appinfo.FieldBackgroundImageURL)
	}
	if m.FieldCleared(appinfo.FieldCoverImageURL) {
		fields = append(fields, appinfo.FieldCoverImageURL)
	}
	if m.FieldCleared(appinfo.FieldReleaseDate) {
		fields = append(fields, appinfo.FieldReleaseDate)
	}
	if m.FieldCleared(appinfo.FieldDeveloper) {
		fields = append(fields, appinfo.FieldDeveloper)
	}
	if m.FieldCleared(appinfo.FieldPublisher) {
		fields = append(fields, appinfo.FieldPublisher)
	}
	if m.FieldCleared(appinfo.FieldVersion) {
		fields = append(fields, appinfo.FieldVersion)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppInfoMutation) ClearField(name string) error {
	switch name {
	case appinfo.FieldSourceURL:
		m.ClearSourceURL()
		return nil
	case appinfo.FieldShortDescription:
		m.ClearShortDescription()
		return nil
	case appinfo.FieldDescription:
		m.ClearDescription()
		return nil
	case appinfo.FieldIconImageURL:
		m.ClearIconImageURL()
		return nil
	case appinfo.FieldBackgroundImageURL:
		m.ClearBackgroundImageURL()
		return nil
	case appinfo.FieldCoverImageURL:
		m.ClearCoverImageURL()
		return nil
	case appinfo.FieldReleaseDate:
		m.ClearReleaseDate()
		return nil
	case appinfo.FieldDeveloper:
		m.ClearDeveloper()
		return nil
	case appinfo.FieldPublisher:
		m.ClearPublisher()
		return nil
	case appinfo.FieldVersion:
		m.ClearVersion()
		return nil
	}
	return fmt.Errorf("unknown AppInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppInfoMutation) ResetField(name string) error {
	switch name {
	case appinfo.FieldInternal:
		m.ResetInternal()
		return nil
	case appinfo.FieldSource:
		m.ResetSource()
		return nil
	case appinfo.FieldSourceAppID:
		m.ResetSourceAppID()
		return nil
	case appinfo.FieldSourceURL:
		m.ResetSourceURL()
		return nil
	case appinfo.FieldName:
		m.ResetName()
		return nil
	case appinfo.FieldType:
		m.ResetType()
		return nil
	case appinfo.FieldShortDescription:
		m.ResetShortDescription()
		return nil
	case appinfo.FieldDescription:
		m.ResetDescription()
		return nil
	case appinfo.FieldIconImageURL:
		m.ResetIconImageURL()
		return nil
	case appinfo.FieldBackgroundImageURL:
		m.ResetBackgroundImageURL()
		return nil
	case appinfo.FieldCoverImageURL:
		m.ResetCoverImageURL()
		return nil
	case appinfo.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case appinfo.FieldDeveloper:
		m.ResetDeveloper()
		return nil
	case appinfo.FieldPublisher:
		m.ResetPublisher()
		return nil
	case appinfo.FieldVersion:
		m.ResetVersion()
		return nil
	case appinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.purchased_by_account != nil {
		edges = append(edges, appinfo.EdgePurchasedByAccount)
	}
	if m.purchased_by_user != nil {
		edges = append(edges, appinfo.EdgePurchasedByUser)
	}
	if m.app != nil {
		edges = append(edges, appinfo.EdgeApp)
	}
	if m.app_binary != nil {
		edges = append(edges, appinfo.EdgeAppBinary)
	}
	if m.bind_internal != nil {
		edges = append(edges, appinfo.EdgeBindInternal)
	}
	if m.bind_external != nil {
		edges = append(edges, appinfo.EdgeBindExternal)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appinfo.EdgePurchasedByAccount:
		ids := make([]ent.Value, 0, len(m.purchased_by_account))
		for id := range m.purchased_by_account {
			ids = append(ids, id)
		}
		return ids
	case appinfo.EdgePurchasedByUser:
		ids := make([]ent.Value, 0, len(m.purchased_by_user))
		for id := range m.purchased_by_user {
			ids = append(ids, id)
		}
		return ids
	case appinfo.EdgeApp:
		ids := make([]ent.Value, 0, len(m.app))
		for id := range m.app {
			ids = append(ids, id)
		}
		return ids
	case appinfo.EdgeAppBinary:
		ids := make([]ent.Value, 0, len(m.app_binary))
		for id := range m.app_binary {
			ids = append(ids, id)
		}
		return ids
	case appinfo.EdgeBindInternal:
		if id := m.bind_internal; id != nil {
			return []ent.Value{*id}
		}
	case appinfo.EdgeBindExternal:
		ids := make([]ent.Value, 0, len(m.bind_external))
		for id := range m.bind_external {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedpurchased_by_account != nil {
		edges = append(edges, appinfo.EdgePurchasedByAccount)
	}
	if m.removedpurchased_by_user != nil {
		edges = append(edges, appinfo.EdgePurchasedByUser)
	}
	if m.removedapp != nil {
		edges = append(edges, appinfo.EdgeApp)
	}
	if m.removedapp_binary != nil {
		edges = append(edges, appinfo.EdgeAppBinary)
	}
	if m.removedbind_external != nil {
		edges = append(edges, appinfo.EdgeBindExternal)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case appinfo.EdgePurchasedByAccount:
		ids := make([]ent.Value, 0, len(m.removedpurchased_by_account))
		for id := range m.removedpurchased_by_account {
			ids = append(ids, id)
		}
		return ids
	case appinfo.EdgePurchasedByUser:
		ids := make([]ent.Value, 0, len(m.removedpurchased_by_user))
		for id := range m.removedpurchased_by_user {
			ids = append(ids, id)
		}
		return ids
	case appinfo.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removedapp))
		for id := range m.removedapp {
			ids = append(ids, id)
		}
		return ids
	case appinfo.EdgeAppBinary:
		ids := make([]ent.Value, 0, len(m.removedapp_binary))
		for id := range m.removedapp_binary {
			ids = append(ids, id)
		}
		return ids
	case appinfo.EdgeBindExternal:
		ids := make([]ent.Value, 0, len(m.removedbind_external))
		for id := range m.removedbind_external {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedpurchased_by_account {
		edges = append(edges, appinfo.EdgePurchasedByAccount)
	}
	if m.clearedpurchased_by_user {
		edges = append(edges, appinfo.EdgePurchasedByUser)
	}
	if m.clearedapp {
		edges = append(edges, appinfo.EdgeApp)
	}
	if m.clearedapp_binary {
		edges = append(edges, appinfo.EdgeAppBinary)
	}
	if m.clearedbind_internal {
		edges = append(edges, appinfo.EdgeBindInternal)
	}
	if m.clearedbind_external {
		edges = append(edges, appinfo.EdgeBindExternal)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case appinfo.EdgePurchasedByAccount:
		return m.clearedpurchased_by_account
	case appinfo.EdgePurchasedByUser:
		return m.clearedpurchased_by_user
	case appinfo.EdgeApp:
		return m.clearedapp
	case appinfo.EdgeAppBinary:
		return m.clearedapp_binary
	case appinfo.EdgeBindInternal:
		return m.clearedbind_internal
	case appinfo.EdgeBindExternal:
		return m.clearedbind_external
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppInfoMutation) ClearEdge(name string) error {
	switch name {
	case appinfo.EdgeBindInternal:
		m.ClearBindInternal()
		return nil
	}
	return fmt.Errorf("unknown AppInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppInfoMutation) ResetEdge(name string) error {
	switch name {
	case appinfo.EdgePurchasedByAccount:
		m.ResetPurchasedByAccount()
		return nil
	case appinfo.EdgePurchasedByUser:
		m.ResetPurchasedByUser()
		return nil
	case appinfo.EdgeApp:
		m.ResetApp()
		return nil
	case appinfo.EdgeAppBinary:
		m.ResetAppBinary()
		return nil
	case appinfo.EdgeBindInternal:
		m.ResetBindInternal()
		return nil
	case appinfo.EdgeBindExternal:
		m.ResetBindExternal()
		return nil
	}
	return fmt.Errorf("unknown AppInfo edge %s", name)
}

// AppInstMutation represents an operation that mutates the AppInst nodes in the graph.
type AppInstMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	device_id     *model.InternalID
	adddevice_id  *model.InternalID
	app_id        *model.InternalID
	addapp_id     *model.InternalID
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *model.InternalID
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*AppInst, error)
	predicates    []predicate.AppInst
}

var _ ent.Mutation = (*AppInstMutation)(nil)

// appinstOption allows management of the mutation configuration using functional options.
type appinstOption func(*AppInstMutation)

// newAppInstMutation creates new mutation for the AppInst entity.
func newAppInstMutation(c config, op Op, opts ...appinstOption) *AppInstMutation {
	m := &AppInstMutation{
		config:        c,
		op:            op,
		typ:           TypeAppInst,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppInstID sets the ID field of the mutation.
func withAppInstID(id model.InternalID) appinstOption {
	return func(m *AppInstMutation) {
		var (
			err   error
			once  sync.Once
			value *AppInst
		)
		m.oldValue = func(ctx context.Context) (*AppInst, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppInst.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppInst sets the old AppInst of the mutation.
func withAppInst(node *AppInst) appinstOption {
	return func(m *AppInstMutation) {
		m.oldValue = func(context.Context) (*AppInst, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppInstMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppInstMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppInst entities.
func (m *AppInstMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppInstMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppInstMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppInst.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeviceID sets the "device_id" field.
func (m *AppInstMutation) SetDeviceID(mi model.InternalID) {
	m.device_id = &mi
	m.adddevice_id = nil
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *AppInstMutation) DeviceID() (r model.InternalID, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the AppInst entity.
// If the AppInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstMutation) OldDeviceID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// AddDeviceID adds mi to the "device_id" field.
func (m *AppInstMutation) AddDeviceID(mi model.InternalID) {
	if m.adddevice_id != nil {
		*m.adddevice_id += mi
	} else {
		m.adddevice_id = &mi
	}
}

// AddedDeviceID returns the value that was added to the "device_id" field in this mutation.
func (m *AppInstMutation) AddedDeviceID() (r model.InternalID, exists bool) {
	v := m.adddevice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *AppInstMutation) ResetDeviceID() {
	m.device_id = nil
	m.adddevice_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppInstMutation) SetAppID(mi model.InternalID) {
	m.app_id = &mi
	m.addapp_id = nil
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppInstMutation) AppID() (r model.InternalID, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppInst entity.
// If the AppInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstMutation) OldAppID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// AddAppID adds mi to the "app_id" field.
func (m *AppInstMutation) AddAppID(mi model.InternalID) {
	if m.addapp_id != nil {
		*m.addapp_id += mi
	} else {
		m.addapp_id = &mi
	}
}

// AddedAppID returns the value that was added to the "app_id" field in this mutation.
func (m *AppInstMutation) AddedAppID() (r model.InternalID, exists bool) {
	v := m.addapp_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppInstMutation) ResetAppID() {
	m.app_id = nil
	m.addapp_id = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppInstMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppInstMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppInst entity.
// If the AppInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppInstMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppInstMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppInstMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppInst entity.
// If the AppInst object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppInstMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *AppInstMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *AppInstMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *AppInstMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AppInstMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AppInstMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AppInstMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the AppInstMutation builder.
func (m *AppInstMutation) Where(ps ...predicate.AppInst) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppInstMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppInstMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppInst, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppInstMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppInstMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppInst).
func (m *AppInstMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppInstMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.device_id != nil {
		fields = append(fields, appinst.FieldDeviceID)
	}
	if m.app_id != nil {
		fields = append(fields, appinst.FieldAppID)
	}
	if m.updated_at != nil {
		fields = append(fields, appinst.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, appinst.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppInstMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appinst.FieldDeviceID:
		return m.DeviceID()
	case appinst.FieldAppID:
		return m.AppID()
	case appinst.FieldUpdatedAt:
		return m.UpdatedAt()
	case appinst.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppInstMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appinst.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case appinst.FieldAppID:
		return m.OldAppID(ctx)
	case appinst.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appinst.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppInst field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppInstMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appinst.FieldDeviceID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case appinst.FieldAppID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appinst.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appinst.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppInst field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppInstMutation) AddedFields() []string {
	var fields []string
	if m.adddevice_id != nil {
		fields = append(fields, appinst.FieldDeviceID)
	}
	if m.addapp_id != nil {
		fields = append(fields, appinst.FieldAppID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppInstMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appinst.FieldDeviceID:
		return m.AddedDeviceID()
	case appinst.FieldAppID:
		return m.AddedAppID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppInstMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appinst.FieldDeviceID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceID(v)
		return nil
	case appinst.FieldAppID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppID(v)
		return nil
	}
	return fmt.Errorf("unknown AppInst numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppInstMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppInstMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppInstMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppInst nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppInstMutation) ResetField(name string) error {
	switch name {
	case appinst.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case appinst.FieldAppID:
		m.ResetAppID()
		return nil
	case appinst.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appinst.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppInst field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppInstMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, appinst.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppInstMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appinst.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppInstMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppInstMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppInstMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, appinst.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppInstMutation) EdgeCleared(name string) bool {
	switch name {
	case appinst.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppInstMutation) ClearEdge(name string) error {
	switch name {
	case appinst.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown AppInst unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppInstMutation) ResetEdge(name string) error {
	switch name {
	case appinst.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown AppInst edge %s", name)
}

// AppInstRunTimeMutation represents an operation that mutates the AppInstRunTime nodes in the graph.
type AppInstRunTimeMutation struct {
	config
	op              Op
	typ             string
	id              *int
	user_id         *model.InternalID
	adduser_id      *model.InternalID
	app_inst_id     *model.InternalID
	addapp_inst_id  *model.InternalID
	start_time      *time.Time
	run_duration    *time.Duration
	addrun_duration *time.Duration
	updated_at      *time.Time
	created_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*AppInstRunTime, error)
	predicates      []predicate.AppInstRunTime
}

var _ ent.Mutation = (*AppInstRunTimeMutation)(nil)

// appinstruntimeOption allows management of the mutation configuration using functional options.
type appinstruntimeOption func(*AppInstRunTimeMutation)

// newAppInstRunTimeMutation creates new mutation for the AppInstRunTime entity.
func newAppInstRunTimeMutation(c config, op Op, opts ...appinstruntimeOption) *AppInstRunTimeMutation {
	m := &AppInstRunTimeMutation{
		config:        c,
		op:            op,
		typ:           TypeAppInstRunTime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppInstRunTimeID sets the ID field of the mutation.
func withAppInstRunTimeID(id int) appinstruntimeOption {
	return func(m *AppInstRunTimeMutation) {
		var (
			err   error
			once  sync.Once
			value *AppInstRunTime
		)
		m.oldValue = func(ctx context.Context) (*AppInstRunTime, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppInstRunTime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppInstRunTime sets the old AppInstRunTime of the mutation.
func withAppInstRunTime(node *AppInstRunTime) appinstruntimeOption {
	return func(m *AppInstRunTimeMutation) {
		m.oldValue = func(context.Context) (*AppInstRunTime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppInstRunTimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppInstRunTimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppInstRunTimeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppInstRunTimeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppInstRunTime.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AppInstRunTimeMutation) SetUserID(mi model.InternalID) {
	m.user_id = &mi
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppInstRunTimeMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppInstRunTime entity.
// If the AppInstRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstRunTimeMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds mi to the "user_id" field.
func (m *AppInstRunTimeMutation) AddUserID(mi model.InternalID) {
	if m.adduser_id != nil {
		*m.adduser_id += mi
	} else {
		m.adduser_id = &mi
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AppInstRunTimeMutation) AddedUserID() (r model.InternalID, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppInstRunTimeMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetAppInstID sets the "app_inst_id" field.
func (m *AppInstRunTimeMutation) SetAppInstID(mi model.InternalID) {
	m.app_inst_id = &mi
	m.addapp_inst_id = nil
}

// AppInstID returns the value of the "app_inst_id" field in the mutation.
func (m *AppInstRunTimeMutation) AppInstID() (r model.InternalID, exists bool) {
	v := m.app_inst_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppInstID returns the old "app_inst_id" field's value of the AppInstRunTime entity.
// If the AppInstRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstRunTimeMutation) OldAppInstID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppInstID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppInstID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppInstID: %w", err)
	}
	return oldValue.AppInstID, nil
}

// AddAppInstID adds mi to the "app_inst_id" field.
func (m *AppInstRunTimeMutation) AddAppInstID(mi model.InternalID) {
	if m.addapp_inst_id != nil {
		*m.addapp_inst_id += mi
	} else {
		m.addapp_inst_id = &mi
	}
}

// AddedAppInstID returns the value that was added to the "app_inst_id" field in this mutation.
func (m *AppInstRunTimeMutation) AddedAppInstID() (r model.InternalID, exists bool) {
	v := m.addapp_inst_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppInstID resets all changes to the "app_inst_id" field.
func (m *AppInstRunTimeMutation) ResetAppInstID() {
	m.app_inst_id = nil
	m.addapp_inst_id = nil
}

// SetStartTime sets the "start_time" field.
func (m *AppInstRunTimeMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *AppInstRunTimeMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the AppInstRunTime entity.
// If the AppInstRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstRunTimeMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *AppInstRunTimeMutation) ResetStartTime() {
	m.start_time = nil
}

// SetRunDuration sets the "run_duration" field.
func (m *AppInstRunTimeMutation) SetRunDuration(t time.Duration) {
	m.run_duration = &t
	m.addrun_duration = nil
}

// RunDuration returns the value of the "run_duration" field in the mutation.
func (m *AppInstRunTimeMutation) RunDuration() (r time.Duration, exists bool) {
	v := m.run_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldRunDuration returns the old "run_duration" field's value of the AppInstRunTime entity.
// If the AppInstRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstRunTimeMutation) OldRunDuration(ctx context.Context) (v time.Duration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRunDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRunDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRunDuration: %w", err)
	}
	return oldValue.RunDuration, nil
}

// AddRunDuration adds t to the "run_duration" field.
func (m *AppInstRunTimeMutation) AddRunDuration(t time.Duration) {
	if m.addrun_duration != nil {
		*m.addrun_duration += t
	} else {
		m.addrun_duration = &t
	}
}

// AddedRunDuration returns the value that was added to the "run_duration" field in this mutation.
func (m *AppInstRunTimeMutation) AddedRunDuration() (r time.Duration, exists bool) {
	v := m.addrun_duration
	if v == nil {
		return
	}
	return *v, true
}

// ResetRunDuration resets all changes to the "run_duration" field.
func (m *AppInstRunTimeMutation) ResetRunDuration() {
	m.run_duration = nil
	m.addrun_duration = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppInstRunTimeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppInstRunTimeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppInstRunTime entity.
// If the AppInstRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstRunTimeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppInstRunTimeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppInstRunTimeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppInstRunTimeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppInstRunTime entity.
// If the AppInstRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInstRunTimeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppInstRunTimeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the AppInstRunTimeMutation builder.
func (m *AppInstRunTimeMutation) Where(ps ...predicate.AppInstRunTime) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppInstRunTimeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppInstRunTimeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppInstRunTime, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppInstRunTimeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppInstRunTimeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppInstRunTime).
func (m *AppInstRunTimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppInstRunTimeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user_id != nil {
		fields = append(fields, appinstruntime.FieldUserID)
	}
	if m.app_inst_id != nil {
		fields = append(fields, appinstruntime.FieldAppInstID)
	}
	if m.start_time != nil {
		fields = append(fields, appinstruntime.FieldStartTime)
	}
	if m.run_duration != nil {
		fields = append(fields, appinstruntime.FieldRunDuration)
	}
	if m.updated_at != nil {
		fields = append(fields, appinstruntime.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, appinstruntime.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppInstRunTimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appinstruntime.FieldUserID:
		return m.UserID()
	case appinstruntime.FieldAppInstID:
		return m.AppInstID()
	case appinstruntime.FieldStartTime:
		return m.StartTime()
	case appinstruntime.FieldRunDuration:
		return m.RunDuration()
	case appinstruntime.FieldUpdatedAt:
		return m.UpdatedAt()
	case appinstruntime.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppInstRunTimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appinstruntime.FieldUserID:
		return m.OldUserID(ctx)
	case appinstruntime.FieldAppInstID:
		return m.OldAppInstID(ctx)
	case appinstruntime.FieldStartTime:
		return m.OldStartTime(ctx)
	case appinstruntime.FieldRunDuration:
		return m.OldRunDuration(ctx)
	case appinstruntime.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appinstruntime.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppInstRunTime field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppInstRunTimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appinstruntime.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appinstruntime.FieldAppInstID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppInstID(v)
		return nil
	case appinstruntime.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case appinstruntime.FieldRunDuration:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRunDuration(v)
		return nil
	case appinstruntime.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appinstruntime.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppInstRunTime field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppInstRunTimeMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, appinstruntime.FieldUserID)
	}
	if m.addapp_inst_id != nil {
		fields = append(fields, appinstruntime.FieldAppInstID)
	}
	if m.addrun_duration != nil {
		fields = append(fields, appinstruntime.FieldRunDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppInstRunTimeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appinstruntime.FieldUserID:
		return m.AddedUserID()
	case appinstruntime.FieldAppInstID:
		return m.AddedAppInstID()
	case appinstruntime.FieldRunDuration:
		return m.AddedRunDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppInstRunTimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appinstruntime.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case appinstruntime.FieldAppInstID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppInstID(v)
		return nil
	case appinstruntime.FieldRunDuration:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRunDuration(v)
		return nil
	}
	return fmt.Errorf("unknown AppInstRunTime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppInstRunTimeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppInstRunTimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppInstRunTimeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppInstRunTime nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppInstRunTimeMutation) ResetField(name string) error {
	switch name {
	case appinstruntime.FieldUserID:
		m.ResetUserID()
		return nil
	case appinstruntime.FieldAppInstID:
		m.ResetAppInstID()
		return nil
	case appinstruntime.FieldStartTime:
		m.ResetStartTime()
		return nil
	case appinstruntime.FieldRunDuration:
		m.ResetRunDuration()
		return nil
	case appinstruntime.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appinstruntime.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppInstRunTime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppInstRunTimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppInstRunTimeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppInstRunTimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppInstRunTimeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppInstRunTimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppInstRunTimeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppInstRunTimeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppInstRunTime unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppInstRunTimeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppInstRunTime edge %s", name)
}

// DeviceInfoMutation represents an operation that mutates the DeviceInfo nodes in the graph.
type DeviceInfoMutation struct {
	config
	op                         Op
	typ                        string
	id                         *model.InternalID
	device_name                *string
	system_type                *deviceinfo.SystemType
	system_version             *string
	client_name                *string
	client_source_code_address *string
	client_version             *string
	updated_at                 *time.Time
	created_at                 *time.Time
	clearedFields              map[string]struct{}
	user                       map[model.InternalID]struct{}
	removeduser                map[model.InternalID]struct{}
	cleareduser                bool
	user_session               map[model.InternalID]struct{}
	removeduser_session        map[model.InternalID]struct{}
	cleareduser_session        bool
	user_device                map[int]struct{}
	removeduser_device         map[int]struct{}
	cleareduser_device         bool
	done                       bool
	oldValue                   func(context.Context) (*DeviceInfo, error)
	predicates                 []predicate.DeviceInfo
}

var _ ent.Mutation = (*DeviceInfoMutation)(nil)

// deviceinfoOption allows management of the mutation configuration using functional options.
type deviceinfoOption func(*DeviceInfoMutation)

// newDeviceInfoMutation creates new mutation for the DeviceInfo entity.
func newDeviceInfoMutation(c config, op Op, opts ...deviceinfoOption) *DeviceInfoMutation {
	m := &DeviceInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeDeviceInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceInfoID sets the ID field of the mutation.
func withDeviceInfoID(id model.InternalID) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *DeviceInfo
		)
		m.oldValue = func(ctx context.Context) (*DeviceInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeviceInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeviceInfo sets the old DeviceInfo of the mutation.
func withDeviceInfo(node *DeviceInfo) deviceinfoOption {
	return func(m *DeviceInfoMutation) {
		m.oldValue = func(context.Context) (*DeviceInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeviceInfo entities.
func (m *DeviceInfoMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceInfoMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceInfoMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeviceInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeviceName sets the "device_name" field.
func (m *DeviceInfoMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *DeviceInfoMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldDeviceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *DeviceInfoMutation) ResetDeviceName() {
	m.device_name = nil
}

// SetSystemType sets the "system_type" field.
func (m *DeviceInfoMutation) SetSystemType(dt deviceinfo.SystemType) {
	m.system_type = &dt
}

// SystemType returns the value of the "system_type" field in the mutation.
func (m *DeviceInfoMutation) SystemType() (r deviceinfo.SystemType, exists bool) {
	v := m.system_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemType returns the old "system_type" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldSystemType(ctx context.Context) (v deviceinfo.SystemType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemType: %w", err)
	}
	return oldValue.SystemType, nil
}

// ResetSystemType resets all changes to the "system_type" field.
func (m *DeviceInfoMutation) ResetSystemType() {
	m.system_type = nil
}

// SetSystemVersion sets the "system_version" field.
func (m *DeviceInfoMutation) SetSystemVersion(s string) {
	m.system_version = &s
}

// SystemVersion returns the value of the "system_version" field in the mutation.
func (m *DeviceInfoMutation) SystemVersion() (r string, exists bool) {
	v := m.system_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemVersion returns the old "system_version" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldSystemVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemVersion: %w", err)
	}
	return oldValue.SystemVersion, nil
}

// ResetSystemVersion resets all changes to the "system_version" field.
func (m *DeviceInfoMutation) ResetSystemVersion() {
	m.system_version = nil
}

// SetClientName sets the "client_name" field.
func (m *DeviceInfoMutation) SetClientName(s string) {
	m.client_name = &s
}

// ClientName returns the value of the "client_name" field in the mutation.
func (m *DeviceInfoMutation) ClientName() (r string, exists bool) {
	v := m.client_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientName returns the old "client_name" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldClientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientName: %w", err)
	}
	return oldValue.ClientName, nil
}

// ResetClientName resets all changes to the "client_name" field.
func (m *DeviceInfoMutation) ResetClientName() {
	m.client_name = nil
}

// SetClientSourceCodeAddress sets the "client_source_code_address" field.
func (m *DeviceInfoMutation) SetClientSourceCodeAddress(s string) {
	m.client_source_code_address = &s
}

// ClientSourceCodeAddress returns the value of the "client_source_code_address" field in the mutation.
func (m *DeviceInfoMutation) ClientSourceCodeAddress() (r string, exists bool) {
	v := m.client_source_code_address
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSourceCodeAddress returns the old "client_source_code_address" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldClientSourceCodeAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSourceCodeAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSourceCodeAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSourceCodeAddress: %w", err)
	}
	return oldValue.ClientSourceCodeAddress, nil
}

// ResetClientSourceCodeAddress resets all changes to the "client_source_code_address" field.
func (m *DeviceInfoMutation) ResetClientSourceCodeAddress() {
	m.client_source_code_address = nil
}

// SetClientVersion sets the "client_version" field.
func (m *DeviceInfoMutation) SetClientVersion(s string) {
	m.client_version = &s
}

// ClientVersion returns the value of the "client_version" field in the mutation.
func (m *DeviceInfoMutation) ClientVersion() (r string, exists bool) {
	v := m.client_version
	if v == nil {
		return
	}
	return *v, true
}

// OldClientVersion returns the old "client_version" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldClientVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientVersion: %w", err)
	}
	return oldValue.ClientVersion, nil
}

// ResetClientVersion resets all changes to the "client_version" field.
func (m *DeviceInfoMutation) ResetClientVersion() {
	m.client_version = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeviceInfo entity.
// If the DeviceInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *DeviceInfoMutation) AddUserIDs(ids ...model.InternalID) {
	if m.user == nil {
		m.user = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *DeviceInfoMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DeviceInfoMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *DeviceInfoMutation) RemoveUserIDs(ids ...model.InternalID) {
	if m.removeduser == nil {
		m.removeduser = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *DeviceInfoMutation) RemovedUserIDs() (ids []model.InternalID) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *DeviceInfoMutation) UserIDs() (ids []model.InternalID) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DeviceInfoMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddUserSessionIDs adds the "user_session" edge to the UserSession entity by ids.
func (m *DeviceInfoMutation) AddUserSessionIDs(ids ...model.InternalID) {
	if m.user_session == nil {
		m.user_session = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.user_session[ids[i]] = struct{}{}
	}
}

// ClearUserSession clears the "user_session" edge to the UserSession entity.
func (m *DeviceInfoMutation) ClearUserSession() {
	m.cleareduser_session = true
}

// UserSessionCleared reports if the "user_session" edge to the UserSession entity was cleared.
func (m *DeviceInfoMutation) UserSessionCleared() bool {
	return m.cleareduser_session
}

// RemoveUserSessionIDs removes the "user_session" edge to the UserSession entity by IDs.
func (m *DeviceInfoMutation) RemoveUserSessionIDs(ids ...model.InternalID) {
	if m.removeduser_session == nil {
		m.removeduser_session = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.user_session, ids[i])
		m.removeduser_session[ids[i]] = struct{}{}
	}
}

// RemovedUserSession returns the removed IDs of the "user_session" edge to the UserSession entity.
func (m *DeviceInfoMutation) RemovedUserSessionIDs() (ids []model.InternalID) {
	for id := range m.removeduser_session {
		ids = append(ids, id)
	}
	return
}

// UserSessionIDs returns the "user_session" edge IDs in the mutation.
func (m *DeviceInfoMutation) UserSessionIDs() (ids []model.InternalID) {
	for id := range m.user_session {
		ids = append(ids, id)
	}
	return
}

// ResetUserSession resets all changes to the "user_session" edge.
func (m *DeviceInfoMutation) ResetUserSession() {
	m.user_session = nil
	m.cleareduser_session = false
	m.removeduser_session = nil
}

// AddUserDeviceIDs adds the "user_device" edge to the UserDevice entity by ids.
func (m *DeviceInfoMutation) AddUserDeviceIDs(ids ...int) {
	if m.user_device == nil {
		m.user_device = make(map[int]struct{})
	}
	for i := range ids {
		m.user_device[ids[i]] = struct{}{}
	}
}

// ClearUserDevice clears the "user_device" edge to the UserDevice entity.
func (m *DeviceInfoMutation) ClearUserDevice() {
	m.cleareduser_device = true
}

// UserDeviceCleared reports if the "user_device" edge to the UserDevice entity was cleared.
func (m *DeviceInfoMutation) UserDeviceCleared() bool {
	return m.cleareduser_device
}

// RemoveUserDeviceIDs removes the "user_device" edge to the UserDevice entity by IDs.
func (m *DeviceInfoMutation) RemoveUserDeviceIDs(ids ...int) {
	if m.removeduser_device == nil {
		m.removeduser_device = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_device, ids[i])
		m.removeduser_device[ids[i]] = struct{}{}
	}
}

// RemovedUserDevice returns the removed IDs of the "user_device" edge to the UserDevice entity.
func (m *DeviceInfoMutation) RemovedUserDeviceIDs() (ids []int) {
	for id := range m.removeduser_device {
		ids = append(ids, id)
	}
	return
}

// UserDeviceIDs returns the "user_device" edge IDs in the mutation.
func (m *DeviceInfoMutation) UserDeviceIDs() (ids []int) {
	for id := range m.user_device {
		ids = append(ids, id)
	}
	return
}

// ResetUserDevice resets all changes to the "user_device" edge.
func (m *DeviceInfoMutation) ResetUserDevice() {
	m.user_device = nil
	m.cleareduser_device = false
	m.removeduser_device = nil
}

// Where appends a list predicates to the DeviceInfoMutation builder.
func (m *DeviceInfoMutation) Where(ps ...predicate.DeviceInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeviceInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeviceInfo).
func (m *DeviceInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceInfoMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.device_name != nil {
		fields = append(fields, deviceinfo.FieldDeviceName)
	}
	if m.system_type != nil {
		fields = append(fields, deviceinfo.FieldSystemType)
	}
	if m.system_version != nil {
		fields = append(fields, deviceinfo.FieldSystemVersion)
	}
	if m.client_name != nil {
		fields = append(fields, deviceinfo.FieldClientName)
	}
	if m.client_source_code_address != nil {
		fields = append(fields, deviceinfo.FieldClientSourceCodeAddress)
	}
	if m.client_version != nil {
		fields = append(fields, deviceinfo.FieldClientVersion)
	}
	if m.updated_at != nil {
		fields = append(fields, deviceinfo.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, deviceinfo.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deviceinfo.FieldDeviceName:
		return m.DeviceName()
	case deviceinfo.FieldSystemType:
		return m.SystemType()
	case deviceinfo.FieldSystemVersion:
		return m.SystemVersion()
	case deviceinfo.FieldClientName:
		return m.ClientName()
	case deviceinfo.FieldClientSourceCodeAddress:
		return m.ClientSourceCodeAddress()
	case deviceinfo.FieldClientVersion:
		return m.ClientVersion()
	case deviceinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case deviceinfo.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deviceinfo.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case deviceinfo.FieldSystemType:
		return m.OldSystemType(ctx)
	case deviceinfo.FieldSystemVersion:
		return m.OldSystemVersion(ctx)
	case deviceinfo.FieldClientName:
		return m.OldClientName(ctx)
	case deviceinfo.FieldClientSourceCodeAddress:
		return m.OldClientSourceCodeAddress(ctx)
	case deviceinfo.FieldClientVersion:
		return m.OldClientVersion(ctx)
	case deviceinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deviceinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeviceInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deviceinfo.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case deviceinfo.FieldSystemType:
		v, ok := value.(deviceinfo.SystemType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemType(v)
		return nil
	case deviceinfo.FieldSystemVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemVersion(v)
		return nil
	case deviceinfo.FieldClientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientName(v)
		return nil
	case deviceinfo.FieldClientSourceCodeAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSourceCodeAddress(v)
		return nil
	case deviceinfo.FieldClientVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientVersion(v)
		return nil
	case deviceinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deviceinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceInfoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceInfoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceInfoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeviceInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceInfoMutation) ResetField(name string) error {
	switch name {
	case deviceinfo.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case deviceinfo.FieldSystemType:
		m.ResetSystemType()
		return nil
	case deviceinfo.FieldSystemVersion:
		m.ResetSystemVersion()
		return nil
	case deviceinfo.FieldClientName:
		m.ResetClientName()
		return nil
	case deviceinfo.FieldClientSourceCodeAddress:
		m.ResetClientSourceCodeAddress()
		return nil
	case deviceinfo.FieldClientVersion:
		m.ResetClientVersion()
		return nil
	case deviceinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deviceinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, deviceinfo.EdgeUser)
	}
	if m.user_session != nil {
		edges = append(edges, deviceinfo.EdgeUserSession)
	}
	if m.user_device != nil {
		edges = append(edges, deviceinfo.EdgeUserDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deviceinfo.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case deviceinfo.EdgeUserSession:
		ids := make([]ent.Value, 0, len(m.user_session))
		for id := range m.user_session {
			ids = append(ids, id)
		}
		return ids
	case deviceinfo.EdgeUserDevice:
		ids := make([]ent.Value, 0, len(m.user_device))
		for id := range m.user_device {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeduser != nil {
		edges = append(edges, deviceinfo.EdgeUser)
	}
	if m.removeduser_session != nil {
		edges = append(edges, deviceinfo.EdgeUserSession)
	}
	if m.removeduser_device != nil {
		edges = append(edges, deviceinfo.EdgeUserDevice)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deviceinfo.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case deviceinfo.EdgeUserSession:
		ids := make([]ent.Value, 0, len(m.removeduser_session))
		for id := range m.removeduser_session {
			ids = append(ids, id)
		}
		return ids
	case deviceinfo.EdgeUserDevice:
		ids := make([]ent.Value, 0, len(m.removeduser_device))
		for id := range m.removeduser_device {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, deviceinfo.EdgeUser)
	}
	if m.cleareduser_session {
		edges = append(edges, deviceinfo.EdgeUserSession)
	}
	if m.cleareduser_device {
		edges = append(edges, deviceinfo.EdgeUserDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case deviceinfo.EdgeUser:
		return m.cleareduser
	case deviceinfo.EdgeUserSession:
		return m.cleareduser_session
	case deviceinfo.EdgeUserDevice:
		return m.cleareduser_device
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DeviceInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceInfoMutation) ResetEdge(name string) error {
	switch name {
	case deviceinfo.EdgeUser:
		m.ResetUser()
		return nil
	case deviceinfo.EdgeUserSession:
		m.ResetUserSession()
		return nil
	case deviceinfo.EdgeUserDevice:
		m.ResetUserDevice()
		return nil
	}
	return fmt.Errorf("unknown DeviceInfo edge %s", name)
}

// FeedMutation represents an operation that mutates the Feed nodes in the graph.
type FeedMutation struct {
	config
	op             Op
	typ            string
	id             *model.InternalID
	title          *string
	link           *string
	description    *string
	language       *string
	authors        *[]*modelfeed.Person
	appendauthors  []*modelfeed.Person
	image          **modelfeed.Image
	updated_at     *time.Time
	created_at     *time.Time
	clearedFields  map[string]struct{}
	item           map[model.InternalID]struct{}
	removeditem    map[model.InternalID]struct{}
	cleareditem    bool
	_config        *model.InternalID
	cleared_config bool
	done           bool
	oldValue       func(context.Context) (*Feed, error)
	predicates     []predicate.Feed
}

var _ ent.Mutation = (*FeedMutation)(nil)

// feedOption allows management of the mutation configuration using functional options.
type feedOption func(*FeedMutation)

// newFeedMutation creates new mutation for the Feed entity.
func newFeedMutation(c config, op Op, opts ...feedOption) *FeedMutation {
	m := &FeedMutation{
		config:        c,
		op:            op,
		typ:           TypeFeed,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedID sets the ID field of the mutation.
func withFeedID(id model.InternalID) feedOption {
	return func(m *FeedMutation) {
		var (
			err   error
			once  sync.Once
			value *Feed
		)
		m.oldValue = func(ctx context.Context) (*Feed, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feed.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeed sets the old Feed of the mutation.
func withFeed(node *Feed) feedOption {
	return func(m *FeedMutation) {
		m.oldValue = func(context.Context) (*Feed, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Feed entities.
func (m *FeedMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feed.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *FeedMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *FeedMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *FeedMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[feed.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *FeedMutation) TitleCleared() bool {
	_, ok := m.clearedFields[feed.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *FeedMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, feed.FieldTitle)
}

// SetLink sets the "link" field.
func (m *FeedMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *FeedMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *FeedMutation) ClearLink() {
	m.link = nil
	m.clearedFields[feed.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *FeedMutation) LinkCleared() bool {
	_, ok := m.clearedFields[feed.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *FeedMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, feed.FieldLink)
}

// SetDescription sets the "description" field.
func (m *FeedMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeedMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeedMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[feed.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeedMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[feed.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeedMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, feed.FieldDescription)
}

// SetLanguage sets the "language" field.
func (m *FeedMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *FeedMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *FeedMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[feed.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *FeedMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[feed.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *FeedMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, feed.FieldLanguage)
}

// SetAuthors sets the "authors" field.
func (m *FeedMutation) SetAuthors(value []*modelfeed.Person) {
	m.authors = &value
	m.appendauthors = nil
}

// Authors returns the value of the "authors" field in the mutation.
func (m *FeedMutation) Authors() (r []*modelfeed.Person, exists bool) {
	v := m.authors
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthors returns the old "authors" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldAuthors(ctx context.Context) (v []*modelfeed.Person, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthors: %w", err)
	}
	return oldValue.Authors, nil
}

// AppendAuthors adds value to the "authors" field.
func (m *FeedMutation) AppendAuthors(value []*modelfeed.Person) {
	m.appendauthors = append(m.appendauthors, value...)
}

// AppendedAuthors returns the list of values that were appended to the "authors" field in this mutation.
func (m *FeedMutation) AppendedAuthors() ([]*modelfeed.Person, bool) {
	if len(m.appendauthors) == 0 {
		return nil, false
	}
	return m.appendauthors, true
}

// ClearAuthors clears the value of the "authors" field.
func (m *FeedMutation) ClearAuthors() {
	m.authors = nil
	m.appendauthors = nil
	m.clearedFields[feed.FieldAuthors] = struct{}{}
}

// AuthorsCleared returns if the "authors" field was cleared in this mutation.
func (m *FeedMutation) AuthorsCleared() bool {
	_, ok := m.clearedFields[feed.FieldAuthors]
	return ok
}

// ResetAuthors resets all changes to the "authors" field.
func (m *FeedMutation) ResetAuthors() {
	m.authors = nil
	m.appendauthors = nil
	delete(m.clearedFields, feed.FieldAuthors)
}

// SetImage sets the "image" field.
func (m *FeedMutation) SetImage(value *modelfeed.Image) {
	m.image = &value
}

// Image returns the value of the "image" field in the mutation.
func (m *FeedMutation) Image() (r *modelfeed.Image, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldImage(ctx context.Context) (v *modelfeed.Image, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *FeedMutation) ClearImage() {
	m.image = nil
	m.clearedFields[feed.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *FeedMutation) ImageCleared() bool {
	_, ok := m.clearedFields[feed.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *FeedMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, feed.FieldImage)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddItemIDs adds the "item" edge to the FeedItem entity by ids.
func (m *FeedMutation) AddItemIDs(ids ...model.InternalID) {
	if m.item == nil {
		m.item = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.item[ids[i]] = struct{}{}
	}
}

// ClearItem clears the "item" edge to the FeedItem entity.
func (m *FeedMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the FeedItem entity was cleared.
func (m *FeedMutation) ItemCleared() bool {
	return m.cleareditem
}

// RemoveItemIDs removes the "item" edge to the FeedItem entity by IDs.
func (m *FeedMutation) RemoveItemIDs(ids ...model.InternalID) {
	if m.removeditem == nil {
		m.removeditem = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.item, ids[i])
		m.removeditem[ids[i]] = struct{}{}
	}
}

// RemovedItem returns the removed IDs of the "item" edge to the FeedItem entity.
func (m *FeedMutation) RemovedItemIDs() (ids []model.InternalID) {
	for id := range m.removeditem {
		ids = append(ids, id)
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
func (m *FeedMutation) ItemIDs() (ids []model.InternalID) {
	for id := range m.item {
		ids = append(ids, id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *FeedMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
	m.removeditem = nil
}

// SetConfigID sets the "config" edge to the FeedConfig entity by id.
func (m *FeedMutation) SetConfigID(id model.InternalID) {
	m._config = &id
}

// ClearConfig clears the "config" edge to the FeedConfig entity.
func (m *FeedMutation) ClearConfig() {
	m.cleared_config = true
}

// ConfigCleared reports if the "config" edge to the FeedConfig entity was cleared.
func (m *FeedMutation) ConfigCleared() bool {
	return m.cleared_config
}

// ConfigID returns the "config" edge ID in the mutation.
func (m *FeedMutation) ConfigID() (id model.InternalID, exists bool) {
	if m._config != nil {
		return *m._config, true
	}
	return
}

// ConfigIDs returns the "config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConfigID instead. It exists only for internal usage by the builders.
func (m *FeedMutation) ConfigIDs() (ids []model.InternalID) {
	if id := m._config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfig resets all changes to the "config" edge.
func (m *FeedMutation) ResetConfig() {
	m._config = nil
	m.cleared_config = false
}

// Where appends a list predicates to the FeedMutation builder.
func (m *FeedMutation) Where(ps ...predicate.Feed) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feed, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feed).
func (m *FeedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.title != nil {
		fields = append(fields, feed.FieldTitle)
	}
	if m.link != nil {
		fields = append(fields, feed.FieldLink)
	}
	if m.description != nil {
		fields = append(fields, feed.FieldDescription)
	}
	if m.language != nil {
		fields = append(fields, feed.FieldLanguage)
	}
	if m.authors != nil {
		fields = append(fields, feed.FieldAuthors)
	}
	if m.image != nil {
		fields = append(fields, feed.FieldImage)
	}
	if m.updated_at != nil {
		fields = append(fields, feed.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feed.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feed.FieldTitle:
		return m.Title()
	case feed.FieldLink:
		return m.Link()
	case feed.FieldDescription:
		return m.Description()
	case feed.FieldLanguage:
		return m.Language()
	case feed.FieldAuthors:
		return m.Authors()
	case feed.FieldImage:
		return m.Image()
	case feed.FieldUpdatedAt:
		return m.UpdatedAt()
	case feed.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feed.FieldTitle:
		return m.OldTitle(ctx)
	case feed.FieldLink:
		return m.OldLink(ctx)
	case feed.FieldDescription:
		return m.OldDescription(ctx)
	case feed.FieldLanguage:
		return m.OldLanguage(ctx)
	case feed.FieldAuthors:
		return m.OldAuthors(ctx)
	case feed.FieldImage:
		return m.OldImage(ctx)
	case feed.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feed.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Feed field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feed.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case feed.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case feed.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feed.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case feed.FieldAuthors:
		v, ok := value.([]*modelfeed.Person)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthors(v)
		return nil
	case feed.FieldImage:
		v, ok := value.(*modelfeed.Image)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case feed.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feed.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Feed field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feed numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feed.FieldTitle) {
		fields = append(fields, feed.FieldTitle)
	}
	if m.FieldCleared(feed.FieldLink) {
		fields = append(fields, feed.FieldLink)
	}
	if m.FieldCleared(feed.FieldDescription) {
		fields = append(fields, feed.FieldDescription)
	}
	if m.FieldCleared(feed.FieldLanguage) {
		fields = append(fields, feed.FieldLanguage)
	}
	if m.FieldCleared(feed.FieldAuthors) {
		fields = append(fields, feed.FieldAuthors)
	}
	if m.FieldCleared(feed.FieldImage) {
		fields = append(fields, feed.FieldImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedMutation) ClearField(name string) error {
	switch name {
	case feed.FieldTitle:
		m.ClearTitle()
		return nil
	case feed.FieldLink:
		m.ClearLink()
		return nil
	case feed.FieldDescription:
		m.ClearDescription()
		return nil
	case feed.FieldLanguage:
		m.ClearLanguage()
		return nil
	case feed.FieldAuthors:
		m.ClearAuthors()
		return nil
	case feed.FieldImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown Feed nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedMutation) ResetField(name string) error {
	switch name {
	case feed.FieldTitle:
		m.ResetTitle()
		return nil
	case feed.FieldLink:
		m.ResetLink()
		return nil
	case feed.FieldDescription:
		m.ResetDescription()
		return nil
	case feed.FieldLanguage:
		m.ResetLanguage()
		return nil
	case feed.FieldAuthors:
		m.ResetAuthors()
		return nil
	case feed.FieldImage:
		m.ResetImage()
		return nil
	case feed.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feed.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Feed field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.item != nil {
		edges = append(edges, feed.EdgeItem)
	}
	if m._config != nil {
		edges = append(edges, feed.EdgeConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feed.EdgeItem:
		ids := make([]ent.Value, 0, len(m.item))
		for id := range m.item {
			ids = append(ids, id)
		}
		return ids
	case feed.EdgeConfig:
		if id := m._config; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditem != nil {
		edges = append(edges, feed.EdgeItem)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feed.EdgeItem:
		ids := make([]ent.Value, 0, len(m.removeditem))
		for id := range m.removeditem {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareditem {
		edges = append(edges, feed.EdgeItem)
	}
	if m.cleared_config {
		edges = append(edges, feed.EdgeConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedMutation) EdgeCleared(name string) bool {
	switch name {
	case feed.EdgeItem:
		return m.cleareditem
	case feed.EdgeConfig:
		return m.cleared_config
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedMutation) ClearEdge(name string) error {
	switch name {
	case feed.EdgeConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Feed unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedMutation) ResetEdge(name string) error {
	switch name {
	case feed.EdgeItem:
		m.ResetItem()
		return nil
	case feed.EdgeConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Feed edge %s", name)
}

// FeedActionSetMutation represents an operation that mutates the FeedActionSet nodes in the graph.
type FeedActionSetMutation struct {
	config
	op                 Op
	typ                string
	id                 *model.InternalID
	name               *string
	description        *string
	actions            *[]*modeltiphereth.FeatureRequest
	appendactions      []*modeltiphereth.FeatureRequest
	updated_at         *time.Time
	created_at         *time.Time
	clearedFields      map[string]struct{}
	owner              *model.InternalID
	clearedowner       bool
	feed_config        map[model.InternalID]struct{}
	removedfeed_config map[model.InternalID]struct{}
	clearedfeed_config bool
	done               bool
	oldValue           func(context.Context) (*FeedActionSet, error)
	predicates         []predicate.FeedActionSet
}

var _ ent.Mutation = (*FeedActionSetMutation)(nil)

// feedactionsetOption allows management of the mutation configuration using functional options.
type feedactionsetOption func(*FeedActionSetMutation)

// newFeedActionSetMutation creates new mutation for the FeedActionSet entity.
func newFeedActionSetMutation(c config, op Op, opts ...feedactionsetOption) *FeedActionSetMutation {
	m := &FeedActionSetMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedActionSet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedActionSetID sets the ID field of the mutation.
func withFeedActionSetID(id model.InternalID) feedactionsetOption {
	return func(m *FeedActionSetMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedActionSet
		)
		m.oldValue = func(ctx context.Context) (*FeedActionSet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedActionSet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedActionSet sets the old FeedActionSet of the mutation.
func withFeedActionSet(node *FeedActionSet) feedactionsetOption {
	return func(m *FeedActionSetMutation) {
		m.oldValue = func(context.Context) (*FeedActionSet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedActionSetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedActionSetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeedActionSet entities.
func (m *FeedActionSetMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedActionSetMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedActionSetMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeedActionSet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FeedActionSetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeedActionSetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeedActionSet entity.
// If the FeedActionSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedActionSetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeedActionSetMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *FeedActionSetMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeedActionSetMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeedActionSet entity.
// If the FeedActionSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedActionSetMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FeedActionSetMutation) ResetDescription() {
	m.description = nil
}

// SetActions sets the "actions" field.
func (m *FeedActionSetMutation) SetActions(mr []*modeltiphereth.FeatureRequest) {
	m.actions = &mr
	m.appendactions = nil
}

// Actions returns the value of the "actions" field in the mutation.
func (m *FeedActionSetMutation) Actions() (r []*modeltiphereth.FeatureRequest, exists bool) {
	v := m.actions
	if v == nil {
		return
	}
	return *v, true
}

// OldActions returns the old "actions" field's value of the FeedActionSet entity.
// If the FeedActionSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedActionSetMutation) OldActions(ctx context.Context) (v []*modeltiphereth.FeatureRequest, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActions: %w", err)
	}
	return oldValue.Actions, nil
}

// AppendActions adds mr to the "actions" field.
func (m *FeedActionSetMutation) AppendActions(mr []*modeltiphereth.FeatureRequest) {
	m.appendactions = append(m.appendactions, mr...)
}

// AppendedActions returns the list of values that were appended to the "actions" field in this mutation.
func (m *FeedActionSetMutation) AppendedActions() ([]*modeltiphereth.FeatureRequest, bool) {
	if len(m.appendactions) == 0 {
		return nil, false
	}
	return m.appendactions, true
}

// ResetActions resets all changes to the "actions" field.
func (m *FeedActionSetMutation) ResetActions() {
	m.actions = nil
	m.appendactions = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedActionSetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedActionSetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeedActionSet entity.
// If the FeedActionSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedActionSetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedActionSetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedActionSetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedActionSetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeedActionSet entity.
// If the FeedActionSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedActionSetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedActionSetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *FeedActionSetMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FeedActionSetMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FeedActionSetMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *FeedActionSetMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FeedActionSetMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FeedActionSetMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddFeedConfigIDs adds the "feed_config" edge to the FeedConfig entity by ids.
func (m *FeedActionSetMutation) AddFeedConfigIDs(ids ...model.InternalID) {
	if m.feed_config == nil {
		m.feed_config = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_config[ids[i]] = struct{}{}
	}
}

// ClearFeedConfig clears the "feed_config" edge to the FeedConfig entity.
func (m *FeedActionSetMutation) ClearFeedConfig() {
	m.clearedfeed_config = true
}

// FeedConfigCleared reports if the "feed_config" edge to the FeedConfig entity was cleared.
func (m *FeedActionSetMutation) FeedConfigCleared() bool {
	return m.clearedfeed_config
}

// RemoveFeedConfigIDs removes the "feed_config" edge to the FeedConfig entity by IDs.
func (m *FeedActionSetMutation) RemoveFeedConfigIDs(ids ...model.InternalID) {
	if m.removedfeed_config == nil {
		m.removedfeed_config = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_config, ids[i])
		m.removedfeed_config[ids[i]] = struct{}{}
	}
}

// RemovedFeedConfig returns the removed IDs of the "feed_config" edge to the FeedConfig entity.
func (m *FeedActionSetMutation) RemovedFeedConfigIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_config {
		ids = append(ids, id)
	}
	return
}

// FeedConfigIDs returns the "feed_config" edge IDs in the mutation.
func (m *FeedActionSetMutation) FeedConfigIDs() (ids []model.InternalID) {
	for id := range m.feed_config {
		ids = append(ids, id)
	}
	return
}

// ResetFeedConfig resets all changes to the "feed_config" edge.
func (m *FeedActionSetMutation) ResetFeedConfig() {
	m.feed_config = nil
	m.clearedfeed_config = false
	m.removedfeed_config = nil
}

// Where appends a list predicates to the FeedActionSetMutation builder.
func (m *FeedActionSetMutation) Where(ps ...predicate.FeedActionSet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedActionSetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedActionSetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeedActionSet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedActionSetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedActionSetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeedActionSet).
func (m *FeedActionSetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedActionSetMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, feedactionset.FieldName)
	}
	if m.description != nil {
		fields = append(fields, feedactionset.FieldDescription)
	}
	if m.actions != nil {
		fields = append(fields, feedactionset.FieldActions)
	}
	if m.updated_at != nil {
		fields = append(fields, feedactionset.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feedactionset.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedActionSetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedactionset.FieldName:
		return m.Name()
	case feedactionset.FieldDescription:
		return m.Description()
	case feedactionset.FieldActions:
		return m.Actions()
	case feedactionset.FieldUpdatedAt:
		return m.UpdatedAt()
	case feedactionset.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedActionSetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedactionset.FieldName:
		return m.OldName(ctx)
	case feedactionset.FieldDescription:
		return m.OldDescription(ctx)
	case feedactionset.FieldActions:
		return m.OldActions(ctx)
	case feedactionset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feedactionset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeedActionSet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedActionSetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedactionset.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feedactionset.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feedactionset.FieldActions:
		v, ok := value.([]*modeltiphereth.FeatureRequest)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActions(v)
		return nil
	case feedactionset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feedactionset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeedActionSet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedActionSetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedActionSetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedActionSetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeedActionSet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedActionSetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedActionSetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedActionSetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeedActionSet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedActionSetMutation) ResetField(name string) error {
	switch name {
	case feedactionset.FieldName:
		m.ResetName()
		return nil
	case feedactionset.FieldDescription:
		m.ResetDescription()
		return nil
	case feedactionset.FieldActions:
		m.ResetActions()
		return nil
	case feedactionset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feedactionset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeedActionSet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedActionSetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, feedactionset.EdgeOwner)
	}
	if m.feed_config != nil {
		edges = append(edges, feedactionset.EdgeFeedConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedActionSetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feedactionset.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case feedactionset.EdgeFeedConfig:
		ids := make([]ent.Value, 0, len(m.feed_config))
		for id := range m.feed_config {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedActionSetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfeed_config != nil {
		edges = append(edges, feedactionset.EdgeFeedConfig)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedActionSetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feedactionset.EdgeFeedConfig:
		ids := make([]ent.Value, 0, len(m.removedfeed_config))
		for id := range m.removedfeed_config {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedActionSetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, feedactionset.EdgeOwner)
	}
	if m.clearedfeed_config {
		edges = append(edges, feedactionset.EdgeFeedConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedActionSetMutation) EdgeCleared(name string) bool {
	switch name {
	case feedactionset.EdgeOwner:
		return m.clearedowner
	case feedactionset.EdgeFeedConfig:
		return m.clearedfeed_config
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedActionSetMutation) ClearEdge(name string) error {
	switch name {
	case feedactionset.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown FeedActionSet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedActionSetMutation) ResetEdge(name string) error {
	switch name {
	case feedactionset.EdgeOwner:
		m.ResetOwner()
		return nil
	case feedactionset.EdgeFeedConfig:
		m.ResetFeedConfig()
		return nil
	}
	return fmt.Errorf("unknown FeedActionSet edge %s", name)
}

// FeedConfigMutation represents an operation that mutates the FeedConfig nodes in the graph.
type FeedConfigMutation struct {
	config
	op                        Op
	typ                       string
	id                        *model.InternalID
	name                      *string
	feed_url                  *string
	author_account            *model.InternalID
	addauthor_account         *model.InternalID
	source                    *string
	status                    *feedconfig.Status
	category                  *string
	pull_interval             *time.Duration
	addpull_interval          *time.Duration
	hide_items                *bool
	latest_pull_at            *time.Time
	latest_pull_status        *feedconfig.LatestPullStatus
	latest_pull_message       *string
	next_pull_begin_at        *time.Time
	updated_at                *time.Time
	created_at                *time.Time
	clearedFields             map[string]struct{}
	owner                     *model.InternalID
	clearedowner              bool
	feed                      *model.InternalID
	clearedfeed               bool
	notify_source             map[model.InternalID]struct{}
	removednotify_source      map[model.InternalID]struct{}
	clearednotify_source      bool
	feed_action_set           map[model.InternalID]struct{}
	removedfeed_action_set    map[model.InternalID]struct{}
	clearedfeed_action_set    bool
	feed_config_action        map[int]struct{}
	removedfeed_config_action map[int]struct{}
	clearedfeed_config_action bool
	done                      bool
	oldValue                  func(context.Context) (*FeedConfig, error)
	predicates                []predicate.FeedConfig
}

var _ ent.Mutation = (*FeedConfigMutation)(nil)

// feedconfigOption allows management of the mutation configuration using functional options.
type feedconfigOption func(*FeedConfigMutation)

// newFeedConfigMutation creates new mutation for the FeedConfig entity.
func newFeedConfigMutation(c config, op Op, opts ...feedconfigOption) *FeedConfigMutation {
	m := &FeedConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedConfigID sets the ID field of the mutation.
func withFeedConfigID(id model.InternalID) feedconfigOption {
	return func(m *FeedConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedConfig
		)
		m.oldValue = func(ctx context.Context) (*FeedConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedConfig sets the old FeedConfig of the mutation.
func withFeedConfig(node *FeedConfig) feedconfigOption {
	return func(m *FeedConfigMutation) {
		m.oldValue = func(context.Context) (*FeedConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeedConfig entities.
func (m *FeedConfigMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedConfigMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedConfigMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeedConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserFeedConfig sets the "user_feed_config" field.
func (m *FeedConfigMutation) SetUserFeedConfig(mi model.InternalID) {
	m.owner = &mi
}

// UserFeedConfig returns the value of the "user_feed_config" field in the mutation.
func (m *FeedConfigMutation) UserFeedConfig() (r model.InternalID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserFeedConfig returns the old "user_feed_config" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldUserFeedConfig(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserFeedConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserFeedConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserFeedConfig: %w", err)
	}
	return oldValue.UserFeedConfig, nil
}

// ResetUserFeedConfig resets all changes to the "user_feed_config" field.
func (m *FeedConfigMutation) ResetUserFeedConfig() {
	m.owner = nil
}

// SetName sets the "name" field.
func (m *FeedConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeedConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeedConfigMutation) ResetName() {
	m.name = nil
}

// SetFeedURL sets the "feed_url" field.
func (m *FeedConfigMutation) SetFeedURL(s string) {
	m.feed_url = &s
}

// FeedURL returns the value of the "feed_url" field in the mutation.
func (m *FeedConfigMutation) FeedURL() (r string, exists bool) {
	v := m.feed_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedURL returns the old "feed_url" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldFeedURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedURL: %w", err)
	}
	return oldValue.FeedURL, nil
}

// ResetFeedURL resets all changes to the "feed_url" field.
func (m *FeedConfigMutation) ResetFeedURL() {
	m.feed_url = nil
}

// SetAuthorAccount sets the "author_account" field.
func (m *FeedConfigMutation) SetAuthorAccount(mi model.InternalID) {
	m.author_account = &mi
	m.addauthor_account = nil
}

// AuthorAccount returns the value of the "author_account" field in the mutation.
func (m *FeedConfigMutation) AuthorAccount() (r model.InternalID, exists bool) {
	v := m.author_account
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthorAccount returns the old "author_account" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldAuthorAccount(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthorAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthorAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthorAccount: %w", err)
	}
	return oldValue.AuthorAccount, nil
}

// AddAuthorAccount adds mi to the "author_account" field.
func (m *FeedConfigMutation) AddAuthorAccount(mi model.InternalID) {
	if m.addauthor_account != nil {
		*m.addauthor_account += mi
	} else {
		m.addauthor_account = &mi
	}
}

// AddedAuthorAccount returns the value that was added to the "author_account" field in this mutation.
func (m *FeedConfigMutation) AddedAuthorAccount() (r model.InternalID, exists bool) {
	v := m.addauthor_account
	if v == nil {
		return
	}
	return *v, true
}

// ResetAuthorAccount resets all changes to the "author_account" field.
func (m *FeedConfigMutation) ResetAuthorAccount() {
	m.author_account = nil
	m.addauthor_account = nil
}

// SetSource sets the "source" field.
func (m *FeedConfigMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *FeedConfigMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *FeedConfigMutation) ResetSource() {
	m.source = nil
}

// SetStatus sets the "status" field.
func (m *FeedConfigMutation) SetStatus(f feedconfig.Status) {
	m.status = &f
}

// Status returns the value of the "status" field in the mutation.
func (m *FeedConfigMutation) Status() (r feedconfig.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldStatus(ctx context.Context) (v feedconfig.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FeedConfigMutation) ResetStatus() {
	m.status = nil
}

// SetCategory sets the "category" field.
func (m *FeedConfigMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *FeedConfigMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *FeedConfigMutation) ResetCategory() {
	m.category = nil
}

// SetPullInterval sets the "pull_interval" field.
func (m *FeedConfigMutation) SetPullInterval(t time.Duration) {
	m.pull_interval = &t
	m.addpull_interval = nil
}

// PullInterval returns the value of the "pull_interval" field in the mutation.
func (m *FeedConfigMutation) PullInterval() (r time.Duration, exists bool) {
	v := m.pull_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldPullInterval returns the old "pull_interval" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldPullInterval(ctx context.Context) (v time.Duration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPullInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPullInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullInterval: %w", err)
	}
	return oldValue.PullInterval, nil
}

// AddPullInterval adds t to the "pull_interval" field.
func (m *FeedConfigMutation) AddPullInterval(t time.Duration) {
	if m.addpull_interval != nil {
		*m.addpull_interval += t
	} else {
		m.addpull_interval = &t
	}
}

// AddedPullInterval returns the value that was added to the "pull_interval" field in this mutation.
func (m *FeedConfigMutation) AddedPullInterval() (r time.Duration, exists bool) {
	v := m.addpull_interval
	if v == nil {
		return
	}
	return *v, true
}

// ResetPullInterval resets all changes to the "pull_interval" field.
func (m *FeedConfigMutation) ResetPullInterval() {
	m.pull_interval = nil
	m.addpull_interval = nil
}

// SetHideItems sets the "hide_items" field.
func (m *FeedConfigMutation) SetHideItems(b bool) {
	m.hide_items = &b
}

// HideItems returns the value of the "hide_items" field in the mutation.
func (m *FeedConfigMutation) HideItems() (r bool, exists bool) {
	v := m.hide_items
	if v == nil {
		return
	}
	return *v, true
}

// OldHideItems returns the old "hide_items" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldHideItems(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideItems: %w", err)
	}
	return oldValue.HideItems, nil
}

// ResetHideItems resets all changes to the "hide_items" field.
func (m *FeedConfigMutation) ResetHideItems() {
	m.hide_items = nil
}

// SetLatestPullAt sets the "latest_pull_at" field.
func (m *FeedConfigMutation) SetLatestPullAt(t time.Time) {
	m.latest_pull_at = &t
}

// LatestPullAt returns the value of the "latest_pull_at" field in the mutation.
func (m *FeedConfigMutation) LatestPullAt() (r time.Time, exists bool) {
	v := m.latest_pull_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestPullAt returns the old "latest_pull_at" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldLatestPullAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestPullAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestPullAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestPullAt: %w", err)
	}
	return oldValue.LatestPullAt, nil
}

// ResetLatestPullAt resets all changes to the "latest_pull_at" field.
func (m *FeedConfigMutation) ResetLatestPullAt() {
	m.latest_pull_at = nil
}

// SetLatestPullStatus sets the "latest_pull_status" field.
func (m *FeedConfigMutation) SetLatestPullStatus(fps feedconfig.LatestPullStatus) {
	m.latest_pull_status = &fps
}

// LatestPullStatus returns the value of the "latest_pull_status" field in the mutation.
func (m *FeedConfigMutation) LatestPullStatus() (r feedconfig.LatestPullStatus, exists bool) {
	v := m.latest_pull_status
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestPullStatus returns the old "latest_pull_status" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldLatestPullStatus(ctx context.Context) (v feedconfig.LatestPullStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestPullStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestPullStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestPullStatus: %w", err)
	}
	return oldValue.LatestPullStatus, nil
}

// ResetLatestPullStatus resets all changes to the "latest_pull_status" field.
func (m *FeedConfigMutation) ResetLatestPullStatus() {
	m.latest_pull_status = nil
}

// SetLatestPullMessage sets the "latest_pull_message" field.
func (m *FeedConfigMutation) SetLatestPullMessage(s string) {
	m.latest_pull_message = &s
}

// LatestPullMessage returns the value of the "latest_pull_message" field in the mutation.
func (m *FeedConfigMutation) LatestPullMessage() (r string, exists bool) {
	v := m.latest_pull_message
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestPullMessage returns the old "latest_pull_message" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldLatestPullMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestPullMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestPullMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestPullMessage: %w", err)
	}
	return oldValue.LatestPullMessage, nil
}

// ResetLatestPullMessage resets all changes to the "latest_pull_message" field.
func (m *FeedConfigMutation) ResetLatestPullMessage() {
	m.latest_pull_message = nil
}

// SetNextPullBeginAt sets the "next_pull_begin_at" field.
func (m *FeedConfigMutation) SetNextPullBeginAt(t time.Time) {
	m.next_pull_begin_at = &t
}

// NextPullBeginAt returns the value of the "next_pull_begin_at" field in the mutation.
func (m *FeedConfigMutation) NextPullBeginAt() (r time.Time, exists bool) {
	v := m.next_pull_begin_at
	if v == nil {
		return
	}
	return *v, true
}

// OldNextPullBeginAt returns the old "next_pull_begin_at" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldNextPullBeginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextPullBeginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextPullBeginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextPullBeginAt: %w", err)
	}
	return oldValue.NextPullBeginAt, nil
}

// ResetNextPullBeginAt resets all changes to the "next_pull_begin_at" field.
func (m *FeedConfigMutation) ResetNextPullBeginAt() {
	m.next_pull_begin_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *FeedConfigMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FeedConfigMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[feedconfig.FieldUserFeedConfig] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FeedConfigMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *FeedConfigMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FeedConfigMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FeedConfigMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetFeedID sets the "feed" edge to the Feed entity by id.
func (m *FeedConfigMutation) SetFeedID(id model.InternalID) {
	m.feed = &id
}

// ClearFeed clears the "feed" edge to the Feed entity.
func (m *FeedConfigMutation) ClearFeed() {
	m.clearedfeed = true
}

// FeedCleared reports if the "feed" edge to the Feed entity was cleared.
func (m *FeedConfigMutation) FeedCleared() bool {
	return m.clearedfeed
}

// FeedID returns the "feed" edge ID in the mutation.
func (m *FeedConfigMutation) FeedID() (id model.InternalID, exists bool) {
	if m.feed != nil {
		return *m.feed, true
	}
	return
}

// FeedIDs returns the "feed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedID instead. It exists only for internal usage by the builders.
func (m *FeedConfigMutation) FeedIDs() (ids []model.InternalID) {
	if id := m.feed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeed resets all changes to the "feed" edge.
func (m *FeedConfigMutation) ResetFeed() {
	m.feed = nil
	m.clearedfeed = false
}

// AddNotifySourceIDs adds the "notify_source" edge to the NotifySource entity by ids.
func (m *FeedConfigMutation) AddNotifySourceIDs(ids ...model.InternalID) {
	if m.notify_source == nil {
		m.notify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_source[ids[i]] = struct{}{}
	}
}

// ClearNotifySource clears the "notify_source" edge to the NotifySource entity.
func (m *FeedConfigMutation) ClearNotifySource() {
	m.clearednotify_source = true
}

// NotifySourceCleared reports if the "notify_source" edge to the NotifySource entity was cleared.
func (m *FeedConfigMutation) NotifySourceCleared() bool {
	return m.clearednotify_source
}

// RemoveNotifySourceIDs removes the "notify_source" edge to the NotifySource entity by IDs.
func (m *FeedConfigMutation) RemoveNotifySourceIDs(ids ...model.InternalID) {
	if m.removednotify_source == nil {
		m.removednotify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_source, ids[i])
		m.removednotify_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifySource returns the removed IDs of the "notify_source" edge to the NotifySource entity.
func (m *FeedConfigMutation) RemovedNotifySourceIDs() (ids []model.InternalID) {
	for id := range m.removednotify_source {
		ids = append(ids, id)
	}
	return
}

// NotifySourceIDs returns the "notify_source" edge IDs in the mutation.
func (m *FeedConfigMutation) NotifySourceIDs() (ids []model.InternalID) {
	for id := range m.notify_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifySource resets all changes to the "notify_source" edge.
func (m *FeedConfigMutation) ResetNotifySource() {
	m.notify_source = nil
	m.clearednotify_source = false
	m.removednotify_source = nil
}

// AddFeedActionSetIDs adds the "feed_action_set" edge to the FeedActionSet entity by ids.
func (m *FeedConfigMutation) AddFeedActionSetIDs(ids ...model.InternalID) {
	if m.feed_action_set == nil {
		m.feed_action_set = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_action_set[ids[i]] = struct{}{}
	}
}

// ClearFeedActionSet clears the "feed_action_set" edge to the FeedActionSet entity.
func (m *FeedConfigMutation) ClearFeedActionSet() {
	m.clearedfeed_action_set = true
}

// FeedActionSetCleared reports if the "feed_action_set" edge to the FeedActionSet entity was cleared.
func (m *FeedConfigMutation) FeedActionSetCleared() bool {
	return m.clearedfeed_action_set
}

// RemoveFeedActionSetIDs removes the "feed_action_set" edge to the FeedActionSet entity by IDs.
func (m *FeedConfigMutation) RemoveFeedActionSetIDs(ids ...model.InternalID) {
	if m.removedfeed_action_set == nil {
		m.removedfeed_action_set = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_action_set, ids[i])
		m.removedfeed_action_set[ids[i]] = struct{}{}
	}
}

// RemovedFeedActionSet returns the removed IDs of the "feed_action_set" edge to the FeedActionSet entity.
func (m *FeedConfigMutation) RemovedFeedActionSetIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_action_set {
		ids = append(ids, id)
	}
	return
}

// FeedActionSetIDs returns the "feed_action_set" edge IDs in the mutation.
func (m *FeedConfigMutation) FeedActionSetIDs() (ids []model.InternalID) {
	for id := range m.feed_action_set {
		ids = append(ids, id)
	}
	return
}

// ResetFeedActionSet resets all changes to the "feed_action_set" edge.
func (m *FeedConfigMutation) ResetFeedActionSet() {
	m.feed_action_set = nil
	m.clearedfeed_action_set = false
	m.removedfeed_action_set = nil
}

// AddFeedConfigActionIDs adds the "feed_config_action" edge to the FeedConfigAction entity by ids.
func (m *FeedConfigMutation) AddFeedConfigActionIDs(ids ...int) {
	if m.feed_config_action == nil {
		m.feed_config_action = make(map[int]struct{})
	}
	for i := range ids {
		m.feed_config_action[ids[i]] = struct{}{}
	}
}

// ClearFeedConfigAction clears the "feed_config_action" edge to the FeedConfigAction entity.
func (m *FeedConfigMutation) ClearFeedConfigAction() {
	m.clearedfeed_config_action = true
}

// FeedConfigActionCleared reports if the "feed_config_action" edge to the FeedConfigAction entity was cleared.
func (m *FeedConfigMutation) FeedConfigActionCleared() bool {
	return m.clearedfeed_config_action
}

// RemoveFeedConfigActionIDs removes the "feed_config_action" edge to the FeedConfigAction entity by IDs.
func (m *FeedConfigMutation) RemoveFeedConfigActionIDs(ids ...int) {
	if m.removedfeed_config_action == nil {
		m.removedfeed_config_action = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.feed_config_action, ids[i])
		m.removedfeed_config_action[ids[i]] = struct{}{}
	}
}

// RemovedFeedConfigAction returns the removed IDs of the "feed_config_action" edge to the FeedConfigAction entity.
func (m *FeedConfigMutation) RemovedFeedConfigActionIDs() (ids []int) {
	for id := range m.removedfeed_config_action {
		ids = append(ids, id)
	}
	return
}

// FeedConfigActionIDs returns the "feed_config_action" edge IDs in the mutation.
func (m *FeedConfigMutation) FeedConfigActionIDs() (ids []int) {
	for id := range m.feed_config_action {
		ids = append(ids, id)
	}
	return
}

// ResetFeedConfigAction resets all changes to the "feed_config_action" edge.
func (m *FeedConfigMutation) ResetFeedConfigAction() {
	m.feed_config_action = nil
	m.clearedfeed_config_action = false
	m.removedfeed_config_action = nil
}

// Where appends a list predicates to the FeedConfigMutation builder.
func (m *FeedConfigMutation) Where(ps ...predicate.FeedConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeedConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeedConfig).
func (m *FeedConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedConfigMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.owner != nil {
		fields = append(fields, feedconfig.FieldUserFeedConfig)
	}
	if m.name != nil {
		fields = append(fields, feedconfig.FieldName)
	}
	if m.feed_url != nil {
		fields = append(fields, feedconfig.FieldFeedURL)
	}
	if m.author_account != nil {
		fields = append(fields, feedconfig.FieldAuthorAccount)
	}
	if m.source != nil {
		fields = append(fields, feedconfig.FieldSource)
	}
	if m.status != nil {
		fields = append(fields, feedconfig.FieldStatus)
	}
	if m.category != nil {
		fields = append(fields, feedconfig.FieldCategory)
	}
	if m.pull_interval != nil {
		fields = append(fields, feedconfig.FieldPullInterval)
	}
	if m.hide_items != nil {
		fields = append(fields, feedconfig.FieldHideItems)
	}
	if m.latest_pull_at != nil {
		fields = append(fields, feedconfig.FieldLatestPullAt)
	}
	if m.latest_pull_status != nil {
		fields = append(fields, feedconfig.FieldLatestPullStatus)
	}
	if m.latest_pull_message != nil {
		fields = append(fields, feedconfig.FieldLatestPullMessage)
	}
	if m.next_pull_begin_at != nil {
		fields = append(fields, feedconfig.FieldNextPullBeginAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feedconfig.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feedconfig.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedconfig.FieldUserFeedConfig:
		return m.UserFeedConfig()
	case feedconfig.FieldName:
		return m.Name()
	case feedconfig.FieldFeedURL:
		return m.FeedURL()
	case feedconfig.FieldAuthorAccount:
		return m.AuthorAccount()
	case feedconfig.FieldSource:
		return m.Source()
	case feedconfig.FieldStatus:
		return m.Status()
	case feedconfig.FieldCategory:
		return m.Category()
	case feedconfig.FieldPullInterval:
		return m.PullInterval()
	case feedconfig.FieldHideItems:
		return m.HideItems()
	case feedconfig.FieldLatestPullAt:
		return m.LatestPullAt()
	case feedconfig.FieldLatestPullStatus:
		return m.LatestPullStatus()
	case feedconfig.FieldLatestPullMessage:
		return m.LatestPullMessage()
	case feedconfig.FieldNextPullBeginAt:
		return m.NextPullBeginAt()
	case feedconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case feedconfig.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedconfig.FieldUserFeedConfig:
		return m.OldUserFeedConfig(ctx)
	case feedconfig.FieldName:
		return m.OldName(ctx)
	case feedconfig.FieldFeedURL:
		return m.OldFeedURL(ctx)
	case feedconfig.FieldAuthorAccount:
		return m.OldAuthorAccount(ctx)
	case feedconfig.FieldSource:
		return m.OldSource(ctx)
	case feedconfig.FieldStatus:
		return m.OldStatus(ctx)
	case feedconfig.FieldCategory:
		return m.OldCategory(ctx)
	case feedconfig.FieldPullInterval:
		return m.OldPullInterval(ctx)
	case feedconfig.FieldHideItems:
		return m.OldHideItems(ctx)
	case feedconfig.FieldLatestPullAt:
		return m.OldLatestPullAt(ctx)
	case feedconfig.FieldLatestPullStatus:
		return m.OldLatestPullStatus(ctx)
	case feedconfig.FieldLatestPullMessage:
		return m.OldLatestPullMessage(ctx)
	case feedconfig.FieldNextPullBeginAt:
		return m.OldNextPullBeginAt(ctx)
	case feedconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feedconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeedConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedconfig.FieldUserFeedConfig:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserFeedConfig(v)
		return nil
	case feedconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feedconfig.FieldFeedURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedURL(v)
		return nil
	case feedconfig.FieldAuthorAccount:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthorAccount(v)
		return nil
	case feedconfig.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case feedconfig.FieldStatus:
		v, ok := value.(feedconfig.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case feedconfig.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case feedconfig.FieldPullInterval:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullInterval(v)
		return nil
	case feedconfig.FieldHideItems:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideItems(v)
		return nil
	case feedconfig.FieldLatestPullAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestPullAt(v)
		return nil
	case feedconfig.FieldLatestPullStatus:
		v, ok := value.(feedconfig.LatestPullStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestPullStatus(v)
		return nil
	case feedconfig.FieldLatestPullMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestPullMessage(v)
		return nil
	case feedconfig.FieldNextPullBeginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextPullBeginAt(v)
		return nil
	case feedconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feedconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeedConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedConfigMutation) AddedFields() []string {
	var fields []string
	if m.addauthor_account != nil {
		fields = append(fields, feedconfig.FieldAuthorAccount)
	}
	if m.addpull_interval != nil {
		fields = append(fields, feedconfig.FieldPullInterval)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feedconfig.FieldAuthorAccount:
		return m.AddedAuthorAccount()
	case feedconfig.FieldPullInterval:
		return m.AddedPullInterval()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feedconfig.FieldAuthorAccount:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAuthorAccount(v)
		return nil
	case feedconfig.FieldPullInterval:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPullInterval(v)
		return nil
	}
	return fmt.Errorf("unknown FeedConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeedConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedConfigMutation) ResetField(name string) error {
	switch name {
	case feedconfig.FieldUserFeedConfig:
		m.ResetUserFeedConfig()
		return nil
	case feedconfig.FieldName:
		m.ResetName()
		return nil
	case feedconfig.FieldFeedURL:
		m.ResetFeedURL()
		return nil
	case feedconfig.FieldAuthorAccount:
		m.ResetAuthorAccount()
		return nil
	case feedconfig.FieldSource:
		m.ResetSource()
		return nil
	case feedconfig.FieldStatus:
		m.ResetStatus()
		return nil
	case feedconfig.FieldCategory:
		m.ResetCategory()
		return nil
	case feedconfig.FieldPullInterval:
		m.ResetPullInterval()
		return nil
	case feedconfig.FieldHideItems:
		m.ResetHideItems()
		return nil
	case feedconfig.FieldLatestPullAt:
		m.ResetLatestPullAt()
		return nil
	case feedconfig.FieldLatestPullStatus:
		m.ResetLatestPullStatus()
		return nil
	case feedconfig.FieldLatestPullMessage:
		m.ResetLatestPullMessage()
		return nil
	case feedconfig.FieldNextPullBeginAt:
		m.ResetNextPullBeginAt()
		return nil
	case feedconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feedconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeedConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, feedconfig.EdgeOwner)
	}
	if m.feed != nil {
		edges = append(edges, feedconfig.EdgeFeed)
	}
	if m.notify_source != nil {
		edges = append(edges, feedconfig.EdgeNotifySource)
	}
	if m.feed_action_set != nil {
		edges = append(edges, feedconfig.EdgeFeedActionSet)
	}
	if m.feed_config_action != nil {
		edges = append(edges, feedconfig.EdgeFeedConfigAction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feedconfig.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case feedconfig.EdgeFeed:
		if id := m.feed; id != nil {
			return []ent.Value{*id}
		}
	case feedconfig.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.notify_source))
		for id := range m.notify_source {
			ids = append(ids, id)
		}
		return ids
	case feedconfig.EdgeFeedActionSet:
		ids := make([]ent.Value, 0, len(m.feed_action_set))
		for id := range m.feed_action_set {
			ids = append(ids, id)
		}
		return ids
	case feedconfig.EdgeFeedConfigAction:
		ids := make([]ent.Value, 0, len(m.feed_config_action))
		for id := range m.feed_config_action {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removednotify_source != nil {
		edges = append(edges, feedconfig.EdgeNotifySource)
	}
	if m.removedfeed_action_set != nil {
		edges = append(edges, feedconfig.EdgeFeedActionSet)
	}
	if m.removedfeed_config_action != nil {
		edges = append(edges, feedconfig.EdgeFeedConfigAction)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feedconfig.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.removednotify_source))
		for id := range m.removednotify_source {
			ids = append(ids, id)
		}
		return ids
	case feedconfig.EdgeFeedActionSet:
		ids := make([]ent.Value, 0, len(m.removedfeed_action_set))
		for id := range m.removedfeed_action_set {
			ids = append(ids, id)
		}
		return ids
	case feedconfig.EdgeFeedConfigAction:
		ids := make([]ent.Value, 0, len(m.removedfeed_config_action))
		for id := range m.removedfeed_config_action {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, feedconfig.EdgeOwner)
	}
	if m.clearedfeed {
		edges = append(edges, feedconfig.EdgeFeed)
	}
	if m.clearednotify_source {
		edges = append(edges, feedconfig.EdgeNotifySource)
	}
	if m.clearedfeed_action_set {
		edges = append(edges, feedconfig.EdgeFeedActionSet)
	}
	if m.clearedfeed_config_action {
		edges = append(edges, feedconfig.EdgeFeedConfigAction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case feedconfig.EdgeOwner:
		return m.clearedowner
	case feedconfig.EdgeFeed:
		return m.clearedfeed
	case feedconfig.EdgeNotifySource:
		return m.clearednotify_source
	case feedconfig.EdgeFeedActionSet:
		return m.clearedfeed_action_set
	case feedconfig.EdgeFeedConfigAction:
		return m.clearedfeed_config_action
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedConfigMutation) ClearEdge(name string) error {
	switch name {
	case feedconfig.EdgeOwner:
		m.ClearOwner()
		return nil
	case feedconfig.EdgeFeed:
		m.ClearFeed()
		return nil
	}
	return fmt.Errorf("unknown FeedConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedConfigMutation) ResetEdge(name string) error {
	switch name {
	case feedconfig.EdgeOwner:
		m.ResetOwner()
		return nil
	case feedconfig.EdgeFeed:
		m.ResetFeed()
		return nil
	case feedconfig.EdgeNotifySource:
		m.ResetNotifySource()
		return nil
	case feedconfig.EdgeFeedActionSet:
		m.ResetFeedActionSet()
		return nil
	case feedconfig.EdgeFeedConfigAction:
		m.ResetFeedConfigAction()
		return nil
	}
	return fmt.Errorf("unknown FeedConfig edge %s", name)
}

// FeedConfigActionMutation represents an operation that mutates the FeedConfigAction nodes in the graph.
type FeedConfigActionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	index                  *int64
	addindex               *int64
	updated_at             *time.Time
	created_at             *time.Time
	clearedFields          map[string]struct{}
	feed_config            *model.InternalID
	clearedfeed_config     bool
	feed_action_set        *model.InternalID
	clearedfeed_action_set bool
	done                   bool
	oldValue               func(context.Context) (*FeedConfigAction, error)
	predicates             []predicate.FeedConfigAction
}

var _ ent.Mutation = (*FeedConfigActionMutation)(nil)

// feedconfigactionOption allows management of the mutation configuration using functional options.
type feedconfigactionOption func(*FeedConfigActionMutation)

// newFeedConfigActionMutation creates new mutation for the FeedConfigAction entity.
func newFeedConfigActionMutation(c config, op Op, opts ...feedconfigactionOption) *FeedConfigActionMutation {
	m := &FeedConfigActionMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedConfigAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedConfigActionID sets the ID field of the mutation.
func withFeedConfigActionID(id int) feedconfigactionOption {
	return func(m *FeedConfigActionMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedConfigAction
		)
		m.oldValue = func(ctx context.Context) (*FeedConfigAction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedConfigAction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedConfigAction sets the old FeedConfigAction of the mutation.
func withFeedConfigAction(node *FeedConfigAction) feedconfigactionOption {
	return func(m *FeedConfigActionMutation) {
		m.oldValue = func(context.Context) (*FeedConfigAction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedConfigActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedConfigActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedConfigActionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedConfigActionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeedConfigAction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeedConfigID sets the "feed_config_id" field.
func (m *FeedConfigActionMutation) SetFeedConfigID(mi model.InternalID) {
	m.feed_config = &mi
}

// FeedConfigID returns the value of the "feed_config_id" field in the mutation.
func (m *FeedConfigActionMutation) FeedConfigID() (r model.InternalID, exists bool) {
	v := m.feed_config
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedConfigID returns the old "feed_config_id" field's value of the FeedConfigAction entity.
// If the FeedConfigAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigActionMutation) OldFeedConfigID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedConfigID: %w", err)
	}
	return oldValue.FeedConfigID, nil
}

// ResetFeedConfigID resets all changes to the "feed_config_id" field.
func (m *FeedConfigActionMutation) ResetFeedConfigID() {
	m.feed_config = nil
}

// SetFeedActionSetID sets the "feed_action_set_id" field.
func (m *FeedConfigActionMutation) SetFeedActionSetID(mi model.InternalID) {
	m.feed_action_set = &mi
}

// FeedActionSetID returns the value of the "feed_action_set_id" field in the mutation.
func (m *FeedConfigActionMutation) FeedActionSetID() (r model.InternalID, exists bool) {
	v := m.feed_action_set
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedActionSetID returns the old "feed_action_set_id" field's value of the FeedConfigAction entity.
// If the FeedConfigAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigActionMutation) OldFeedActionSetID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedActionSetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedActionSetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedActionSetID: %w", err)
	}
	return oldValue.FeedActionSetID, nil
}

// ResetFeedActionSetID resets all changes to the "feed_action_set_id" field.
func (m *FeedConfigActionMutation) ResetFeedActionSetID() {
	m.feed_action_set = nil
}

// SetIndex sets the "index" field.
func (m *FeedConfigActionMutation) SetIndex(i int64) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *FeedConfigActionMutation) Index() (r int64, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the FeedConfigAction entity.
// If the FeedConfigAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigActionMutation) OldIndex(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *FeedConfigActionMutation) AddIndex(i int64) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *FeedConfigActionMutation) AddedIndex() (r int64, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *FeedConfigActionMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedConfigActionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedConfigActionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeedConfigAction entity.
// If the FeedConfigAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigActionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedConfigActionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedConfigActionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedConfigActionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeedConfigAction entity.
// If the FeedConfigAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigActionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedConfigActionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearFeedConfig clears the "feed_config" edge to the FeedConfig entity.
func (m *FeedConfigActionMutation) ClearFeedConfig() {
	m.clearedfeed_config = true
	m.clearedFields[feedconfigaction.FieldFeedConfigID] = struct{}{}
}

// FeedConfigCleared reports if the "feed_config" edge to the FeedConfig entity was cleared.
func (m *FeedConfigActionMutation) FeedConfigCleared() bool {
	return m.clearedfeed_config
}

// FeedConfigIDs returns the "feed_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedConfigID instead. It exists only for internal usage by the builders.
func (m *FeedConfigActionMutation) FeedConfigIDs() (ids []model.InternalID) {
	if id := m.feed_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeedConfig resets all changes to the "feed_config" edge.
func (m *FeedConfigActionMutation) ResetFeedConfig() {
	m.feed_config = nil
	m.clearedfeed_config = false
}

// ClearFeedActionSet clears the "feed_action_set" edge to the FeedActionSet entity.
func (m *FeedConfigActionMutation) ClearFeedActionSet() {
	m.clearedfeed_action_set = true
	m.clearedFields[feedconfigaction.FieldFeedActionSetID] = struct{}{}
}

// FeedActionSetCleared reports if the "feed_action_set" edge to the FeedActionSet entity was cleared.
func (m *FeedConfigActionMutation) FeedActionSetCleared() bool {
	return m.clearedfeed_action_set
}

// FeedActionSetIDs returns the "feed_action_set" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedActionSetID instead. It exists only for internal usage by the builders.
func (m *FeedConfigActionMutation) FeedActionSetIDs() (ids []model.InternalID) {
	if id := m.feed_action_set; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeedActionSet resets all changes to the "feed_action_set" edge.
func (m *FeedConfigActionMutation) ResetFeedActionSet() {
	m.feed_action_set = nil
	m.clearedfeed_action_set = false
}

// Where appends a list predicates to the FeedConfigActionMutation builder.
func (m *FeedConfigActionMutation) Where(ps ...predicate.FeedConfigAction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedConfigActionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedConfigActionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeedConfigAction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedConfigActionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedConfigActionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeedConfigAction).
func (m *FeedConfigActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedConfigActionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.feed_config != nil {
		fields = append(fields, feedconfigaction.FieldFeedConfigID)
	}
	if m.feed_action_set != nil {
		fields = append(fields, feedconfigaction.FieldFeedActionSetID)
	}
	if m.index != nil {
		fields = append(fields, feedconfigaction.FieldIndex)
	}
	if m.updated_at != nil {
		fields = append(fields, feedconfigaction.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feedconfigaction.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedConfigActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedconfigaction.FieldFeedConfigID:
		return m.FeedConfigID()
	case feedconfigaction.FieldFeedActionSetID:
		return m.FeedActionSetID()
	case feedconfigaction.FieldIndex:
		return m.Index()
	case feedconfigaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case feedconfigaction.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedConfigActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedconfigaction.FieldFeedConfigID:
		return m.OldFeedConfigID(ctx)
	case feedconfigaction.FieldFeedActionSetID:
		return m.OldFeedActionSetID(ctx)
	case feedconfigaction.FieldIndex:
		return m.OldIndex(ctx)
	case feedconfigaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feedconfigaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeedConfigAction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedConfigActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedconfigaction.FieldFeedConfigID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedConfigID(v)
		return nil
	case feedconfigaction.FieldFeedActionSetID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedActionSetID(v)
		return nil
	case feedconfigaction.FieldIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case feedconfigaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feedconfigaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeedConfigAction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedConfigActionMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, feedconfigaction.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedConfigActionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feedconfigaction.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedConfigActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feedconfigaction.FieldIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown FeedConfigAction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedConfigActionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedConfigActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedConfigActionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeedConfigAction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedConfigActionMutation) ResetField(name string) error {
	switch name {
	case feedconfigaction.FieldFeedConfigID:
		m.ResetFeedConfigID()
		return nil
	case feedconfigaction.FieldFeedActionSetID:
		m.ResetFeedActionSetID()
		return nil
	case feedconfigaction.FieldIndex:
		m.ResetIndex()
		return nil
	case feedconfigaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feedconfigaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeedConfigAction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedConfigActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.feed_config != nil {
		edges = append(edges, feedconfigaction.EdgeFeedConfig)
	}
	if m.feed_action_set != nil {
		edges = append(edges, feedconfigaction.EdgeFeedActionSet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedConfigActionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feedconfigaction.EdgeFeedConfig:
		if id := m.feed_config; id != nil {
			return []ent.Value{*id}
		}
	case feedconfigaction.EdgeFeedActionSet:
		if id := m.feed_action_set; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedConfigActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedConfigActionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedConfigActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfeed_config {
		edges = append(edges, feedconfigaction.EdgeFeedConfig)
	}
	if m.clearedfeed_action_set {
		edges = append(edges, feedconfigaction.EdgeFeedActionSet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedConfigActionMutation) EdgeCleared(name string) bool {
	switch name {
	case feedconfigaction.EdgeFeedConfig:
		return m.clearedfeed_config
	case feedconfigaction.EdgeFeedActionSet:
		return m.clearedfeed_action_set
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedConfigActionMutation) ClearEdge(name string) error {
	switch name {
	case feedconfigaction.EdgeFeedConfig:
		m.ClearFeedConfig()
		return nil
	case feedconfigaction.EdgeFeedActionSet:
		m.ClearFeedActionSet()
		return nil
	}
	return fmt.Errorf("unknown FeedConfigAction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedConfigActionMutation) ResetEdge(name string) error {
	switch name {
	case feedconfigaction.EdgeFeedConfig:
		m.ResetFeedConfig()
		return nil
	case feedconfigaction.EdgeFeedActionSet:
		m.ResetFeedActionSet()
		return nil
	}
	return fmt.Errorf("unknown FeedConfigAction edge %s", name)
}

// FeedItemMutation represents an operation that mutates the FeedItem nodes in the graph.
type FeedItemMutation struct {
	config
	op                          Op
	typ                         string
	id                          *model.InternalID
	title                       *string
	authors                     *[]*modelfeed.Person
	appendauthors               []*modelfeed.Person
	description                 *string
	content                     *string
	guid                        *string
	link                        *string
	image                       **modelfeed.Image
	published                   *string
	published_parsed            *time.Time
	updated                     *string
	updated_parsed              *time.Time
	enclosures                  *[]*modelfeed.Enclosure
	appendenclosures            []*modelfeed.Enclosure
	publish_platform            *string
	read_count                  *int64
	addread_count               *int64
	digest_description          *string
	digest_images               *[]*modelfeed.Image
	appenddigest_images         []*modelfeed.Image
	updated_at                  *time.Time
	created_at                  *time.Time
	clearedFields               map[string]struct{}
	feed                        *model.InternalID
	clearedfeed                 bool
	feed_item_collection        map[model.InternalID]struct{}
	removedfeed_item_collection map[model.InternalID]struct{}
	clearedfeed_item_collection bool
	done                        bool
	oldValue                    func(context.Context) (*FeedItem, error)
	predicates                  []predicate.FeedItem
}

var _ ent.Mutation = (*FeedItemMutation)(nil)

// feeditemOption allows management of the mutation configuration using functional options.
type feeditemOption func(*FeedItemMutation)

// newFeedItemMutation creates new mutation for the FeedItem entity.
func newFeedItemMutation(c config, op Op, opts ...feeditemOption) *FeedItemMutation {
	m := &FeedItemMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedItemID sets the ID field of the mutation.
func withFeedItemID(id model.InternalID) feeditemOption {
	return func(m *FeedItemMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedItem
		)
		m.oldValue = func(ctx context.Context) (*FeedItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedItem sets the old FeedItem of the mutation.
func withFeedItem(node *FeedItem) feeditemOption {
	return func(m *FeedItemMutation) {
		m.oldValue = func(context.Context) (*FeedItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeedItem entities.
func (m *FeedItemMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedItemMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedItemMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeedItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeedID sets the "feed_id" field.
func (m *FeedItemMutation) SetFeedID(mi model.InternalID) {
	m.feed = &mi
}

// FeedID returns the value of the "feed_id" field in the mutation.
func (m *FeedItemMutation) FeedID() (r model.InternalID, exists bool) {
	v := m.feed
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedID returns the old "feed_id" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldFeedID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedID: %w", err)
	}
	return oldValue.FeedID, nil
}

// ResetFeedID resets all changes to the "feed_id" field.
func (m *FeedItemMutation) ResetFeedID() {
	m.feed = nil
}

// SetTitle sets the "title" field.
func (m *FeedItemMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *FeedItemMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *FeedItemMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[feeditem.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *FeedItemMutation) TitleCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *FeedItemMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, feeditem.FieldTitle)
}

// SetAuthors sets the "authors" field.
func (m *FeedItemMutation) SetAuthors(value []*modelfeed.Person) {
	m.authors = &value
	m.appendauthors = nil
}

// Authors returns the value of the "authors" field in the mutation.
func (m *FeedItemMutation) Authors() (r []*modelfeed.Person, exists bool) {
	v := m.authors
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthors returns the old "authors" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldAuthors(ctx context.Context) (v []*modelfeed.Person, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthors: %w", err)
	}
	return oldValue.Authors, nil
}

// AppendAuthors adds value to the "authors" field.
func (m *FeedItemMutation) AppendAuthors(value []*modelfeed.Person) {
	m.appendauthors = append(m.appendauthors, value...)
}

// AppendedAuthors returns the list of values that were appended to the "authors" field in this mutation.
func (m *FeedItemMutation) AppendedAuthors() ([]*modelfeed.Person, bool) {
	if len(m.appendauthors) == 0 {
		return nil, false
	}
	return m.appendauthors, true
}

// ClearAuthors clears the value of the "authors" field.
func (m *FeedItemMutation) ClearAuthors() {
	m.authors = nil
	m.appendauthors = nil
	m.clearedFields[feeditem.FieldAuthors] = struct{}{}
}

// AuthorsCleared returns if the "authors" field was cleared in this mutation.
func (m *FeedItemMutation) AuthorsCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldAuthors]
	return ok
}

// ResetAuthors resets all changes to the "authors" field.
func (m *FeedItemMutation) ResetAuthors() {
	m.authors = nil
	m.appendauthors = nil
	delete(m.clearedFields, feeditem.FieldAuthors)
}

// SetDescription sets the "description" field.
func (m *FeedItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeedItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeedItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[feeditem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeedItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeedItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, feeditem.FieldDescription)
}

// SetContent sets the "content" field.
func (m *FeedItemMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *FeedItemMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *FeedItemMutation) ClearContent() {
	m.content = nil
	m.clearedFields[feeditem.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *FeedItemMutation) ContentCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *FeedItemMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, feeditem.FieldContent)
}

// SetGUID sets the "guid" field.
func (m *FeedItemMutation) SetGUID(s string) {
	m.guid = &s
}

// GUID returns the value of the "guid" field in the mutation.
func (m *FeedItemMutation) GUID() (r string, exists bool) {
	v := m.guid
	if v == nil {
		return
	}
	return *v, true
}

// OldGUID returns the old "guid" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldGUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGUID: %w", err)
	}
	return oldValue.GUID, nil
}

// ResetGUID resets all changes to the "guid" field.
func (m *FeedItemMutation) ResetGUID() {
	m.guid = nil
}

// SetLink sets the "link" field.
func (m *FeedItemMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *FeedItemMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *FeedItemMutation) ClearLink() {
	m.link = nil
	m.clearedFields[feeditem.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *FeedItemMutation) LinkCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *FeedItemMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, feeditem.FieldLink)
}

// SetImage sets the "image" field.
func (m *FeedItemMutation) SetImage(value *modelfeed.Image) {
	m.image = &value
}

// Image returns the value of the "image" field in the mutation.
func (m *FeedItemMutation) Image() (r *modelfeed.Image, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldImage(ctx context.Context) (v *modelfeed.Image, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *FeedItemMutation) ClearImage() {
	m.image = nil
	m.clearedFields[feeditem.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *FeedItemMutation) ImageCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *FeedItemMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, feeditem.FieldImage)
}

// SetPublished sets the "published" field.
func (m *FeedItemMutation) SetPublished(s string) {
	m.published = &s
}

// Published returns the value of the "published" field in the mutation.
func (m *FeedItemMutation) Published() (r string, exists bool) {
	v := m.published
	if v == nil {
		return
	}
	return *v, true
}

// OldPublished returns the old "published" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldPublished(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublished: %w", err)
	}
	return oldValue.Published, nil
}

// ClearPublished clears the value of the "published" field.
func (m *FeedItemMutation) ClearPublished() {
	m.published = nil
	m.clearedFields[feeditem.FieldPublished] = struct{}{}
}

// PublishedCleared returns if the "published" field was cleared in this mutation.
func (m *FeedItemMutation) PublishedCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldPublished]
	return ok
}

// ResetPublished resets all changes to the "published" field.
func (m *FeedItemMutation) ResetPublished() {
	m.published = nil
	delete(m.clearedFields, feeditem.FieldPublished)
}

// SetPublishedParsed sets the "published_parsed" field.
func (m *FeedItemMutation) SetPublishedParsed(t time.Time) {
	m.published_parsed = &t
}

// PublishedParsed returns the value of the "published_parsed" field in the mutation.
func (m *FeedItemMutation) PublishedParsed() (r time.Time, exists bool) {
	v := m.published_parsed
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedParsed returns the old "published_parsed" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldPublishedParsed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedParsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedParsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedParsed: %w", err)
	}
	return oldValue.PublishedParsed, nil
}

// ResetPublishedParsed resets all changes to the "published_parsed" field.
func (m *FeedItemMutation) ResetPublishedParsed() {
	m.published_parsed = nil
}

// SetUpdated sets the "updated" field.
func (m *FeedItemMutation) SetUpdated(s string) {
	m.updated = &s
}

// Updated returns the value of the "updated" field in the mutation.
func (m *FeedItemMutation) Updated() (r string, exists bool) {
	v := m.updated
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdated returns the old "updated" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldUpdated(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdated: %w", err)
	}
	return oldValue.Updated, nil
}

// ClearUpdated clears the value of the "updated" field.
func (m *FeedItemMutation) ClearUpdated() {
	m.updated = nil
	m.clearedFields[feeditem.FieldUpdated] = struct{}{}
}

// UpdatedCleared returns if the "updated" field was cleared in this mutation.
func (m *FeedItemMutation) UpdatedCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldUpdated]
	return ok
}

// ResetUpdated resets all changes to the "updated" field.
func (m *FeedItemMutation) ResetUpdated() {
	m.updated = nil
	delete(m.clearedFields, feeditem.FieldUpdated)
}

// SetUpdatedParsed sets the "updated_parsed" field.
func (m *FeedItemMutation) SetUpdatedParsed(t time.Time) {
	m.updated_parsed = &t
}

// UpdatedParsed returns the value of the "updated_parsed" field in the mutation.
func (m *FeedItemMutation) UpdatedParsed() (r time.Time, exists bool) {
	v := m.updated_parsed
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedParsed returns the old "updated_parsed" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldUpdatedParsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedParsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedParsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedParsed: %w", err)
	}
	return oldValue.UpdatedParsed, nil
}

// ClearUpdatedParsed clears the value of the "updated_parsed" field.
func (m *FeedItemMutation) ClearUpdatedParsed() {
	m.updated_parsed = nil
	m.clearedFields[feeditem.FieldUpdatedParsed] = struct{}{}
}

// UpdatedParsedCleared returns if the "updated_parsed" field was cleared in this mutation.
func (m *FeedItemMutation) UpdatedParsedCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldUpdatedParsed]
	return ok
}

// ResetUpdatedParsed resets all changes to the "updated_parsed" field.
func (m *FeedItemMutation) ResetUpdatedParsed() {
	m.updated_parsed = nil
	delete(m.clearedFields, feeditem.FieldUpdatedParsed)
}

// SetEnclosures sets the "enclosures" field.
func (m *FeedItemMutation) SetEnclosures(value []*modelfeed.Enclosure) {
	m.enclosures = &value
	m.appendenclosures = nil
}

// Enclosures returns the value of the "enclosures" field in the mutation.
func (m *FeedItemMutation) Enclosures() (r []*modelfeed.Enclosure, exists bool) {
	v := m.enclosures
	if v == nil {
		return
	}
	return *v, true
}

// OldEnclosures returns the old "enclosures" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldEnclosures(ctx context.Context) (v []*modelfeed.Enclosure, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnclosures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnclosures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnclosures: %w", err)
	}
	return oldValue.Enclosures, nil
}

// AppendEnclosures adds value to the "enclosures" field.
func (m *FeedItemMutation) AppendEnclosures(value []*modelfeed.Enclosure) {
	m.appendenclosures = append(m.appendenclosures, value...)
}

// AppendedEnclosures returns the list of values that were appended to the "enclosures" field in this mutation.
func (m *FeedItemMutation) AppendedEnclosures() ([]*modelfeed.Enclosure, bool) {
	if len(m.appendenclosures) == 0 {
		return nil, false
	}
	return m.appendenclosures, true
}

// ClearEnclosures clears the value of the "enclosures" field.
func (m *FeedItemMutation) ClearEnclosures() {
	m.enclosures = nil
	m.appendenclosures = nil
	m.clearedFields[feeditem.FieldEnclosures] = struct{}{}
}

// EnclosuresCleared returns if the "enclosures" field was cleared in this mutation.
func (m *FeedItemMutation) EnclosuresCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldEnclosures]
	return ok
}

// ResetEnclosures resets all changes to the "enclosures" field.
func (m *FeedItemMutation) ResetEnclosures() {
	m.enclosures = nil
	m.appendenclosures = nil
	delete(m.clearedFields, feeditem.FieldEnclosures)
}

// SetPublishPlatform sets the "publish_platform" field.
func (m *FeedItemMutation) SetPublishPlatform(s string) {
	m.publish_platform = &s
}

// PublishPlatform returns the value of the "publish_platform" field in the mutation.
func (m *FeedItemMutation) PublishPlatform() (r string, exists bool) {
	v := m.publish_platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishPlatform returns the old "publish_platform" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldPublishPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishPlatform: %w", err)
	}
	return oldValue.PublishPlatform, nil
}

// ClearPublishPlatform clears the value of the "publish_platform" field.
func (m *FeedItemMutation) ClearPublishPlatform() {
	m.publish_platform = nil
	m.clearedFields[feeditem.FieldPublishPlatform] = struct{}{}
}

// PublishPlatformCleared returns if the "publish_platform" field was cleared in this mutation.
func (m *FeedItemMutation) PublishPlatformCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldPublishPlatform]
	return ok
}

// ResetPublishPlatform resets all changes to the "publish_platform" field.
func (m *FeedItemMutation) ResetPublishPlatform() {
	m.publish_platform = nil
	delete(m.clearedFields, feeditem.FieldPublishPlatform)
}

// SetReadCount sets the "read_count" field.
func (m *FeedItemMutation) SetReadCount(i int64) {
	m.read_count = &i
	m.addread_count = nil
}

// ReadCount returns the value of the "read_count" field in the mutation.
func (m *FeedItemMutation) ReadCount() (r int64, exists bool) {
	v := m.read_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReadCount returns the old "read_count" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldReadCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadCount: %w", err)
	}
	return oldValue.ReadCount, nil
}

// AddReadCount adds i to the "read_count" field.
func (m *FeedItemMutation) AddReadCount(i int64) {
	if m.addread_count != nil {
		*m.addread_count += i
	} else {
		m.addread_count = &i
	}
}

// AddedReadCount returns the value that was added to the "read_count" field in this mutation.
func (m *FeedItemMutation) AddedReadCount() (r int64, exists bool) {
	v := m.addread_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReadCount resets all changes to the "read_count" field.
func (m *FeedItemMutation) ResetReadCount() {
	m.read_count = nil
	m.addread_count = nil
}

// SetDigestDescription sets the "digest_description" field.
func (m *FeedItemMutation) SetDigestDescription(s string) {
	m.digest_description = &s
}

// DigestDescription returns the value of the "digest_description" field in the mutation.
func (m *FeedItemMutation) DigestDescription() (r string, exists bool) {
	v := m.digest_description
	if v == nil {
		return
	}
	return *v, true
}

// OldDigestDescription returns the old "digest_description" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldDigestDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigestDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigestDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigestDescription: %w", err)
	}
	return oldValue.DigestDescription, nil
}

// ClearDigestDescription clears the value of the "digest_description" field.
func (m *FeedItemMutation) ClearDigestDescription() {
	m.digest_description = nil
	m.clearedFields[feeditem.FieldDigestDescription] = struct{}{}
}

// DigestDescriptionCleared returns if the "digest_description" field was cleared in this mutation.
func (m *FeedItemMutation) DigestDescriptionCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldDigestDescription]
	return ok
}

// ResetDigestDescription resets all changes to the "digest_description" field.
func (m *FeedItemMutation) ResetDigestDescription() {
	m.digest_description = nil
	delete(m.clearedFields, feeditem.FieldDigestDescription)
}

// SetDigestImages sets the "digest_images" field.
func (m *FeedItemMutation) SetDigestImages(value []*modelfeed.Image) {
	m.digest_images = &value
	m.appenddigest_images = nil
}

// DigestImages returns the value of the "digest_images" field in the mutation.
func (m *FeedItemMutation) DigestImages() (r []*modelfeed.Image, exists bool) {
	v := m.digest_images
	if v == nil {
		return
	}
	return *v, true
}

// OldDigestImages returns the old "digest_images" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldDigestImages(ctx context.Context) (v []*modelfeed.Image, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigestImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigestImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigestImages: %w", err)
	}
	return oldValue.DigestImages, nil
}

// AppendDigestImages adds value to the "digest_images" field.
func (m *FeedItemMutation) AppendDigestImages(value []*modelfeed.Image) {
	m.appenddigest_images = append(m.appenddigest_images, value...)
}

// AppendedDigestImages returns the list of values that were appended to the "digest_images" field in this mutation.
func (m *FeedItemMutation) AppendedDigestImages() ([]*modelfeed.Image, bool) {
	if len(m.appenddigest_images) == 0 {
		return nil, false
	}
	return m.appenddigest_images, true
}

// ClearDigestImages clears the value of the "digest_images" field.
func (m *FeedItemMutation) ClearDigestImages() {
	m.digest_images = nil
	m.appenddigest_images = nil
	m.clearedFields[feeditem.FieldDigestImages] = struct{}{}
}

// DigestImagesCleared returns if the "digest_images" field was cleared in this mutation.
func (m *FeedItemMutation) DigestImagesCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldDigestImages]
	return ok
}

// ResetDigestImages resets all changes to the "digest_images" field.
func (m *FeedItemMutation) ResetDigestImages() {
	m.digest_images = nil
	m.appenddigest_images = nil
	delete(m.clearedFields, feeditem.FieldDigestImages)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearFeed clears the "feed" edge to the Feed entity.
func (m *FeedItemMutation) ClearFeed() {
	m.clearedfeed = true
	m.clearedFields[feeditem.FieldFeedID] = struct{}{}
}

// FeedCleared reports if the "feed" edge to the Feed entity was cleared.
func (m *FeedItemMutation) FeedCleared() bool {
	return m.clearedfeed
}

// FeedIDs returns the "feed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedID instead. It exists only for internal usage by the builders.
func (m *FeedItemMutation) FeedIDs() (ids []model.InternalID) {
	if id := m.feed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeed resets all changes to the "feed" edge.
func (m *FeedItemMutation) ResetFeed() {
	m.feed = nil
	m.clearedfeed = false
}

// AddFeedItemCollectionIDs adds the "feed_item_collection" edge to the FeedItemCollection entity by ids.
func (m *FeedItemMutation) AddFeedItemCollectionIDs(ids ...model.InternalID) {
	if m.feed_item_collection == nil {
		m.feed_item_collection = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_item_collection[ids[i]] = struct{}{}
	}
}

// ClearFeedItemCollection clears the "feed_item_collection" edge to the FeedItemCollection entity.
func (m *FeedItemMutation) ClearFeedItemCollection() {
	m.clearedfeed_item_collection = true
}

// FeedItemCollectionCleared reports if the "feed_item_collection" edge to the FeedItemCollection entity was cleared.
func (m *FeedItemMutation) FeedItemCollectionCleared() bool {
	return m.clearedfeed_item_collection
}

// RemoveFeedItemCollectionIDs removes the "feed_item_collection" edge to the FeedItemCollection entity by IDs.
func (m *FeedItemMutation) RemoveFeedItemCollectionIDs(ids ...model.InternalID) {
	if m.removedfeed_item_collection == nil {
		m.removedfeed_item_collection = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_item_collection, ids[i])
		m.removedfeed_item_collection[ids[i]] = struct{}{}
	}
}

// RemovedFeedItemCollection returns the removed IDs of the "feed_item_collection" edge to the FeedItemCollection entity.
func (m *FeedItemMutation) RemovedFeedItemCollectionIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_item_collection {
		ids = append(ids, id)
	}
	return
}

// FeedItemCollectionIDs returns the "feed_item_collection" edge IDs in the mutation.
func (m *FeedItemMutation) FeedItemCollectionIDs() (ids []model.InternalID) {
	for id := range m.feed_item_collection {
		ids = append(ids, id)
	}
	return
}

// ResetFeedItemCollection resets all changes to the "feed_item_collection" edge.
func (m *FeedItemMutation) ResetFeedItemCollection() {
	m.feed_item_collection = nil
	m.clearedfeed_item_collection = false
	m.removedfeed_item_collection = nil
}

// Where appends a list predicates to the FeedItemMutation builder.
func (m *FeedItemMutation) Where(ps ...predicate.FeedItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeedItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeedItem).
func (m *FeedItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedItemMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.feed != nil {
		fields = append(fields, feeditem.FieldFeedID)
	}
	if m.title != nil {
		fields = append(fields, feeditem.FieldTitle)
	}
	if m.authors != nil {
		fields = append(fields, feeditem.FieldAuthors)
	}
	if m.description != nil {
		fields = append(fields, feeditem.FieldDescription)
	}
	if m.content != nil {
		fields = append(fields, feeditem.FieldContent)
	}
	if m.guid != nil {
		fields = append(fields, feeditem.FieldGUID)
	}
	if m.link != nil {
		fields = append(fields, feeditem.FieldLink)
	}
	if m.image != nil {
		fields = append(fields, feeditem.FieldImage)
	}
	if m.published != nil {
		fields = append(fields, feeditem.FieldPublished)
	}
	if m.published_parsed != nil {
		fields = append(fields, feeditem.FieldPublishedParsed)
	}
	if m.updated != nil {
		fields = append(fields, feeditem.FieldUpdated)
	}
	if m.updated_parsed != nil {
		fields = append(fields, feeditem.FieldUpdatedParsed)
	}
	if m.enclosures != nil {
		fields = append(fields, feeditem.FieldEnclosures)
	}
	if m.publish_platform != nil {
		fields = append(fields, feeditem.FieldPublishPlatform)
	}
	if m.read_count != nil {
		fields = append(fields, feeditem.FieldReadCount)
	}
	if m.digest_description != nil {
		fields = append(fields, feeditem.FieldDigestDescription)
	}
	if m.digest_images != nil {
		fields = append(fields, feeditem.FieldDigestImages)
	}
	if m.updated_at != nil {
		fields = append(fields, feeditem.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feeditem.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feeditem.FieldFeedID:
		return m.FeedID()
	case feeditem.FieldTitle:
		return m.Title()
	case feeditem.FieldAuthors:
		return m.Authors()
	case feeditem.FieldDescription:
		return m.Description()
	case feeditem.FieldContent:
		return m.Content()
	case feeditem.FieldGUID:
		return m.GUID()
	case feeditem.FieldLink:
		return m.Link()
	case feeditem.FieldImage:
		return m.Image()
	case feeditem.FieldPublished:
		return m.Published()
	case feeditem.FieldPublishedParsed:
		return m.PublishedParsed()
	case feeditem.FieldUpdated:
		return m.Updated()
	case feeditem.FieldUpdatedParsed:
		return m.UpdatedParsed()
	case feeditem.FieldEnclosures:
		return m.Enclosures()
	case feeditem.FieldPublishPlatform:
		return m.PublishPlatform()
	case feeditem.FieldReadCount:
		return m.ReadCount()
	case feeditem.FieldDigestDescription:
		return m.DigestDescription()
	case feeditem.FieldDigestImages:
		return m.DigestImages()
	case feeditem.FieldUpdatedAt:
		return m.UpdatedAt()
	case feeditem.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feeditem.FieldFeedID:
		return m.OldFeedID(ctx)
	case feeditem.FieldTitle:
		return m.OldTitle(ctx)
	case feeditem.FieldAuthors:
		return m.OldAuthors(ctx)
	case feeditem.FieldDescription:
		return m.OldDescription(ctx)
	case feeditem.FieldContent:
		return m.OldContent(ctx)
	case feeditem.FieldGUID:
		return m.OldGUID(ctx)
	case feeditem.FieldLink:
		return m.OldLink(ctx)
	case feeditem.FieldImage:
		return m.OldImage(ctx)
	case feeditem.FieldPublished:
		return m.OldPublished(ctx)
	case feeditem.FieldPublishedParsed:
		return m.OldPublishedParsed(ctx)
	case feeditem.FieldUpdated:
		return m.OldUpdated(ctx)
	case feeditem.FieldUpdatedParsed:
		return m.OldUpdatedParsed(ctx)
	case feeditem.FieldEnclosures:
		return m.OldEnclosures(ctx)
	case feeditem.FieldPublishPlatform:
		return m.OldPublishPlatform(ctx)
	case feeditem.FieldReadCount:
		return m.OldReadCount(ctx)
	case feeditem.FieldDigestDescription:
		return m.OldDigestDescription(ctx)
	case feeditem.FieldDigestImages:
		return m.OldDigestImages(ctx)
	case feeditem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feeditem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeedItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feeditem.FieldFeedID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedID(v)
		return nil
	case feeditem.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case feeditem.FieldAuthors:
		v, ok := value.([]*modelfeed.Person)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthors(v)
		return nil
	case feeditem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feeditem.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case feeditem.FieldGUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGUID(v)
		return nil
	case feeditem.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case feeditem.FieldImage:
		v, ok := value.(*modelfeed.Image)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case feeditem.FieldPublished:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublished(v)
		return nil
	case feeditem.FieldPublishedParsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedParsed(v)
		return nil
	case feeditem.FieldUpdated:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdated(v)
		return nil
	case feeditem.FieldUpdatedParsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedParsed(v)
		return nil
	case feeditem.FieldEnclosures:
		v, ok := value.([]*modelfeed.Enclosure)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnclosures(v)
		return nil
	case feeditem.FieldPublishPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishPlatform(v)
		return nil
	case feeditem.FieldReadCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadCount(v)
		return nil
	case feeditem.FieldDigestDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigestDescription(v)
		return nil
	case feeditem.FieldDigestImages:
		v, ok := value.([]*modelfeed.Image)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigestImages(v)
		return nil
	case feeditem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feeditem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeedItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedItemMutation) AddedFields() []string {
	var fields []string
	if m.addread_count != nil {
		fields = append(fields, feeditem.FieldReadCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feeditem.FieldReadCount:
		return m.AddedReadCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feeditem.FieldReadCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReadCount(v)
		return nil
	}
	return fmt.Errorf("unknown FeedItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feeditem.FieldTitle) {
		fields = append(fields, feeditem.FieldTitle)
	}
	if m.FieldCleared(feeditem.FieldAuthors) {
		fields = append(fields, feeditem.FieldAuthors)
	}
	if m.FieldCleared(feeditem.FieldDescription) {
		fields = append(fields, feeditem.FieldDescription)
	}
	if m.FieldCleared(feeditem.FieldContent) {
		fields = append(fields, feeditem.FieldContent)
	}
	if m.FieldCleared(feeditem.FieldLink) {
		fields = append(fields, feeditem.FieldLink)
	}
	if m.FieldCleared(feeditem.FieldImage) {
		fields = append(fields, feeditem.FieldImage)
	}
	if m.FieldCleared(feeditem.FieldPublished) {
		fields = append(fields, feeditem.FieldPublished)
	}
	if m.FieldCleared(feeditem.FieldUpdated) {
		fields = append(fields, feeditem.FieldUpdated)
	}
	if m.FieldCleared(feeditem.FieldUpdatedParsed) {
		fields = append(fields, feeditem.FieldUpdatedParsed)
	}
	if m.FieldCleared(feeditem.FieldEnclosures) {
		fields = append(fields, feeditem.FieldEnclosures)
	}
	if m.FieldCleared(feeditem.FieldPublishPlatform) {
		fields = append(fields, feeditem.FieldPublishPlatform)
	}
	if m.FieldCleared(feeditem.FieldDigestDescription) {
		fields = append(fields, feeditem.FieldDigestDescription)
	}
	if m.FieldCleared(feeditem.FieldDigestImages) {
		fields = append(fields, feeditem.FieldDigestImages)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedItemMutation) ClearField(name string) error {
	switch name {
	case feeditem.FieldTitle:
		m.ClearTitle()
		return nil
	case feeditem.FieldAuthors:
		m.ClearAuthors()
		return nil
	case feeditem.FieldDescription:
		m.ClearDescription()
		return nil
	case feeditem.FieldContent:
		m.ClearContent()
		return nil
	case feeditem.FieldLink:
		m.ClearLink()
		return nil
	case feeditem.FieldImage:
		m.ClearImage()
		return nil
	case feeditem.FieldPublished:
		m.ClearPublished()
		return nil
	case feeditem.FieldUpdated:
		m.ClearUpdated()
		return nil
	case feeditem.FieldUpdatedParsed:
		m.ClearUpdatedParsed()
		return nil
	case feeditem.FieldEnclosures:
		m.ClearEnclosures()
		return nil
	case feeditem.FieldPublishPlatform:
		m.ClearPublishPlatform()
		return nil
	case feeditem.FieldDigestDescription:
		m.ClearDigestDescription()
		return nil
	case feeditem.FieldDigestImages:
		m.ClearDigestImages()
		return nil
	}
	return fmt.Errorf("unknown FeedItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedItemMutation) ResetField(name string) error {
	switch name {
	case feeditem.FieldFeedID:
		m.ResetFeedID()
		return nil
	case feeditem.FieldTitle:
		m.ResetTitle()
		return nil
	case feeditem.FieldAuthors:
		m.ResetAuthors()
		return nil
	case feeditem.FieldDescription:
		m.ResetDescription()
		return nil
	case feeditem.FieldContent:
		m.ResetContent()
		return nil
	case feeditem.FieldGUID:
		m.ResetGUID()
		return nil
	case feeditem.FieldLink:
		m.ResetLink()
		return nil
	case feeditem.FieldImage:
		m.ResetImage()
		return nil
	case feeditem.FieldPublished:
		m.ResetPublished()
		return nil
	case feeditem.FieldPublishedParsed:
		m.ResetPublishedParsed()
		return nil
	case feeditem.FieldUpdated:
		m.ResetUpdated()
		return nil
	case feeditem.FieldUpdatedParsed:
		m.ResetUpdatedParsed()
		return nil
	case feeditem.FieldEnclosures:
		m.ResetEnclosures()
		return nil
	case feeditem.FieldPublishPlatform:
		m.ResetPublishPlatform()
		return nil
	case feeditem.FieldReadCount:
		m.ResetReadCount()
		return nil
	case feeditem.FieldDigestDescription:
		m.ResetDigestDescription()
		return nil
	case feeditem.FieldDigestImages:
		m.ResetDigestImages()
		return nil
	case feeditem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feeditem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeedItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.feed != nil {
		edges = append(edges, feeditem.EdgeFeed)
	}
	if m.feed_item_collection != nil {
		edges = append(edges, feeditem.EdgeFeedItemCollection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feeditem.EdgeFeed:
		if id := m.feed; id != nil {
			return []ent.Value{*id}
		}
	case feeditem.EdgeFeedItemCollection:
		ids := make([]ent.Value, 0, len(m.feed_item_collection))
		for id := range m.feed_item_collection {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfeed_item_collection != nil {
		edges = append(edges, feeditem.EdgeFeedItemCollection)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feeditem.EdgeFeedItemCollection:
		ids := make([]ent.Value, 0, len(m.removedfeed_item_collection))
		for id := range m.removedfeed_item_collection {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfeed {
		edges = append(edges, feeditem.EdgeFeed)
	}
	if m.clearedfeed_item_collection {
		edges = append(edges, feeditem.EdgeFeedItemCollection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedItemMutation) EdgeCleared(name string) bool {
	switch name {
	case feeditem.EdgeFeed:
		return m.clearedfeed
	case feeditem.EdgeFeedItemCollection:
		return m.clearedfeed_item_collection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedItemMutation) ClearEdge(name string) error {
	switch name {
	case feeditem.EdgeFeed:
		m.ClearFeed()
		return nil
	}
	return fmt.Errorf("unknown FeedItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedItemMutation) ResetEdge(name string) error {
	switch name {
	case feeditem.EdgeFeed:
		m.ResetFeed()
		return nil
	case feeditem.EdgeFeedItemCollection:
		m.ResetFeedItemCollection()
		return nil
	}
	return fmt.Errorf("unknown FeedItem edge %s", name)
}

// FeedItemCollectionMutation represents an operation that mutates the FeedItemCollection nodes in the graph.
type FeedItemCollectionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *model.InternalID
	name                 *string
	description          *string
	category             *string
	updated_at           *time.Time
	created_at           *time.Time
	clearedFields        map[string]struct{}
	owner                *model.InternalID
	clearedowner         bool
	feed_item            map[model.InternalID]struct{}
	removedfeed_item     map[model.InternalID]struct{}
	clearedfeed_item     bool
	notify_source        map[model.InternalID]struct{}
	removednotify_source map[model.InternalID]struct{}
	clearednotify_source bool
	done                 bool
	oldValue             func(context.Context) (*FeedItemCollection, error)
	predicates           []predicate.FeedItemCollection
}

var _ ent.Mutation = (*FeedItemCollectionMutation)(nil)

// feeditemcollectionOption allows management of the mutation configuration using functional options.
type feeditemcollectionOption func(*FeedItemCollectionMutation)

// newFeedItemCollectionMutation creates new mutation for the FeedItemCollection entity.
func newFeedItemCollectionMutation(c config, op Op, opts ...feeditemcollectionOption) *FeedItemCollectionMutation {
	m := &FeedItemCollectionMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedItemCollection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedItemCollectionID sets the ID field of the mutation.
func withFeedItemCollectionID(id model.InternalID) feeditemcollectionOption {
	return func(m *FeedItemCollectionMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedItemCollection
		)
		m.oldValue = func(ctx context.Context) (*FeedItemCollection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedItemCollection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedItemCollection sets the old FeedItemCollection of the mutation.
func withFeedItemCollection(node *FeedItemCollection) feeditemcollectionOption {
	return func(m *FeedItemCollectionMutation) {
		m.oldValue = func(context.Context) (*FeedItemCollection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedItemCollectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedItemCollectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeedItemCollection entities.
func (m *FeedItemCollectionMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedItemCollectionMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedItemCollectionMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeedItemCollection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FeedItemCollectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeedItemCollectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeedItemCollection entity.
// If the FeedItemCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemCollectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeedItemCollectionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *FeedItemCollectionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeedItemCollectionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeedItemCollection entity.
// If the FeedItemCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemCollectionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FeedItemCollectionMutation) ResetDescription() {
	m.description = nil
}

// SetCategory sets the "category" field.
func (m *FeedItemCollectionMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *FeedItemCollectionMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the FeedItemCollection entity.
// If the FeedItemCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemCollectionMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *FeedItemCollectionMutation) ResetCategory() {
	m.category = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedItemCollectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedItemCollectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeedItemCollection entity.
// If the FeedItemCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemCollectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedItemCollectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedItemCollectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedItemCollectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeedItemCollection entity.
// If the FeedItemCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemCollectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedItemCollectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *FeedItemCollectionMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FeedItemCollectionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FeedItemCollectionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *FeedItemCollectionMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FeedItemCollectionMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FeedItemCollectionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddFeedItemIDs adds the "feed_item" edge to the FeedItem entity by ids.
func (m *FeedItemCollectionMutation) AddFeedItemIDs(ids ...model.InternalID) {
	if m.feed_item == nil {
		m.feed_item = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_item[ids[i]] = struct{}{}
	}
}

// ClearFeedItem clears the "feed_item" edge to the FeedItem entity.
func (m *FeedItemCollectionMutation) ClearFeedItem() {
	m.clearedfeed_item = true
}

// FeedItemCleared reports if the "feed_item" edge to the FeedItem entity was cleared.
func (m *FeedItemCollectionMutation) FeedItemCleared() bool {
	return m.clearedfeed_item
}

// RemoveFeedItemIDs removes the "feed_item" edge to the FeedItem entity by IDs.
func (m *FeedItemCollectionMutation) RemoveFeedItemIDs(ids ...model.InternalID) {
	if m.removedfeed_item == nil {
		m.removedfeed_item = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_item, ids[i])
		m.removedfeed_item[ids[i]] = struct{}{}
	}
}

// RemovedFeedItem returns the removed IDs of the "feed_item" edge to the FeedItem entity.
func (m *FeedItemCollectionMutation) RemovedFeedItemIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_item {
		ids = append(ids, id)
	}
	return
}

// FeedItemIDs returns the "feed_item" edge IDs in the mutation.
func (m *FeedItemCollectionMutation) FeedItemIDs() (ids []model.InternalID) {
	for id := range m.feed_item {
		ids = append(ids, id)
	}
	return
}

// ResetFeedItem resets all changes to the "feed_item" edge.
func (m *FeedItemCollectionMutation) ResetFeedItem() {
	m.feed_item = nil
	m.clearedfeed_item = false
	m.removedfeed_item = nil
}

// AddNotifySourceIDs adds the "notify_source" edge to the NotifySource entity by ids.
func (m *FeedItemCollectionMutation) AddNotifySourceIDs(ids ...model.InternalID) {
	if m.notify_source == nil {
		m.notify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_source[ids[i]] = struct{}{}
	}
}

// ClearNotifySource clears the "notify_source" edge to the NotifySource entity.
func (m *FeedItemCollectionMutation) ClearNotifySource() {
	m.clearednotify_source = true
}

// NotifySourceCleared reports if the "notify_source" edge to the NotifySource entity was cleared.
func (m *FeedItemCollectionMutation) NotifySourceCleared() bool {
	return m.clearednotify_source
}

// RemoveNotifySourceIDs removes the "notify_source" edge to the NotifySource entity by IDs.
func (m *FeedItemCollectionMutation) RemoveNotifySourceIDs(ids ...model.InternalID) {
	if m.removednotify_source == nil {
		m.removednotify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_source, ids[i])
		m.removednotify_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifySource returns the removed IDs of the "notify_source" edge to the NotifySource entity.
func (m *FeedItemCollectionMutation) RemovedNotifySourceIDs() (ids []model.InternalID) {
	for id := range m.removednotify_source {
		ids = append(ids, id)
	}
	return
}

// NotifySourceIDs returns the "notify_source" edge IDs in the mutation.
func (m *FeedItemCollectionMutation) NotifySourceIDs() (ids []model.InternalID) {
	for id := range m.notify_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifySource resets all changes to the "notify_source" edge.
func (m *FeedItemCollectionMutation) ResetNotifySource() {
	m.notify_source = nil
	m.clearednotify_source = false
	m.removednotify_source = nil
}

// Where appends a list predicates to the FeedItemCollectionMutation builder.
func (m *FeedItemCollectionMutation) Where(ps ...predicate.FeedItemCollection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedItemCollectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedItemCollectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeedItemCollection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedItemCollectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedItemCollectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeedItemCollection).
func (m *FeedItemCollectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedItemCollectionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, feeditemcollection.FieldName)
	}
	if m.description != nil {
		fields = append(fields, feeditemcollection.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, feeditemcollection.FieldCategory)
	}
	if m.updated_at != nil {
		fields = append(fields, feeditemcollection.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feeditemcollection.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedItemCollectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feeditemcollection.FieldName:
		return m.Name()
	case feeditemcollection.FieldDescription:
		return m.Description()
	case feeditemcollection.FieldCategory:
		return m.Category()
	case feeditemcollection.FieldUpdatedAt:
		return m.UpdatedAt()
	case feeditemcollection.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedItemCollectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feeditemcollection.FieldName:
		return m.OldName(ctx)
	case feeditemcollection.FieldDescription:
		return m.OldDescription(ctx)
	case feeditemcollection.FieldCategory:
		return m.OldCategory(ctx)
	case feeditemcollection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feeditemcollection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeedItemCollection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedItemCollectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feeditemcollection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feeditemcollection.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feeditemcollection.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case feeditemcollection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feeditemcollection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeedItemCollection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedItemCollectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedItemCollectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedItemCollectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeedItemCollection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedItemCollectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedItemCollectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedItemCollectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeedItemCollection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedItemCollectionMutation) ResetField(name string) error {
	switch name {
	case feeditemcollection.FieldName:
		m.ResetName()
		return nil
	case feeditemcollection.FieldDescription:
		m.ResetDescription()
		return nil
	case feeditemcollection.FieldCategory:
		m.ResetCategory()
		return nil
	case feeditemcollection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feeditemcollection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeedItemCollection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedItemCollectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, feeditemcollection.EdgeOwner)
	}
	if m.feed_item != nil {
		edges = append(edges, feeditemcollection.EdgeFeedItem)
	}
	if m.notify_source != nil {
		edges = append(edges, feeditemcollection.EdgeNotifySource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedItemCollectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feeditemcollection.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case feeditemcollection.EdgeFeedItem:
		ids := make([]ent.Value, 0, len(m.feed_item))
		for id := range m.feed_item {
			ids = append(ids, id)
		}
		return ids
	case feeditemcollection.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.notify_source))
		for id := range m.notify_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedItemCollectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfeed_item != nil {
		edges = append(edges, feeditemcollection.EdgeFeedItem)
	}
	if m.removednotify_source != nil {
		edges = append(edges, feeditemcollection.EdgeNotifySource)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedItemCollectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feeditemcollection.EdgeFeedItem:
		ids := make([]ent.Value, 0, len(m.removedfeed_item))
		for id := range m.removedfeed_item {
			ids = append(ids, id)
		}
		return ids
	case feeditemcollection.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.removednotify_source))
		for id := range m.removednotify_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedItemCollectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, feeditemcollection.EdgeOwner)
	}
	if m.clearedfeed_item {
		edges = append(edges, feeditemcollection.EdgeFeedItem)
	}
	if m.clearednotify_source {
		edges = append(edges, feeditemcollection.EdgeNotifySource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedItemCollectionMutation) EdgeCleared(name string) bool {
	switch name {
	case feeditemcollection.EdgeOwner:
		return m.clearedowner
	case feeditemcollection.EdgeFeedItem:
		return m.clearedfeed_item
	case feeditemcollection.EdgeNotifySource:
		return m.clearednotify_source
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedItemCollectionMutation) ClearEdge(name string) error {
	switch name {
	case feeditemcollection.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown FeedItemCollection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedItemCollectionMutation) ResetEdge(name string) error {
	switch name {
	case feeditemcollection.EdgeOwner:
		m.ResetOwner()
		return nil
	case feeditemcollection.EdgeFeedItem:
		m.ResetFeedItem()
		return nil
	case feeditemcollection.EdgeNotifySource:
		m.ResetNotifySource()
		return nil
	}
	return fmt.Errorf("unknown FeedItemCollection edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	name          *string
	size          *int64
	addsize       *int64
	_type         *file.Type
	sha256        *[]byte
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *model.InternalID
	clearedowner  bool
	image         *model.InternalID
	clearedimage  bool
	done          bool
	oldValue      func(context.Context) (*File, error)
	predicates    []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id model.InternalID) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetType sets the "type" field.
func (m *FileMutation) SetType(f file.Type) {
	m._type = &f
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileMutation) GetType() (r file.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v file.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FileMutation) ResetType() {
	m._type = nil
}

// SetSha256 sets the "sha256" field.
func (m *FileMutation) SetSha256(b []byte) {
	m.sha256 = &b
}

// Sha256 returns the value of the "sha256" field in the mutation.
func (m *FileMutation) Sha256() (r []byte, exists bool) {
	v := m.sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldSha256 returns the old "sha256" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSha256(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha256: %w", err)
	}
	return oldValue.Sha256, nil
}

// ResetSha256 resets all changes to the "sha256" field.
func (m *FileMutation) ResetSha256() {
	m.sha256 = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *FileMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FileMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FileMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *FileMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FileMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FileMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetImageID sets the "image" edge to the Image entity by id.
func (m *FileMutation) SetImageID(id model.InternalID) {
	m.image = &id
}

// ClearImage clears the "image" edge to the Image entity.
func (m *FileMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *FileMutation) ImageCleared() bool {
	return m.clearedimage
}

// ImageID returns the "image" edge ID in the mutation.
func (m *FileMutation) ImageID() (id model.InternalID, exists bool) {
	if m.image != nil {
		return *m.image, true
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageID instead. It exists only for internal usage by the builders.
func (m *FileMutation) ImageIDs() (ids []model.InternalID) {
	if id := m.image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *FileMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m._type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.sha256 != nil {
		fields = append(fields, file.FieldSha256)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldName:
		return m.Name()
	case file.FieldSize:
		return m.Size()
	case file.FieldType:
		return m.GetType()
	case file.FieldSha256:
		return m.Sha256()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldSha256:
		return m.OldSha256(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldType:
		v, ok := value.(file.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldSha256:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha256(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldSha256:
		m.ResetSha256()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, file.EdgeOwner)
	}
	if m.image != nil {
		edges = append(edges, file.EdgeImage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeImage:
		if id := m.image; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, file.EdgeOwner)
	}
	if m.clearedimage {
		edges = append(edges, file.EdgeImage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeOwner:
		return m.clearedowner
	case file.EdgeImage:
		return m.clearedimage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeOwner:
		m.ClearOwner()
		return nil
	case file.EdgeImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeOwner:
		m.ResetOwner()
		return nil
	case file.EdgeImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	name          *string
	description   *string
	status        *image.Status
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *model.InternalID
	clearedowner  bool
	file          *model.InternalID
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*Image, error)
	predicates    []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id model.InternalID) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Image entities.
func (m *ImageMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ImageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ImageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ImageMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ImageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ImageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ImageMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *ImageMutation) SetStatus(i image.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *ImageMutation) Status() (r image.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldStatus(ctx context.Context) (v image.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ImageMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *ImageMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ImageMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ImageMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ImageMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ImageMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *ImageMutation) SetFileID(id model.InternalID) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *ImageMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *ImageMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *ImageMutation) FileID() (id model.InternalID, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) FileIDs() (ids []model.InternalID) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *ImageMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Image, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, image.FieldName)
	}
	if m.description != nil {
		fields = append(fields, image.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, image.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, image.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, image.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldName:
		return m.Name()
	case image.FieldDescription:
		return m.Description()
	case image.FieldStatus:
		return m.Status()
	case image.FieldUpdatedAt:
		return m.UpdatedAt()
	case image.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldName:
		return m.OldName(ctx)
	case image.FieldDescription:
		return m.OldDescription(ctx)
	case image.FieldStatus:
		return m.OldStatus(ctx)
	case image.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case image.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case image.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case image.FieldStatus:
		v, ok := value.(image.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case image.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case image.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldName:
		m.ResetName()
		return nil
	case image.FieldDescription:
		m.ResetDescription()
		return nil
	case image.FieldStatus:
		m.ResetStatus()
		return nil
	case image.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case image.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, image.EdgeOwner)
	}
	if m.file != nil {
		edges = append(edges, image.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, image.EdgeOwner)
	}
	if m.clearedfile {
		edges = append(edges, image.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeOwner:
		return m.clearedowner
	case image.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	case image.EdgeOwner:
		m.ClearOwner()
		return nil
	case image.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeOwner:
		m.ResetOwner()
		return nil
	case image.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// NotifyFlowMutation represents an operation that mutates the NotifyFlow nodes in the graph.
type NotifyFlowMutation struct {
	config
	op                        Op
	typ                       string
	id                        *model.InternalID
	name                      *string
	description               *string
	status                    *notifyflow.Status
	updated_at                *time.Time
	created_at                *time.Time
	clearedFields             map[string]struct{}
	owner                     *model.InternalID
	clearedowner              bool
	notify_target             map[model.InternalID]struct{}
	removednotify_target      map[model.InternalID]struct{}
	clearednotify_target      bool
	notify_source             map[model.InternalID]struct{}
	removednotify_source      map[model.InternalID]struct{}
	clearednotify_source      bool
	notify_flow_target        map[int]struct{}
	removednotify_flow_target map[int]struct{}
	clearednotify_flow_target bool
	notify_flow_source        map[int]struct{}
	removednotify_flow_source map[int]struct{}
	clearednotify_flow_source bool
	done                      bool
	oldValue                  func(context.Context) (*NotifyFlow, error)
	predicates                []predicate.NotifyFlow
}

var _ ent.Mutation = (*NotifyFlowMutation)(nil)

// notifyflowOption allows management of the mutation configuration using functional options.
type notifyflowOption func(*NotifyFlowMutation)

// newNotifyFlowMutation creates new mutation for the NotifyFlow entity.
func newNotifyFlowMutation(c config, op Op, opts ...notifyflowOption) *NotifyFlowMutation {
	m := &NotifyFlowMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyFlowID sets the ID field of the mutation.
func withNotifyFlowID(id model.InternalID) notifyflowOption {
	return func(m *NotifyFlowMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyFlow
		)
		m.oldValue = func(ctx context.Context) (*NotifyFlow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyFlow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyFlow sets the old NotifyFlow of the mutation.
func withNotifyFlow(node *NotifyFlow) notifyflowOption {
	return func(m *NotifyFlowMutation) {
		m.oldValue = func(context.Context) (*NotifyFlow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyFlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyFlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotifyFlow entities.
func (m *NotifyFlowMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyFlowMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyFlowMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyFlow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NotifyFlowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotifyFlowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotifyFlowMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NotifyFlowMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotifyFlowMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *NotifyFlowMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *NotifyFlowMutation) SetStatus(n notifyflow.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NotifyFlowMutation) Status() (r notifyflow.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldStatus(ctx context.Context) (v notifyflow.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NotifyFlowMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyFlowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyFlowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyFlowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyFlowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyFlowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyFlowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *NotifyFlowMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *NotifyFlowMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *NotifyFlowMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NotifyFlowMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NotifyFlowMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddNotifyTargetIDs adds the "notify_target" edge to the NotifyTarget entity by ids.
func (m *NotifyFlowMutation) AddNotifyTargetIDs(ids ...model.InternalID) {
	if m.notify_target == nil {
		m.notify_target = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_target[ids[i]] = struct{}{}
	}
}

// ClearNotifyTarget clears the "notify_target" edge to the NotifyTarget entity.
func (m *NotifyFlowMutation) ClearNotifyTarget() {
	m.clearednotify_target = true
}

// NotifyTargetCleared reports if the "notify_target" edge to the NotifyTarget entity was cleared.
func (m *NotifyFlowMutation) NotifyTargetCleared() bool {
	return m.clearednotify_target
}

// RemoveNotifyTargetIDs removes the "notify_target" edge to the NotifyTarget entity by IDs.
func (m *NotifyFlowMutation) RemoveNotifyTargetIDs(ids ...model.InternalID) {
	if m.removednotify_target == nil {
		m.removednotify_target = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_target, ids[i])
		m.removednotify_target[ids[i]] = struct{}{}
	}
}

// RemovedNotifyTarget returns the removed IDs of the "notify_target" edge to the NotifyTarget entity.
func (m *NotifyFlowMutation) RemovedNotifyTargetIDs() (ids []model.InternalID) {
	for id := range m.removednotify_target {
		ids = append(ids, id)
	}
	return
}

// NotifyTargetIDs returns the "notify_target" edge IDs in the mutation.
func (m *NotifyFlowMutation) NotifyTargetIDs() (ids []model.InternalID) {
	for id := range m.notify_target {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyTarget resets all changes to the "notify_target" edge.
func (m *NotifyFlowMutation) ResetNotifyTarget() {
	m.notify_target = nil
	m.clearednotify_target = false
	m.removednotify_target = nil
}

// AddNotifySourceIDs adds the "notify_source" edge to the NotifySource entity by ids.
func (m *NotifyFlowMutation) AddNotifySourceIDs(ids ...model.InternalID) {
	if m.notify_source == nil {
		m.notify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_source[ids[i]] = struct{}{}
	}
}

// ClearNotifySource clears the "notify_source" edge to the NotifySource entity.
func (m *NotifyFlowMutation) ClearNotifySource() {
	m.clearednotify_source = true
}

// NotifySourceCleared reports if the "notify_source" edge to the NotifySource entity was cleared.
func (m *NotifyFlowMutation) NotifySourceCleared() bool {
	return m.clearednotify_source
}

// RemoveNotifySourceIDs removes the "notify_source" edge to the NotifySource entity by IDs.
func (m *NotifyFlowMutation) RemoveNotifySourceIDs(ids ...model.InternalID) {
	if m.removednotify_source == nil {
		m.removednotify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_source, ids[i])
		m.removednotify_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifySource returns the removed IDs of the "notify_source" edge to the NotifySource entity.
func (m *NotifyFlowMutation) RemovedNotifySourceIDs() (ids []model.InternalID) {
	for id := range m.removednotify_source {
		ids = append(ids, id)
	}
	return
}

// NotifySourceIDs returns the "notify_source" edge IDs in the mutation.
func (m *NotifyFlowMutation) NotifySourceIDs() (ids []model.InternalID) {
	for id := range m.notify_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifySource resets all changes to the "notify_source" edge.
func (m *NotifyFlowMutation) ResetNotifySource() {
	m.notify_source = nil
	m.clearednotify_source = false
	m.removednotify_source = nil
}

// AddNotifyFlowTargetIDs adds the "notify_flow_target" edge to the NotifyFlowTarget entity by ids.
func (m *NotifyFlowMutation) AddNotifyFlowTargetIDs(ids ...int) {
	if m.notify_flow_target == nil {
		m.notify_flow_target = make(map[int]struct{})
	}
	for i := range ids {
		m.notify_flow_target[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlowTarget clears the "notify_flow_target" edge to the NotifyFlowTarget entity.
func (m *NotifyFlowMutation) ClearNotifyFlowTarget() {
	m.clearednotify_flow_target = true
}

// NotifyFlowTargetCleared reports if the "notify_flow_target" edge to the NotifyFlowTarget entity was cleared.
func (m *NotifyFlowMutation) NotifyFlowTargetCleared() bool {
	return m.clearednotify_flow_target
}

// RemoveNotifyFlowTargetIDs removes the "notify_flow_target" edge to the NotifyFlowTarget entity by IDs.
func (m *NotifyFlowMutation) RemoveNotifyFlowTargetIDs(ids ...int) {
	if m.removednotify_flow_target == nil {
		m.removednotify_flow_target = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notify_flow_target, ids[i])
		m.removednotify_flow_target[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlowTarget returns the removed IDs of the "notify_flow_target" edge to the NotifyFlowTarget entity.
func (m *NotifyFlowMutation) RemovedNotifyFlowTargetIDs() (ids []int) {
	for id := range m.removednotify_flow_target {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowTargetIDs returns the "notify_flow_target" edge IDs in the mutation.
func (m *NotifyFlowMutation) NotifyFlowTargetIDs() (ids []int) {
	for id := range m.notify_flow_target {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlowTarget resets all changes to the "notify_flow_target" edge.
func (m *NotifyFlowMutation) ResetNotifyFlowTarget() {
	m.notify_flow_target = nil
	m.clearednotify_flow_target = false
	m.removednotify_flow_target = nil
}

// AddNotifyFlowSourceIDs adds the "notify_flow_source" edge to the NotifyFlowSource entity by ids.
func (m *NotifyFlowMutation) AddNotifyFlowSourceIDs(ids ...int) {
	if m.notify_flow_source == nil {
		m.notify_flow_source = make(map[int]struct{})
	}
	for i := range ids {
		m.notify_flow_source[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlowSource clears the "notify_flow_source" edge to the NotifyFlowSource entity.
func (m *NotifyFlowMutation) ClearNotifyFlowSource() {
	m.clearednotify_flow_source = true
}

// NotifyFlowSourceCleared reports if the "notify_flow_source" edge to the NotifyFlowSource entity was cleared.
func (m *NotifyFlowMutation) NotifyFlowSourceCleared() bool {
	return m.clearednotify_flow_source
}

// RemoveNotifyFlowSourceIDs removes the "notify_flow_source" edge to the NotifyFlowSource entity by IDs.
func (m *NotifyFlowMutation) RemoveNotifyFlowSourceIDs(ids ...int) {
	if m.removednotify_flow_source == nil {
		m.removednotify_flow_source = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notify_flow_source, ids[i])
		m.removednotify_flow_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlowSource returns the removed IDs of the "notify_flow_source" edge to the NotifyFlowSource entity.
func (m *NotifyFlowMutation) RemovedNotifyFlowSourceIDs() (ids []int) {
	for id := range m.removednotify_flow_source {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowSourceIDs returns the "notify_flow_source" edge IDs in the mutation.
func (m *NotifyFlowMutation) NotifyFlowSourceIDs() (ids []int) {
	for id := range m.notify_flow_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlowSource resets all changes to the "notify_flow_source" edge.
func (m *NotifyFlowMutation) ResetNotifyFlowSource() {
	m.notify_flow_source = nil
	m.clearednotify_flow_source = false
	m.removednotify_flow_source = nil
}

// Where appends a list predicates to the NotifyFlowMutation builder.
func (m *NotifyFlowMutation) Where(ps ...predicate.NotifyFlow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyFlowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyFlowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyFlow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyFlowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyFlowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyFlow).
func (m *NotifyFlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyFlowMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, notifyflow.FieldName)
	}
	if m.description != nil {
		fields = append(fields, notifyflow.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, notifyflow.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, notifyflow.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifyflow.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyFlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifyflow.FieldName:
		return m.Name()
	case notifyflow.FieldDescription:
		return m.Description()
	case notifyflow.FieldStatus:
		return m.Status()
	case notifyflow.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifyflow.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyFlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifyflow.FieldName:
		return m.OldName(ctx)
	case notifyflow.FieldDescription:
		return m.OldDescription(ctx)
	case notifyflow.FieldStatus:
		return m.OldStatus(ctx)
	case notifyflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifyflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyFlow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifyflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notifyflow.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notifyflow.FieldStatus:
		v, ok := value.(notifyflow.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case notifyflow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifyflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyFlow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyFlowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyFlowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifyFlow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyFlowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyFlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyFlowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotifyFlow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyFlowMutation) ResetField(name string) error {
	switch name {
	case notifyflow.FieldName:
		m.ResetName()
		return nil
	case notifyflow.FieldDescription:
		m.ResetDescription()
		return nil
	case notifyflow.FieldStatus:
		m.ResetStatus()
		return nil
	case notifyflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifyflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyFlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, notifyflow.EdgeOwner)
	}
	if m.notify_target != nil {
		edges = append(edges, notifyflow.EdgeNotifyTarget)
	}
	if m.notify_source != nil {
		edges = append(edges, notifyflow.EdgeNotifySource)
	}
	if m.notify_flow_target != nil {
		edges = append(edges, notifyflow.EdgeNotifyFlowTarget)
	}
	if m.notify_flow_source != nil {
		edges = append(edges, notifyflow.EdgeNotifyFlowSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyFlowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifyflow.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case notifyflow.EdgeNotifyTarget:
		ids := make([]ent.Value, 0, len(m.notify_target))
		for id := range m.notify_target {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.notify_source))
		for id := range m.notify_source {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifyFlowTarget:
		ids := make([]ent.Value, 0, len(m.notify_flow_target))
		for id := range m.notify_flow_target {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifyFlowSource:
		ids := make([]ent.Value, 0, len(m.notify_flow_source))
		for id := range m.notify_flow_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyFlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removednotify_target != nil {
		edges = append(edges, notifyflow.EdgeNotifyTarget)
	}
	if m.removednotify_source != nil {
		edges = append(edges, notifyflow.EdgeNotifySource)
	}
	if m.removednotify_flow_target != nil {
		edges = append(edges, notifyflow.EdgeNotifyFlowTarget)
	}
	if m.removednotify_flow_source != nil {
		edges = append(edges, notifyflow.EdgeNotifyFlowSource)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyFlowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notifyflow.EdgeNotifyTarget:
		ids := make([]ent.Value, 0, len(m.removednotify_target))
		for id := range m.removednotify_target {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.removednotify_source))
		for id := range m.removednotify_source {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifyFlowTarget:
		ids := make([]ent.Value, 0, len(m.removednotify_flow_target))
		for id := range m.removednotify_flow_target {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifyFlowSource:
		ids := make([]ent.Value, 0, len(m.removednotify_flow_source))
		for id := range m.removednotify_flow_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyFlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, notifyflow.EdgeOwner)
	}
	if m.clearednotify_target {
		edges = append(edges, notifyflow.EdgeNotifyTarget)
	}
	if m.clearednotify_source {
		edges = append(edges, notifyflow.EdgeNotifySource)
	}
	if m.clearednotify_flow_target {
		edges = append(edges, notifyflow.EdgeNotifyFlowTarget)
	}
	if m.clearednotify_flow_source {
		edges = append(edges, notifyflow.EdgeNotifyFlowSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyFlowMutation) EdgeCleared(name string) bool {
	switch name {
	case notifyflow.EdgeOwner:
		return m.clearedowner
	case notifyflow.EdgeNotifyTarget:
		return m.clearednotify_target
	case notifyflow.EdgeNotifySource:
		return m.clearednotify_source
	case notifyflow.EdgeNotifyFlowTarget:
		return m.clearednotify_flow_target
	case notifyflow.EdgeNotifyFlowSource:
		return m.clearednotify_flow_source
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyFlowMutation) ClearEdge(name string) error {
	switch name {
	case notifyflow.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyFlowMutation) ResetEdge(name string) error {
	switch name {
	case notifyflow.EdgeOwner:
		m.ResetOwner()
		return nil
	case notifyflow.EdgeNotifyTarget:
		m.ResetNotifyTarget()
		return nil
	case notifyflow.EdgeNotifySource:
		m.ResetNotifySource()
		return nil
	case notifyflow.EdgeNotifyFlowTarget:
		m.ResetNotifyFlowTarget()
		return nil
	case notifyflow.EdgeNotifyFlowSource:
		m.ResetNotifyFlowSource()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlow edge %s", name)
}

// NotifyFlowSourceMutation represents an operation that mutates the NotifyFlowSource nodes in the graph.
type NotifyFlowSourceMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	filter_include_keywords       *[]string
	appendfilter_include_keywords []string
	filter_exclude_keywords       *[]string
	appendfilter_exclude_keywords []string
	updated_at                    *time.Time
	created_at                    *time.Time
	clearedFields                 map[string]struct{}
	notify_flow                   *model.InternalID
	clearednotify_flow            bool
	notify_source                 *model.InternalID
	clearednotify_source          bool
	done                          bool
	oldValue                      func(context.Context) (*NotifyFlowSource, error)
	predicates                    []predicate.NotifyFlowSource
}

var _ ent.Mutation = (*NotifyFlowSourceMutation)(nil)

// notifyflowsourceOption allows management of the mutation configuration using functional options.
type notifyflowsourceOption func(*NotifyFlowSourceMutation)

// newNotifyFlowSourceMutation creates new mutation for the NotifyFlowSource entity.
func newNotifyFlowSourceMutation(c config, op Op, opts ...notifyflowsourceOption) *NotifyFlowSourceMutation {
	m := &NotifyFlowSourceMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyFlowSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyFlowSourceID sets the ID field of the mutation.
func withNotifyFlowSourceID(id int) notifyflowsourceOption {
	return func(m *NotifyFlowSourceMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyFlowSource
		)
		m.oldValue = func(ctx context.Context) (*NotifyFlowSource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyFlowSource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyFlowSource sets the old NotifyFlowSource of the mutation.
func withNotifyFlowSource(node *NotifyFlowSource) notifyflowsourceOption {
	return func(m *NotifyFlowSourceMutation) {
		m.oldValue = func(context.Context) (*NotifyFlowSource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyFlowSourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyFlowSourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyFlowSourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyFlowSourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyFlowSource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNotifyFlowID sets the "notify_flow_id" field.
func (m *NotifyFlowSourceMutation) SetNotifyFlowID(mi model.InternalID) {
	m.notify_flow = &mi
}

// NotifyFlowID returns the value of the "notify_flow_id" field in the mutation.
func (m *NotifyFlowSourceMutation) NotifyFlowID() (r model.InternalID, exists bool) {
	v := m.notify_flow
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyFlowID returns the old "notify_flow_id" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldNotifyFlowID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyFlowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyFlowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyFlowID: %w", err)
	}
	return oldValue.NotifyFlowID, nil
}

// ResetNotifyFlowID resets all changes to the "notify_flow_id" field.
func (m *NotifyFlowSourceMutation) ResetNotifyFlowID() {
	m.notify_flow = nil
}

// SetNotifySourceID sets the "notify_source_id" field.
func (m *NotifyFlowSourceMutation) SetNotifySourceID(mi model.InternalID) {
	m.notify_source = &mi
}

// NotifySourceID returns the value of the "notify_source_id" field in the mutation.
func (m *NotifyFlowSourceMutation) NotifySourceID() (r model.InternalID, exists bool) {
	v := m.notify_source
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifySourceID returns the old "notify_source_id" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldNotifySourceID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifySourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifySourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifySourceID: %w", err)
	}
	return oldValue.NotifySourceID, nil
}

// ResetNotifySourceID resets all changes to the "notify_source_id" field.
func (m *NotifyFlowSourceMutation) ResetNotifySourceID() {
	m.notify_source = nil
}

// SetFilterIncludeKeywords sets the "filter_include_keywords" field.
func (m *NotifyFlowSourceMutation) SetFilterIncludeKeywords(s []string) {
	m.filter_include_keywords = &s
	m.appendfilter_include_keywords = nil
}

// FilterIncludeKeywords returns the value of the "filter_include_keywords" field in the mutation.
func (m *NotifyFlowSourceMutation) FilterIncludeKeywords() (r []string, exists bool) {
	v := m.filter_include_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterIncludeKeywords returns the old "filter_include_keywords" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldFilterIncludeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterIncludeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterIncludeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterIncludeKeywords: %w", err)
	}
	return oldValue.FilterIncludeKeywords, nil
}

// AppendFilterIncludeKeywords adds s to the "filter_include_keywords" field.
func (m *NotifyFlowSourceMutation) AppendFilterIncludeKeywords(s []string) {
	m.appendfilter_include_keywords = append(m.appendfilter_include_keywords, s...)
}

// AppendedFilterIncludeKeywords returns the list of values that were appended to the "filter_include_keywords" field in this mutation.
func (m *NotifyFlowSourceMutation) AppendedFilterIncludeKeywords() ([]string, bool) {
	if len(m.appendfilter_include_keywords) == 0 {
		return nil, false
	}
	return m.appendfilter_include_keywords, true
}

// ResetFilterIncludeKeywords resets all changes to the "filter_include_keywords" field.
func (m *NotifyFlowSourceMutation) ResetFilterIncludeKeywords() {
	m.filter_include_keywords = nil
	m.appendfilter_include_keywords = nil
}

// SetFilterExcludeKeywords sets the "filter_exclude_keywords" field.
func (m *NotifyFlowSourceMutation) SetFilterExcludeKeywords(s []string) {
	m.filter_exclude_keywords = &s
	m.appendfilter_exclude_keywords = nil
}

// FilterExcludeKeywords returns the value of the "filter_exclude_keywords" field in the mutation.
func (m *NotifyFlowSourceMutation) FilterExcludeKeywords() (r []string, exists bool) {
	v := m.filter_exclude_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterExcludeKeywords returns the old "filter_exclude_keywords" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldFilterExcludeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterExcludeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterExcludeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterExcludeKeywords: %w", err)
	}
	return oldValue.FilterExcludeKeywords, nil
}

// AppendFilterExcludeKeywords adds s to the "filter_exclude_keywords" field.
func (m *NotifyFlowSourceMutation) AppendFilterExcludeKeywords(s []string) {
	m.appendfilter_exclude_keywords = append(m.appendfilter_exclude_keywords, s...)
}

// AppendedFilterExcludeKeywords returns the list of values that were appended to the "filter_exclude_keywords" field in this mutation.
func (m *NotifyFlowSourceMutation) AppendedFilterExcludeKeywords() ([]string, bool) {
	if len(m.appendfilter_exclude_keywords) == 0 {
		return nil, false
	}
	return m.appendfilter_exclude_keywords, true
}

// ResetFilterExcludeKeywords resets all changes to the "filter_exclude_keywords" field.
func (m *NotifyFlowSourceMutation) ResetFilterExcludeKeywords() {
	m.filter_exclude_keywords = nil
	m.appendfilter_exclude_keywords = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyFlowSourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyFlowSourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyFlowSourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyFlowSourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyFlowSourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyFlowSourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifyFlowSourceMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
	m.clearedFields[notifyflowsource.FieldNotifyFlowID] = struct{}{}
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *NotifyFlowSourceMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotifyFlowID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowSourceMutation) NotifyFlowIDs() (ids []model.InternalID) {
	if id := m.notify_flow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *NotifyFlowSourceMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
}

// ClearNotifySource clears the "notify_source" edge to the NotifySource entity.
func (m *NotifyFlowSourceMutation) ClearNotifySource() {
	m.clearednotify_source = true
	m.clearedFields[notifyflowsource.FieldNotifySourceID] = struct{}{}
}

// NotifySourceCleared reports if the "notify_source" edge to the NotifySource entity was cleared.
func (m *NotifyFlowSourceMutation) NotifySourceCleared() bool {
	return m.clearednotify_source
}

// NotifySourceIDs returns the "notify_source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotifySourceID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowSourceMutation) NotifySourceIDs() (ids []model.InternalID) {
	if id := m.notify_source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotifySource resets all changes to the "notify_source" edge.
func (m *NotifyFlowSourceMutation) ResetNotifySource() {
	m.notify_source = nil
	m.clearednotify_source = false
}

// Where appends a list predicates to the NotifyFlowSourceMutation builder.
func (m *NotifyFlowSourceMutation) Where(ps ...predicate.NotifyFlowSource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyFlowSourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyFlowSourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyFlowSource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyFlowSourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyFlowSourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyFlowSource).
func (m *NotifyFlowSourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyFlowSourceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.notify_flow != nil {
		fields = append(fields, notifyflowsource.FieldNotifyFlowID)
	}
	if m.notify_source != nil {
		fields = append(fields, notifyflowsource.FieldNotifySourceID)
	}
	if m.filter_include_keywords != nil {
		fields = append(fields, notifyflowsource.FieldFilterIncludeKeywords)
	}
	if m.filter_exclude_keywords != nil {
		fields = append(fields, notifyflowsource.FieldFilterExcludeKeywords)
	}
	if m.updated_at != nil {
		fields = append(fields, notifyflowsource.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifyflowsource.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyFlowSourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifyflowsource.FieldNotifyFlowID:
		return m.NotifyFlowID()
	case notifyflowsource.FieldNotifySourceID:
		return m.NotifySourceID()
	case notifyflowsource.FieldFilterIncludeKeywords:
		return m.FilterIncludeKeywords()
	case notifyflowsource.FieldFilterExcludeKeywords:
		return m.FilterExcludeKeywords()
	case notifyflowsource.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifyflowsource.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyFlowSourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifyflowsource.FieldNotifyFlowID:
		return m.OldNotifyFlowID(ctx)
	case notifyflowsource.FieldNotifySourceID:
		return m.OldNotifySourceID(ctx)
	case notifyflowsource.FieldFilterIncludeKeywords:
		return m.OldFilterIncludeKeywords(ctx)
	case notifyflowsource.FieldFilterExcludeKeywords:
		return m.OldFilterExcludeKeywords(ctx)
	case notifyflowsource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifyflowsource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyFlowSource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowSourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifyflowsource.FieldNotifyFlowID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyFlowID(v)
		return nil
	case notifyflowsource.FieldNotifySourceID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifySourceID(v)
		return nil
	case notifyflowsource.FieldFilterIncludeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterIncludeKeywords(v)
		return nil
	case notifyflowsource.FieldFilterExcludeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterExcludeKeywords(v)
		return nil
	case notifyflowsource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifyflowsource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowSource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyFlowSourceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyFlowSourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowSourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifyFlowSource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyFlowSourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyFlowSourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyFlowSourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotifyFlowSource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyFlowSourceMutation) ResetField(name string) error {
	switch name {
	case notifyflowsource.FieldNotifyFlowID:
		m.ResetNotifyFlowID()
		return nil
	case notifyflowsource.FieldNotifySourceID:
		m.ResetNotifySourceID()
		return nil
	case notifyflowsource.FieldFilterIncludeKeywords:
		m.ResetFilterIncludeKeywords()
		return nil
	case notifyflowsource.FieldFilterExcludeKeywords:
		m.ResetFilterExcludeKeywords()
		return nil
	case notifyflowsource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifyflowsource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowSource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyFlowSourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.notify_flow != nil {
		edges = append(edges, notifyflowsource.EdgeNotifyFlow)
	}
	if m.notify_source != nil {
		edges = append(edges, notifyflowsource.EdgeNotifySource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyFlowSourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifyflowsource.EdgeNotifyFlow:
		if id := m.notify_flow; id != nil {
			return []ent.Value{*id}
		}
	case notifyflowsource.EdgeNotifySource:
		if id := m.notify_source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyFlowSourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyFlowSourceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyFlowSourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednotify_flow {
		edges = append(edges, notifyflowsource.EdgeNotifyFlow)
	}
	if m.clearednotify_source {
		edges = append(edges, notifyflowsource.EdgeNotifySource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyFlowSourceMutation) EdgeCleared(name string) bool {
	switch name {
	case notifyflowsource.EdgeNotifyFlow:
		return m.clearednotify_flow
	case notifyflowsource.EdgeNotifySource:
		return m.clearednotify_source
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyFlowSourceMutation) ClearEdge(name string) error {
	switch name {
	case notifyflowsource.EdgeNotifyFlow:
		m.ClearNotifyFlow()
		return nil
	case notifyflowsource.EdgeNotifySource:
		m.ClearNotifySource()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowSource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyFlowSourceMutation) ResetEdge(name string) error {
	switch name {
	case notifyflowsource.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case notifyflowsource.EdgeNotifySource:
		m.ResetNotifySource()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowSource edge %s", name)
}

// NotifyFlowTargetMutation represents an operation that mutates the NotifyFlowTarget nodes in the graph.
type NotifyFlowTargetMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	channel_id                    *string
	filter_include_keywords       *[]string
	appendfilter_include_keywords []string
	filter_exclude_keywords       *[]string
	appendfilter_exclude_keywords []string
	updated_at                    *time.Time
	created_at                    *time.Time
	clearedFields                 map[string]struct{}
	notify_flow                   *model.InternalID
	clearednotify_flow            bool
	notify_target                 *model.InternalID
	clearednotify_target          bool
	done                          bool
	oldValue                      func(context.Context) (*NotifyFlowTarget, error)
	predicates                    []predicate.NotifyFlowTarget
}

var _ ent.Mutation = (*NotifyFlowTargetMutation)(nil)

// notifyflowtargetOption allows management of the mutation configuration using functional options.
type notifyflowtargetOption func(*NotifyFlowTargetMutation)

// newNotifyFlowTargetMutation creates new mutation for the NotifyFlowTarget entity.
func newNotifyFlowTargetMutation(c config, op Op, opts ...notifyflowtargetOption) *NotifyFlowTargetMutation {
	m := &NotifyFlowTargetMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyFlowTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyFlowTargetID sets the ID field of the mutation.
func withNotifyFlowTargetID(id int) notifyflowtargetOption {
	return func(m *NotifyFlowTargetMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyFlowTarget
		)
		m.oldValue = func(ctx context.Context) (*NotifyFlowTarget, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyFlowTarget.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyFlowTarget sets the old NotifyFlowTarget of the mutation.
func withNotifyFlowTarget(node *NotifyFlowTarget) notifyflowtargetOption {
	return func(m *NotifyFlowTargetMutation) {
		m.oldValue = func(context.Context) (*NotifyFlowTarget, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyFlowTargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyFlowTargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyFlowTargetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyFlowTargetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyFlowTarget.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNotifyFlowID sets the "notify_flow_id" field.
func (m *NotifyFlowTargetMutation) SetNotifyFlowID(mi model.InternalID) {
	m.notify_flow = &mi
}

// NotifyFlowID returns the value of the "notify_flow_id" field in the mutation.
func (m *NotifyFlowTargetMutation) NotifyFlowID() (r model.InternalID, exists bool) {
	v := m.notify_flow
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyFlowID returns the old "notify_flow_id" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldNotifyFlowID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyFlowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyFlowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyFlowID: %w", err)
	}
	return oldValue.NotifyFlowID, nil
}

// ResetNotifyFlowID resets all changes to the "notify_flow_id" field.
func (m *NotifyFlowTargetMutation) ResetNotifyFlowID() {
	m.notify_flow = nil
}

// SetNotifyTargetID sets the "notify_target_id" field.
func (m *NotifyFlowTargetMutation) SetNotifyTargetID(mi model.InternalID) {
	m.notify_target = &mi
}

// NotifyTargetID returns the value of the "notify_target_id" field in the mutation.
func (m *NotifyFlowTargetMutation) NotifyTargetID() (r model.InternalID, exists bool) {
	v := m.notify_target
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyTargetID returns the old "notify_target_id" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldNotifyTargetID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyTargetID: %w", err)
	}
	return oldValue.NotifyTargetID, nil
}

// ResetNotifyTargetID resets all changes to the "notify_target_id" field.
func (m *NotifyFlowTargetMutation) ResetNotifyTargetID() {
	m.notify_target = nil
}

// SetChannelID sets the "channel_id" field.
func (m *NotifyFlowTargetMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *NotifyFlowTargetMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *NotifyFlowTargetMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetFilterIncludeKeywords sets the "filter_include_keywords" field.
func (m *NotifyFlowTargetMutation) SetFilterIncludeKeywords(s []string) {
	m.filter_include_keywords = &s
	m.appendfilter_include_keywords = nil
}

// FilterIncludeKeywords returns the value of the "filter_include_keywords" field in the mutation.
func (m *NotifyFlowTargetMutation) FilterIncludeKeywords() (r []string, exists bool) {
	v := m.filter_include_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterIncludeKeywords returns the old "filter_include_keywords" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldFilterIncludeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterIncludeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterIncludeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterIncludeKeywords: %w", err)
	}
	return oldValue.FilterIncludeKeywords, nil
}

// AppendFilterIncludeKeywords adds s to the "filter_include_keywords" field.
func (m *NotifyFlowTargetMutation) AppendFilterIncludeKeywords(s []string) {
	m.appendfilter_include_keywords = append(m.appendfilter_include_keywords, s...)
}

// AppendedFilterIncludeKeywords returns the list of values that were appended to the "filter_include_keywords" field in this mutation.
func (m *NotifyFlowTargetMutation) AppendedFilterIncludeKeywords() ([]string, bool) {
	if len(m.appendfilter_include_keywords) == 0 {
		return nil, false
	}
	return m.appendfilter_include_keywords, true
}

// ResetFilterIncludeKeywords resets all changes to the "filter_include_keywords" field.
func (m *NotifyFlowTargetMutation) ResetFilterIncludeKeywords() {
	m.filter_include_keywords = nil
	m.appendfilter_include_keywords = nil
}

// SetFilterExcludeKeywords sets the "filter_exclude_keywords" field.
func (m *NotifyFlowTargetMutation) SetFilterExcludeKeywords(s []string) {
	m.filter_exclude_keywords = &s
	m.appendfilter_exclude_keywords = nil
}

// FilterExcludeKeywords returns the value of the "filter_exclude_keywords" field in the mutation.
func (m *NotifyFlowTargetMutation) FilterExcludeKeywords() (r []string, exists bool) {
	v := m.filter_exclude_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterExcludeKeywords returns the old "filter_exclude_keywords" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldFilterExcludeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterExcludeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterExcludeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterExcludeKeywords: %w", err)
	}
	return oldValue.FilterExcludeKeywords, nil
}

// AppendFilterExcludeKeywords adds s to the "filter_exclude_keywords" field.
func (m *NotifyFlowTargetMutation) AppendFilterExcludeKeywords(s []string) {
	m.appendfilter_exclude_keywords = append(m.appendfilter_exclude_keywords, s...)
}

// AppendedFilterExcludeKeywords returns the list of values that were appended to the "filter_exclude_keywords" field in this mutation.
func (m *NotifyFlowTargetMutation) AppendedFilterExcludeKeywords() ([]string, bool) {
	if len(m.appendfilter_exclude_keywords) == 0 {
		return nil, false
	}
	return m.appendfilter_exclude_keywords, true
}

// ResetFilterExcludeKeywords resets all changes to the "filter_exclude_keywords" field.
func (m *NotifyFlowTargetMutation) ResetFilterExcludeKeywords() {
	m.filter_exclude_keywords = nil
	m.appendfilter_exclude_keywords = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyFlowTargetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyFlowTargetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyFlowTargetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyFlowTargetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyFlowTargetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyFlowTargetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifyFlowTargetMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
	m.clearedFields[notifyflowtarget.FieldNotifyFlowID] = struct{}{}
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *NotifyFlowTargetMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotifyFlowID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowTargetMutation) NotifyFlowIDs() (ids []model.InternalID) {
	if id := m.notify_flow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *NotifyFlowTargetMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
}

// ClearNotifyTarget clears the "notify_target" edge to the NotifyTarget entity.
func (m *NotifyFlowTargetMutation) ClearNotifyTarget() {
	m.clearednotify_target = true
	m.clearedFields[notifyflowtarget.FieldNotifyTargetID] = struct{}{}
}

// NotifyTargetCleared reports if the "notify_target" edge to the NotifyTarget entity was cleared.
func (m *NotifyFlowTargetMutation) NotifyTargetCleared() bool {
	return m.clearednotify_target
}

// NotifyTargetIDs returns the "notify_target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotifyTargetID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowTargetMutation) NotifyTargetIDs() (ids []model.InternalID) {
	if id := m.notify_target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotifyTarget resets all changes to the "notify_target" edge.
func (m *NotifyFlowTargetMutation) ResetNotifyTarget() {
	m.notify_target = nil
	m.clearednotify_target = false
}

// Where appends a list predicates to the NotifyFlowTargetMutation builder.
func (m *NotifyFlowTargetMutation) Where(ps ...predicate.NotifyFlowTarget) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyFlowTargetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyFlowTargetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyFlowTarget, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyFlowTargetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyFlowTargetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyFlowTarget).
func (m *NotifyFlowTargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyFlowTargetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.notify_flow != nil {
		fields = append(fields, notifyflowtarget.FieldNotifyFlowID)
	}
	if m.notify_target != nil {
		fields = append(fields, notifyflowtarget.FieldNotifyTargetID)
	}
	if m.channel_id != nil {
		fields = append(fields, notifyflowtarget.FieldChannelID)
	}
	if m.filter_include_keywords != nil {
		fields = append(fields, notifyflowtarget.FieldFilterIncludeKeywords)
	}
	if m.filter_exclude_keywords != nil {
		fields = append(fields, notifyflowtarget.FieldFilterExcludeKeywords)
	}
	if m.updated_at != nil {
		fields = append(fields, notifyflowtarget.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifyflowtarget.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyFlowTargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifyflowtarget.FieldNotifyFlowID:
		return m.NotifyFlowID()
	case notifyflowtarget.FieldNotifyTargetID:
		return m.NotifyTargetID()
	case notifyflowtarget.FieldChannelID:
		return m.ChannelID()
	case notifyflowtarget.FieldFilterIncludeKeywords:
		return m.FilterIncludeKeywords()
	case notifyflowtarget.FieldFilterExcludeKeywords:
		return m.FilterExcludeKeywords()
	case notifyflowtarget.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifyflowtarget.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyFlowTargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifyflowtarget.FieldNotifyFlowID:
		return m.OldNotifyFlowID(ctx)
	case notifyflowtarget.FieldNotifyTargetID:
		return m.OldNotifyTargetID(ctx)
	case notifyflowtarget.FieldChannelID:
		return m.OldChannelID(ctx)
	case notifyflowtarget.FieldFilterIncludeKeywords:
		return m.OldFilterIncludeKeywords(ctx)
	case notifyflowtarget.FieldFilterExcludeKeywords:
		return m.OldFilterExcludeKeywords(ctx)
	case notifyflowtarget.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifyflowtarget.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyFlowTarget field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowTargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifyflowtarget.FieldNotifyFlowID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyFlowID(v)
		return nil
	case notifyflowtarget.FieldNotifyTargetID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyTargetID(v)
		return nil
	case notifyflowtarget.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case notifyflowtarget.FieldFilterIncludeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterIncludeKeywords(v)
		return nil
	case notifyflowtarget.FieldFilterExcludeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterExcludeKeywords(v)
		return nil
	case notifyflowtarget.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifyflowtarget.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowTarget field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyFlowTargetMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyFlowTargetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowTargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifyFlowTarget numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyFlowTargetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyFlowTargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyFlowTargetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotifyFlowTarget nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyFlowTargetMutation) ResetField(name string) error {
	switch name {
	case notifyflowtarget.FieldNotifyFlowID:
		m.ResetNotifyFlowID()
		return nil
	case notifyflowtarget.FieldNotifyTargetID:
		m.ResetNotifyTargetID()
		return nil
	case notifyflowtarget.FieldChannelID:
		m.ResetChannelID()
		return nil
	case notifyflowtarget.FieldFilterIncludeKeywords:
		m.ResetFilterIncludeKeywords()
		return nil
	case notifyflowtarget.FieldFilterExcludeKeywords:
		m.ResetFilterExcludeKeywords()
		return nil
	case notifyflowtarget.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifyflowtarget.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowTarget field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyFlowTargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.notify_flow != nil {
		edges = append(edges, notifyflowtarget.EdgeNotifyFlow)
	}
	if m.notify_target != nil {
		edges = append(edges, notifyflowtarget.EdgeNotifyTarget)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyFlowTargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifyflowtarget.EdgeNotifyFlow:
		if id := m.notify_flow; id != nil {
			return []ent.Value{*id}
		}
	case notifyflowtarget.EdgeNotifyTarget:
		if id := m.notify_target; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyFlowTargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyFlowTargetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyFlowTargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednotify_flow {
		edges = append(edges, notifyflowtarget.EdgeNotifyFlow)
	}
	if m.clearednotify_target {
		edges = append(edges, notifyflowtarget.EdgeNotifyTarget)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyFlowTargetMutation) EdgeCleared(name string) bool {
	switch name {
	case notifyflowtarget.EdgeNotifyFlow:
		return m.clearednotify_flow
	case notifyflowtarget.EdgeNotifyTarget:
		return m.clearednotify_target
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyFlowTargetMutation) ClearEdge(name string) error {
	switch name {
	case notifyflowtarget.EdgeNotifyFlow:
		m.ClearNotifyFlow()
		return nil
	case notifyflowtarget.EdgeNotifyTarget:
		m.ClearNotifyTarget()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowTarget unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyFlowTargetMutation) ResetEdge(name string) error {
	switch name {
	case notifyflowtarget.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case notifyflowtarget.EdgeNotifyTarget:
		m.ResetNotifyTarget()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowTarget edge %s", name)
}

// NotifySourceMutation represents an operation that mutates the NotifySource nodes in the graph.
type NotifySourceMutation struct {
	config
	op                          Op
	typ                         string
	id                          *model.InternalID
	updated_at                  *time.Time
	created_at                  *time.Time
	clearedFields               map[string]struct{}
	owner                       *model.InternalID
	clearedowner                bool
	notify_flow                 map[model.InternalID]struct{}
	removednotify_flow          map[model.InternalID]struct{}
	clearednotify_flow          bool
	feed_config                 *model.InternalID
	clearedfeed_config          bool
	feed_item_collection        *model.InternalID
	clearedfeed_item_collection bool
	notify_flow_source          map[int]struct{}
	removednotify_flow_source   map[int]struct{}
	clearednotify_flow_source   bool
	done                        bool
	oldValue                    func(context.Context) (*NotifySource, error)
	predicates                  []predicate.NotifySource
}

var _ ent.Mutation = (*NotifySourceMutation)(nil)

// notifysourceOption allows management of the mutation configuration using functional options.
type notifysourceOption func(*NotifySourceMutation)

// newNotifySourceMutation creates new mutation for the NotifySource entity.
func newNotifySourceMutation(c config, op Op, opts ...notifysourceOption) *NotifySourceMutation {
	m := &NotifySourceMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifySource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifySourceID sets the ID field of the mutation.
func withNotifySourceID(id model.InternalID) notifysourceOption {
	return func(m *NotifySourceMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifySource
		)
		m.oldValue = func(ctx context.Context) (*NotifySource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifySource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifySource sets the old NotifySource of the mutation.
func withNotifySource(node *NotifySource) notifysourceOption {
	return func(m *NotifySourceMutation) {
		m.oldValue = func(context.Context) (*NotifySource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifySourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifySourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotifySource entities.
func (m *NotifySourceMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifySourceMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifySourceMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifySource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeedConfigID sets the "feed_config_id" field.
func (m *NotifySourceMutation) SetFeedConfigID(mi model.InternalID) {
	m.feed_config = &mi
}

// FeedConfigID returns the value of the "feed_config_id" field in the mutation.
func (m *NotifySourceMutation) FeedConfigID() (r model.InternalID, exists bool) {
	v := m.feed_config
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedConfigID returns the old "feed_config_id" field's value of the NotifySource entity.
// If the NotifySource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifySourceMutation) OldFeedConfigID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedConfigID: %w", err)
	}
	return oldValue.FeedConfigID, nil
}

// ClearFeedConfigID clears the value of the "feed_config_id" field.
func (m *NotifySourceMutation) ClearFeedConfigID() {
	m.feed_config = nil
	m.clearedFields[notifysource.FieldFeedConfigID] = struct{}{}
}

// FeedConfigIDCleared returns if the "feed_config_id" field was cleared in this mutation.
func (m *NotifySourceMutation) FeedConfigIDCleared() bool {
	_, ok := m.clearedFields[notifysource.FieldFeedConfigID]
	return ok
}

// ResetFeedConfigID resets all changes to the "feed_config_id" field.
func (m *NotifySourceMutation) ResetFeedConfigID() {
	m.feed_config = nil
	delete(m.clearedFields, notifysource.FieldFeedConfigID)
}

// SetFeedItemCollectionID sets the "feed_item_collection_id" field.
func (m *NotifySourceMutation) SetFeedItemCollectionID(mi model.InternalID) {
	m.feed_item_collection = &mi
}

// FeedItemCollectionID returns the value of the "feed_item_collection_id" field in the mutation.
func (m *NotifySourceMutation) FeedItemCollectionID() (r model.InternalID, exists bool) {
	v := m.feed_item_collection
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedItemCollectionID returns the old "feed_item_collection_id" field's value of the NotifySource entity.
// If the NotifySource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifySourceMutation) OldFeedItemCollectionID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedItemCollectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedItemCollectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedItemCollectionID: %w", err)
	}
	return oldValue.FeedItemCollectionID, nil
}

// ClearFeedItemCollectionID clears the value of the "feed_item_collection_id" field.
func (m *NotifySourceMutation) ClearFeedItemCollectionID() {
	m.feed_item_collection = nil
	m.clearedFields[notifysource.FieldFeedItemCollectionID] = struct{}{}
}

// FeedItemCollectionIDCleared returns if the "feed_item_collection_id" field was cleared in this mutation.
func (m *NotifySourceMutation) FeedItemCollectionIDCleared() bool {
	_, ok := m.clearedFields[notifysource.FieldFeedItemCollectionID]
	return ok
}

// ResetFeedItemCollectionID resets all changes to the "feed_item_collection_id" field.
func (m *NotifySourceMutation) ResetFeedItemCollectionID() {
	m.feed_item_collection = nil
	delete(m.clearedFields, notifysource.FieldFeedItemCollectionID)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifySourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifySourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifySource entity.
// If the NotifySource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifySourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifySourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifySourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifySourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifySource entity.
// If the NotifySource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifySourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifySourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *NotifySourceMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *NotifySourceMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *NotifySourceMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NotifySourceMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NotifySourceMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NotifySourceMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddNotifyFlowIDs adds the "notify_flow" edge to the NotifyFlow entity by ids.
func (m *NotifySourceMutation) AddNotifyFlowIDs(ids ...model.InternalID) {
	if m.notify_flow == nil {
		m.notify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_flow[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifySourceMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *NotifySourceMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// RemoveNotifyFlowIDs removes the "notify_flow" edge to the NotifyFlow entity by IDs.
func (m *NotifySourceMutation) RemoveNotifyFlowIDs(ids ...model.InternalID) {
	if m.removednotify_flow == nil {
		m.removednotify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_flow, ids[i])
		m.removednotify_flow[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlow returns the removed IDs of the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifySourceMutation) RemovedNotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.removednotify_flow {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
func (m *NotifySourceMutation) NotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.notify_flow {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *NotifySourceMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
	m.removednotify_flow = nil
}

// ClearFeedConfig clears the "feed_config" edge to the FeedConfig entity.
func (m *NotifySourceMutation) ClearFeedConfig() {
	m.clearedfeed_config = true
	m.clearedFields[notifysource.FieldFeedConfigID] = struct{}{}
}

// FeedConfigCleared reports if the "feed_config" edge to the FeedConfig entity was cleared.
func (m *NotifySourceMutation) FeedConfigCleared() bool {
	return m.FeedConfigIDCleared() || m.clearedfeed_config
}

// FeedConfigIDs returns the "feed_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedConfigID instead. It exists only for internal usage by the builders.
func (m *NotifySourceMutation) FeedConfigIDs() (ids []model.InternalID) {
	if id := m.feed_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeedConfig resets all changes to the "feed_config" edge.
func (m *NotifySourceMutation) ResetFeedConfig() {
	m.feed_config = nil
	m.clearedfeed_config = false
}

// ClearFeedItemCollection clears the "feed_item_collection" edge to the FeedItemCollection entity.
func (m *NotifySourceMutation) ClearFeedItemCollection() {
	m.clearedfeed_item_collection = true
	m.clearedFields[notifysource.FieldFeedItemCollectionID] = struct{}{}
}

// FeedItemCollectionCleared reports if the "feed_item_collection" edge to the FeedItemCollection entity was cleared.
func (m *NotifySourceMutation) FeedItemCollectionCleared() bool {
	return m.FeedItemCollectionIDCleared() || m.clearedfeed_item_collection
}

// FeedItemCollectionIDs returns the "feed_item_collection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedItemCollectionID instead. It exists only for internal usage by the builders.
func (m *NotifySourceMutation) FeedItemCollectionIDs() (ids []model.InternalID) {
	if id := m.feed_item_collection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeedItemCollection resets all changes to the "feed_item_collection" edge.
func (m *NotifySourceMutation) ResetFeedItemCollection() {
	m.feed_item_collection = nil
	m.clearedfeed_item_collection = false
}

// AddNotifyFlowSourceIDs adds the "notify_flow_source" edge to the NotifyFlowSource entity by ids.
func (m *NotifySourceMutation) AddNotifyFlowSourceIDs(ids ...int) {
	if m.notify_flow_source == nil {
		m.notify_flow_source = make(map[int]struct{})
	}
	for i := range ids {
		m.notify_flow_source[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlowSource clears the "notify_flow_source" edge to the NotifyFlowSource entity.
func (m *NotifySourceMutation) ClearNotifyFlowSource() {
	m.clearednotify_flow_source = true
}

// NotifyFlowSourceCleared reports if the "notify_flow_source" edge to the NotifyFlowSource entity was cleared.
func (m *NotifySourceMutation) NotifyFlowSourceCleared() bool {
	return m.clearednotify_flow_source
}

// RemoveNotifyFlowSourceIDs removes the "notify_flow_source" edge to the NotifyFlowSource entity by IDs.
func (m *NotifySourceMutation) RemoveNotifyFlowSourceIDs(ids ...int) {
	if m.removednotify_flow_source == nil {
		m.removednotify_flow_source = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notify_flow_source, ids[i])
		m.removednotify_flow_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlowSource returns the removed IDs of the "notify_flow_source" edge to the NotifyFlowSource entity.
func (m *NotifySourceMutation) RemovedNotifyFlowSourceIDs() (ids []int) {
	for id := range m.removednotify_flow_source {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowSourceIDs returns the "notify_flow_source" edge IDs in the mutation.
func (m *NotifySourceMutation) NotifyFlowSourceIDs() (ids []int) {
	for id := range m.notify_flow_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlowSource resets all changes to the "notify_flow_source" edge.
func (m *NotifySourceMutation) ResetNotifyFlowSource() {
	m.notify_flow_source = nil
	m.clearednotify_flow_source = false
	m.removednotify_flow_source = nil
}

// Where appends a list predicates to the NotifySourceMutation builder.
func (m *NotifySourceMutation) Where(ps ...predicate.NotifySource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifySourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifySourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifySource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifySourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifySourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifySource).
func (m *NotifySourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifySourceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.feed_config != nil {
		fields = append(fields, notifysource.FieldFeedConfigID)
	}
	if m.feed_item_collection != nil {
		fields = append(fields, notifysource.FieldFeedItemCollectionID)
	}
	if m.updated_at != nil {
		fields = append(fields, notifysource.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifysource.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifySourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifysource.FieldFeedConfigID:
		return m.FeedConfigID()
	case notifysource.FieldFeedItemCollectionID:
		return m.FeedItemCollectionID()
	case notifysource.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifysource.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifySourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifysource.FieldFeedConfigID:
		return m.OldFeedConfigID(ctx)
	case notifysource.FieldFeedItemCollectionID:
		return m.OldFeedItemCollectionID(ctx)
	case notifysource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifysource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifySource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifySourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifysource.FieldFeedConfigID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedConfigID(v)
		return nil
	case notifysource.FieldFeedItemCollectionID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedItemCollectionID(v)
		return nil
	case notifysource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifysource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifySource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifySourceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifySourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifySourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifySource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifySourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notifysource.FieldFeedConfigID) {
		fields = append(fields, notifysource.FieldFeedConfigID)
	}
	if m.FieldCleared(notifysource.FieldFeedItemCollectionID) {
		fields = append(fields, notifysource.FieldFeedItemCollectionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifySourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifySourceMutation) ClearField(name string) error {
	switch name {
	case notifysource.FieldFeedConfigID:
		m.ClearFeedConfigID()
		return nil
	case notifysource.FieldFeedItemCollectionID:
		m.ClearFeedItemCollectionID()
		return nil
	}
	return fmt.Errorf("unknown NotifySource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifySourceMutation) ResetField(name string) error {
	switch name {
	case notifysource.FieldFeedConfigID:
		m.ResetFeedConfigID()
		return nil
	case notifysource.FieldFeedItemCollectionID:
		m.ResetFeedItemCollectionID()
		return nil
	case notifysource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifysource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifySource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifySourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, notifysource.EdgeOwner)
	}
	if m.notify_flow != nil {
		edges = append(edges, notifysource.EdgeNotifyFlow)
	}
	if m.feed_config != nil {
		edges = append(edges, notifysource.EdgeFeedConfig)
	}
	if m.feed_item_collection != nil {
		edges = append(edges, notifysource.EdgeFeedItemCollection)
	}
	if m.notify_flow_source != nil {
		edges = append(edges, notifysource.EdgeNotifyFlowSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifySourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifysource.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case notifysource.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.notify_flow))
		for id := range m.notify_flow {
			ids = append(ids, id)
		}
		return ids
	case notifysource.EdgeFeedConfig:
		if id := m.feed_config; id != nil {
			return []ent.Value{*id}
		}
	case notifysource.EdgeFeedItemCollection:
		if id := m.feed_item_collection; id != nil {
			return []ent.Value{*id}
		}
	case notifysource.EdgeNotifyFlowSource:
		ids := make([]ent.Value, 0, len(m.notify_flow_source))
		for id := range m.notify_flow_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifySourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removednotify_flow != nil {
		edges = append(edges, notifysource.EdgeNotifyFlow)
	}
	if m.removednotify_flow_source != nil {
		edges = append(edges, notifysource.EdgeNotifyFlowSource)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifySourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notifysource.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.removednotify_flow))
		for id := range m.removednotify_flow {
			ids = append(ids, id)
		}
		return ids
	case notifysource.EdgeNotifyFlowSource:
		ids := make([]ent.Value, 0, len(m.removednotify_flow_source))
		for id := range m.removednotify_flow_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifySourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, notifysource.EdgeOwner)
	}
	if m.clearednotify_flow {
		edges = append(edges, notifysource.EdgeNotifyFlow)
	}
	if m.clearedfeed_config {
		edges = append(edges, notifysource.EdgeFeedConfig)
	}
	if m.clearedfeed_item_collection {
		edges = append(edges, notifysource.EdgeFeedItemCollection)
	}
	if m.clearednotify_flow_source {
		edges = append(edges, notifysource.EdgeNotifyFlowSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifySourceMutation) EdgeCleared(name string) bool {
	switch name {
	case notifysource.EdgeOwner:
		return m.clearedowner
	case notifysource.EdgeNotifyFlow:
		return m.clearednotify_flow
	case notifysource.EdgeFeedConfig:
		return m.clearedfeed_config
	case notifysource.EdgeFeedItemCollection:
		return m.clearedfeed_item_collection
	case notifysource.EdgeNotifyFlowSource:
		return m.clearednotify_flow_source
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifySourceMutation) ClearEdge(name string) error {
	switch name {
	case notifysource.EdgeOwner:
		m.ClearOwner()
		return nil
	case notifysource.EdgeFeedConfig:
		m.ClearFeedConfig()
		return nil
	case notifysource.EdgeFeedItemCollection:
		m.ClearFeedItemCollection()
		return nil
	}
	return fmt.Errorf("unknown NotifySource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifySourceMutation) ResetEdge(name string) error {
	switch name {
	case notifysource.EdgeOwner:
		m.ResetOwner()
		return nil
	case notifysource.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case notifysource.EdgeFeedConfig:
		m.ResetFeedConfig()
		return nil
	case notifysource.EdgeFeedItemCollection:
		m.ResetFeedItemCollection()
		return nil
	case notifysource.EdgeNotifyFlowSource:
		m.ResetNotifyFlowSource()
		return nil
	}
	return fmt.Errorf("unknown NotifySource edge %s", name)
}

// NotifyTargetMutation represents an operation that mutates the NotifyTarget nodes in the graph.
type NotifyTargetMutation struct {
	config
	op                        Op
	typ                       string
	id                        *model.InternalID
	token                     *string
	name                      *string
	description               *string
	destination               *string
	status                    *notifytarget.Status
	updated_at                *time.Time
	created_at                *time.Time
	clearedFields             map[string]struct{}
	owner                     *model.InternalID
	clearedowner              bool
	notify_flow               map[model.InternalID]struct{}
	removednotify_flow        map[model.InternalID]struct{}
	clearednotify_flow        bool
	notify_flow_target        map[int]struct{}
	removednotify_flow_target map[int]struct{}
	clearednotify_flow_target bool
	done                      bool
	oldValue                  func(context.Context) (*NotifyTarget, error)
	predicates                []predicate.NotifyTarget
}

var _ ent.Mutation = (*NotifyTargetMutation)(nil)

// notifytargetOption allows management of the mutation configuration using functional options.
type notifytargetOption func(*NotifyTargetMutation)

// newNotifyTargetMutation creates new mutation for the NotifyTarget entity.
func newNotifyTargetMutation(c config, op Op, opts ...notifytargetOption) *NotifyTargetMutation {
	m := &NotifyTargetMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyTargetID sets the ID field of the mutation.
func withNotifyTargetID(id model.InternalID) notifytargetOption {
	return func(m *NotifyTargetMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyTarget
		)
		m.oldValue = func(ctx context.Context) (*NotifyTarget, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyTarget.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyTarget sets the old NotifyTarget of the mutation.
func withNotifyTarget(node *NotifyTarget) notifytargetOption {
	return func(m *NotifyTargetMutation) {
		m.oldValue = func(context.Context) (*NotifyTarget, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyTargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyTargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotifyTarget entities.
func (m *NotifyTargetMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyTargetMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyTargetMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyTarget.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *NotifyTargetMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *NotifyTargetMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *NotifyTargetMutation) ResetToken() {
	m.token = nil
}

// SetName sets the "name" field.
func (m *NotifyTargetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotifyTargetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotifyTargetMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NotifyTargetMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotifyTargetMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *NotifyTargetMutation) ResetDescription() {
	m.description = nil
}

// SetDestination sets the "destination" field.
func (m *NotifyTargetMutation) SetDestination(s string) {
	m.destination = &s
}

// Destination returns the value of the "destination" field in the mutation.
func (m *NotifyTargetMutation) Destination() (r string, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old "destination" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldDestination(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination resets all changes to the "destination" field.
func (m *NotifyTargetMutation) ResetDestination() {
	m.destination = nil
}

// SetStatus sets the "status" field.
func (m *NotifyTargetMutation) SetStatus(n notifytarget.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NotifyTargetMutation) Status() (r notifytarget.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldStatus(ctx context.Context) (v notifytarget.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NotifyTargetMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyTargetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyTargetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyTargetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyTargetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyTargetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyTargetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *NotifyTargetMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *NotifyTargetMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *NotifyTargetMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NotifyTargetMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NotifyTargetMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NotifyTargetMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddNotifyFlowIDs adds the "notify_flow" edge to the NotifyFlow entity by ids.
func (m *NotifyTargetMutation) AddNotifyFlowIDs(ids ...model.InternalID) {
	if m.notify_flow == nil {
		m.notify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_flow[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifyTargetMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *NotifyTargetMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// RemoveNotifyFlowIDs removes the "notify_flow" edge to the NotifyFlow entity by IDs.
func (m *NotifyTargetMutation) RemoveNotifyFlowIDs(ids ...model.InternalID) {
	if m.removednotify_flow == nil {
		m.removednotify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_flow, ids[i])
		m.removednotify_flow[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlow returns the removed IDs of the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifyTargetMutation) RemovedNotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.removednotify_flow {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
func (m *NotifyTargetMutation) NotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.notify_flow {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *NotifyTargetMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
	m.removednotify_flow = nil
}

// AddNotifyFlowTargetIDs adds the "notify_flow_target" edge to the NotifyFlowTarget entity by ids.
func (m *NotifyTargetMutation) AddNotifyFlowTargetIDs(ids ...int) {
	if m.notify_flow_target == nil {
		m.notify_flow_target = make(map[int]struct{})
	}
	for i := range ids {
		m.notify_flow_target[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlowTarget clears the "notify_flow_target" edge to the NotifyFlowTarget entity.
func (m *NotifyTargetMutation) ClearNotifyFlowTarget() {
	m.clearednotify_flow_target = true
}

// NotifyFlowTargetCleared reports if the "notify_flow_target" edge to the NotifyFlowTarget entity was cleared.
func (m *NotifyTargetMutation) NotifyFlowTargetCleared() bool {
	return m.clearednotify_flow_target
}

// RemoveNotifyFlowTargetIDs removes the "notify_flow_target" edge to the NotifyFlowTarget entity by IDs.
func (m *NotifyTargetMutation) RemoveNotifyFlowTargetIDs(ids ...int) {
	if m.removednotify_flow_target == nil {
		m.removednotify_flow_target = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notify_flow_target, ids[i])
		m.removednotify_flow_target[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlowTarget returns the removed IDs of the "notify_flow_target" edge to the NotifyFlowTarget entity.
func (m *NotifyTargetMutation) RemovedNotifyFlowTargetIDs() (ids []int) {
	for id := range m.removednotify_flow_target {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowTargetIDs returns the "notify_flow_target" edge IDs in the mutation.
func (m *NotifyTargetMutation) NotifyFlowTargetIDs() (ids []int) {
	for id := range m.notify_flow_target {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlowTarget resets all changes to the "notify_flow_target" edge.
func (m *NotifyTargetMutation) ResetNotifyFlowTarget() {
	m.notify_flow_target = nil
	m.clearednotify_flow_target = false
	m.removednotify_flow_target = nil
}

// Where appends a list predicates to the NotifyTargetMutation builder.
func (m *NotifyTargetMutation) Where(ps ...predicate.NotifyTarget) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyTargetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyTargetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyTarget, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyTargetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyTargetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyTarget).
func (m *NotifyTargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyTargetMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.token != nil {
		fields = append(fields, notifytarget.FieldToken)
	}
	if m.name != nil {
		fields = append(fields, notifytarget.FieldName)
	}
	if m.description != nil {
		fields = append(fields, notifytarget.FieldDescription)
	}
	if m.destination != nil {
		fields = append(fields, notifytarget.FieldDestination)
	}
	if m.status != nil {
		fields = append(fields, notifytarget.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, notifytarget.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifytarget.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyTargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifytarget.FieldToken:
		return m.Token()
	case notifytarget.FieldName:
		return m.Name()
	case notifytarget.FieldDescription:
		return m.Description()
	case notifytarget.FieldDestination:
		return m.Destination()
	case notifytarget.FieldStatus:
		return m.Status()
	case notifytarget.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifytarget.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyTargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifytarget.FieldToken:
		return m.OldToken(ctx)
	case notifytarget.FieldName:
		return m.OldName(ctx)
	case notifytarget.FieldDescription:
		return m.OldDescription(ctx)
	case notifytarget.FieldDestination:
		return m.OldDestination(ctx)
	case notifytarget.FieldStatus:
		return m.OldStatus(ctx)
	case notifytarget.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifytarget.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyTarget field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyTargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifytarget.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case notifytarget.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notifytarget.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notifytarget.FieldDestination:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case notifytarget.FieldStatus:
		v, ok := value.(notifytarget.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case notifytarget.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifytarget.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyTarget field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyTargetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyTargetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyTargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifyTarget numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyTargetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyTargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyTargetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotifyTarget nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyTargetMutation) ResetField(name string) error {
	switch name {
	case notifytarget.FieldToken:
		m.ResetToken()
		return nil
	case notifytarget.FieldName:
		m.ResetName()
		return nil
	case notifytarget.FieldDescription:
		m.ResetDescription()
		return nil
	case notifytarget.FieldDestination:
		m.ResetDestination()
		return nil
	case notifytarget.FieldStatus:
		m.ResetStatus()
		return nil
	case notifytarget.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifytarget.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyTarget field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyTargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, notifytarget.EdgeOwner)
	}
	if m.notify_flow != nil {
		edges = append(edges, notifytarget.EdgeNotifyFlow)
	}
	if m.notify_flow_target != nil {
		edges = append(edges, notifytarget.EdgeNotifyFlowTarget)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyTargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifytarget.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case notifytarget.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.notify_flow))
		for id := range m.notify_flow {
			ids = append(ids, id)
		}
		return ids
	case notifytarget.EdgeNotifyFlowTarget:
		ids := make([]ent.Value, 0, len(m.notify_flow_target))
		for id := range m.notify_flow_target {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyTargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removednotify_flow != nil {
		edges = append(edges, notifytarget.EdgeNotifyFlow)
	}
	if m.removednotify_flow_target != nil {
		edges = append(edges, notifytarget.EdgeNotifyFlowTarget)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyTargetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notifytarget.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.removednotify_flow))
		for id := range m.removednotify_flow {
			ids = append(ids, id)
		}
		return ids
	case notifytarget.EdgeNotifyFlowTarget:
		ids := make([]ent.Value, 0, len(m.removednotify_flow_target))
		for id := range m.removednotify_flow_target {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyTargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, notifytarget.EdgeOwner)
	}
	if m.clearednotify_flow {
		edges = append(edges, notifytarget.EdgeNotifyFlow)
	}
	if m.clearednotify_flow_target {
		edges = append(edges, notifytarget.EdgeNotifyFlowTarget)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyTargetMutation) EdgeCleared(name string) bool {
	switch name {
	case notifytarget.EdgeOwner:
		return m.clearedowner
	case notifytarget.EdgeNotifyFlow:
		return m.clearednotify_flow
	case notifytarget.EdgeNotifyFlowTarget:
		return m.clearednotify_flow_target
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyTargetMutation) ClearEdge(name string) error {
	switch name {
	case notifytarget.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown NotifyTarget unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyTargetMutation) ResetEdge(name string) error {
	switch name {
	case notifytarget.EdgeOwner:
		m.ResetOwner()
		return nil
	case notifytarget.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case notifytarget.EdgeNotifyFlowTarget:
		m.ResetNotifyFlowTarget()
		return nil
	}
	return fmt.Errorf("unknown NotifyTarget edge %s", name)
}

// PorterInstanceMutation represents an operation that mutates the PorterInstance nodes in the graph.
type PorterInstanceMutation struct {
	config
	op              Op
	typ             string
	id              *model.InternalID
	name            *string
	version         *string
	global_name     *string
	address         *string
	feature_summary **modeltiphereth.PorterFeatureSummary
	status          *porterinstance.Status
	updated_at      *time.Time
	created_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*PorterInstance, error)
	predicates      []predicate.PorterInstance
}

var _ ent.Mutation = (*PorterInstanceMutation)(nil)

// porterinstanceOption allows management of the mutation configuration using functional options.
type porterinstanceOption func(*PorterInstanceMutation)

// newPorterInstanceMutation creates new mutation for the PorterInstance entity.
func newPorterInstanceMutation(c config, op Op, opts ...porterinstanceOption) *PorterInstanceMutation {
	m := &PorterInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypePorterInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPorterInstanceID sets the ID field of the mutation.
func withPorterInstanceID(id model.InternalID) porterinstanceOption {
	return func(m *PorterInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *PorterInstance
		)
		m.oldValue = func(ctx context.Context) (*PorterInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PorterInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPorterInstance sets the old PorterInstance of the mutation.
func withPorterInstance(node *PorterInstance) porterinstanceOption {
	return func(m *PorterInstanceMutation) {
		m.oldValue = func(context.Context) (*PorterInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PorterInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PorterInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PorterInstance entities.
func (m *PorterInstanceMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PorterInstanceMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PorterInstanceMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PorterInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PorterInstanceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PorterInstanceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PorterInstanceMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PorterInstanceMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PorterInstanceMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PorterInstanceMutation) ResetVersion() {
	m.version = nil
}

// SetGlobalName sets the "global_name" field.
func (m *PorterInstanceMutation) SetGlobalName(s string) {
	m.global_name = &s
}

// GlobalName returns the value of the "global_name" field in the mutation.
func (m *PorterInstanceMutation) GlobalName() (r string, exists bool) {
	v := m.global_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGlobalName returns the old "global_name" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldGlobalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGlobalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGlobalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGlobalName: %w", err)
	}
	return oldValue.GlobalName, nil
}

// ResetGlobalName resets all changes to the "global_name" field.
func (m *PorterInstanceMutation) ResetGlobalName() {
	m.global_name = nil
}

// SetAddress sets the "address" field.
func (m *PorterInstanceMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PorterInstanceMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *PorterInstanceMutation) ResetAddress() {
	m.address = nil
}

// SetFeatureSummary sets the "feature_summary" field.
func (m *PorterInstanceMutation) SetFeatureSummary(mfs *modeltiphereth.PorterFeatureSummary) {
	m.feature_summary = &mfs
}

// FeatureSummary returns the value of the "feature_summary" field in the mutation.
func (m *PorterInstanceMutation) FeatureSummary() (r *modeltiphereth.PorterFeatureSummary, exists bool) {
	v := m.feature_summary
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureSummary returns the old "feature_summary" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldFeatureSummary(ctx context.Context) (v *modeltiphereth.PorterFeatureSummary, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureSummary: %w", err)
	}
	return oldValue.FeatureSummary, nil
}

// ResetFeatureSummary resets all changes to the "feature_summary" field.
func (m *PorterInstanceMutation) ResetFeatureSummary() {
	m.feature_summary = nil
}

// SetStatus sets the "status" field.
func (m *PorterInstanceMutation) SetStatus(po porterinstance.Status) {
	m.status = &po
}

// Status returns the value of the "status" field in the mutation.
func (m *PorterInstanceMutation) Status() (r porterinstance.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldStatus(ctx context.Context) (v porterinstance.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PorterInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PorterInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PorterInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PorterInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PorterInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PorterInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PorterInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the PorterInstanceMutation builder.
func (m *PorterInstanceMutation) Where(ps ...predicate.PorterInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PorterInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PorterInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PorterInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PorterInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PorterInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PorterInstance).
func (m *PorterInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PorterInstanceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, porterinstance.FieldName)
	}
	if m.version != nil {
		fields = append(fields, porterinstance.FieldVersion)
	}
	if m.global_name != nil {
		fields = append(fields, porterinstance.FieldGlobalName)
	}
	if m.address != nil {
		fields = append(fields, porterinstance.FieldAddress)
	}
	if m.feature_summary != nil {
		fields = append(fields, porterinstance.FieldFeatureSummary)
	}
	if m.status != nil {
		fields = append(fields, porterinstance.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, porterinstance.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, porterinstance.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PorterInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case porterinstance.FieldName:
		return m.Name()
	case porterinstance.FieldVersion:
		return m.Version()
	case porterinstance.FieldGlobalName:
		return m.GlobalName()
	case porterinstance.FieldAddress:
		return m.Address()
	case porterinstance.FieldFeatureSummary:
		return m.FeatureSummary()
	case porterinstance.FieldStatus:
		return m.Status()
	case porterinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	case porterinstance.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PorterInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case porterinstance.FieldName:
		return m.OldName(ctx)
	case porterinstance.FieldVersion:
		return m.OldVersion(ctx)
	case porterinstance.FieldGlobalName:
		return m.OldGlobalName(ctx)
	case porterinstance.FieldAddress:
		return m.OldAddress(ctx)
	case porterinstance.FieldFeatureSummary:
		return m.OldFeatureSummary(ctx)
	case porterinstance.FieldStatus:
		return m.OldStatus(ctx)
	case porterinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case porterinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PorterInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PorterInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case porterinstance.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case porterinstance.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case porterinstance.FieldGlobalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGlobalName(v)
		return nil
	case porterinstance.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case porterinstance.FieldFeatureSummary:
		v, ok := value.(*modeltiphereth.PorterFeatureSummary)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureSummary(v)
		return nil
	case porterinstance.FieldStatus:
		v, ok := value.(porterinstance.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case porterinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case porterinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PorterInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PorterInstanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PorterInstanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PorterInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PorterInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PorterInstanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PorterInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PorterInstanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PorterInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PorterInstanceMutation) ResetField(name string) error {
	switch name {
	case porterinstance.FieldName:
		m.ResetName()
		return nil
	case porterinstance.FieldVersion:
		m.ResetVersion()
		return nil
	case porterinstance.FieldGlobalName:
		m.ResetGlobalName()
		return nil
	case porterinstance.FieldAddress:
		m.ResetAddress()
		return nil
	case porterinstance.FieldFeatureSummary:
		m.ResetFeatureSummary()
		return nil
	case porterinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case porterinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case porterinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PorterInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PorterInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PorterInstanceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PorterInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PorterInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PorterInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PorterInstanceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PorterInstanceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PorterInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PorterInstanceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PorterInstance edge %s", name)
}

// PorterPrivilegeMutation represents an operation that mutates the PorterPrivilege nodes in the graph.
type PorterPrivilegeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *model.InternalID
	adduser_id    *model.InternalID
	porter_id     *model.InternalID
	addporter_id  *model.InternalID
	privilege     **modeltiphereth.PorterInstancePrivilege
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PorterPrivilege, error)
	predicates    []predicate.PorterPrivilege
}

var _ ent.Mutation = (*PorterPrivilegeMutation)(nil)

// porterprivilegeOption allows management of the mutation configuration using functional options.
type porterprivilegeOption func(*PorterPrivilegeMutation)

// newPorterPrivilegeMutation creates new mutation for the PorterPrivilege entity.
func newPorterPrivilegeMutation(c config, op Op, opts ...porterprivilegeOption) *PorterPrivilegeMutation {
	m := &PorterPrivilegeMutation{
		config:        c,
		op:            op,
		typ:           TypePorterPrivilege,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPorterPrivilegeID sets the ID field of the mutation.
func withPorterPrivilegeID(id int) porterprivilegeOption {
	return func(m *PorterPrivilegeMutation) {
		var (
			err   error
			once  sync.Once
			value *PorterPrivilege
		)
		m.oldValue = func(ctx context.Context) (*PorterPrivilege, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PorterPrivilege.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPorterPrivilege sets the old PorterPrivilege of the mutation.
func withPorterPrivilege(node *PorterPrivilege) porterprivilegeOption {
	return func(m *PorterPrivilegeMutation) {
		m.oldValue = func(context.Context) (*PorterPrivilege, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PorterPrivilegeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PorterPrivilegeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PorterPrivilegeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PorterPrivilegeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PorterPrivilege.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *PorterPrivilegeMutation) SetUserID(mi model.InternalID) {
	m.user_id = &mi
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PorterPrivilegeMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PorterPrivilege entity.
// If the PorterPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterPrivilegeMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds mi to the "user_id" field.
func (m *PorterPrivilegeMutation) AddUserID(mi model.InternalID) {
	if m.adduser_id != nil {
		*m.adduser_id += mi
	} else {
		m.adduser_id = &mi
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *PorterPrivilegeMutation) AddedUserID() (r model.InternalID, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PorterPrivilegeMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetPorterID sets the "porter_id" field.
func (m *PorterPrivilegeMutation) SetPorterID(mi model.InternalID) {
	m.porter_id = &mi
	m.addporter_id = nil
}

// PorterID returns the value of the "porter_id" field in the mutation.
func (m *PorterPrivilegeMutation) PorterID() (r model.InternalID, exists bool) {
	v := m.porter_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPorterID returns the old "porter_id" field's value of the PorterPrivilege entity.
// If the PorterPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterPrivilegeMutation) OldPorterID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPorterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPorterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPorterID: %w", err)
	}
	return oldValue.PorterID, nil
}

// AddPorterID adds mi to the "porter_id" field.
func (m *PorterPrivilegeMutation) AddPorterID(mi model.InternalID) {
	if m.addporter_id != nil {
		*m.addporter_id += mi
	} else {
		m.addporter_id = &mi
	}
}

// AddedPorterID returns the value that was added to the "porter_id" field in this mutation.
func (m *PorterPrivilegeMutation) AddedPorterID() (r model.InternalID, exists bool) {
	v := m.addporter_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetPorterID resets all changes to the "porter_id" field.
func (m *PorterPrivilegeMutation) ResetPorterID() {
	m.porter_id = nil
	m.addporter_id = nil
}

// SetPrivilege sets the "privilege" field.
func (m *PorterPrivilegeMutation) SetPrivilege(mip *modeltiphereth.PorterInstancePrivilege) {
	m.privilege = &mip
}

// Privilege returns the value of the "privilege" field in the mutation.
func (m *PorterPrivilegeMutation) Privilege() (r *modeltiphereth.PorterInstancePrivilege, exists bool) {
	v := m.privilege
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivilege returns the old "privilege" field's value of the PorterPrivilege entity.
// If the PorterPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterPrivilegeMutation) OldPrivilege(ctx context.Context) (v *modeltiphereth.PorterInstancePrivilege, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivilege is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivilege requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivilege: %w", err)
	}
	return oldValue.Privilege, nil
}

// ResetPrivilege resets all changes to the "privilege" field.
func (m *PorterPrivilegeMutation) ResetPrivilege() {
	m.privilege = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PorterPrivilegeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PorterPrivilegeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PorterPrivilege entity.
// If the PorterPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterPrivilegeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PorterPrivilegeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PorterPrivilegeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PorterPrivilegeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PorterPrivilege entity.
// If the PorterPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterPrivilegeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PorterPrivilegeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the PorterPrivilegeMutation builder.
func (m *PorterPrivilegeMutation) Where(ps ...predicate.PorterPrivilege) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PorterPrivilegeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PorterPrivilegeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PorterPrivilege, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PorterPrivilegeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PorterPrivilegeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PorterPrivilege).
func (m *PorterPrivilegeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PorterPrivilegeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user_id != nil {
		fields = append(fields, porterprivilege.FieldUserID)
	}
	if m.porter_id != nil {
		fields = append(fields, porterprivilege.FieldPorterID)
	}
	if m.privilege != nil {
		fields = append(fields, porterprivilege.FieldPrivilege)
	}
	if m.updated_at != nil {
		fields = append(fields, porterprivilege.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, porterprivilege.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PorterPrivilegeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case porterprivilege.FieldUserID:
		return m.UserID()
	case porterprivilege.FieldPorterID:
		return m.PorterID()
	case porterprivilege.FieldPrivilege:
		return m.Privilege()
	case porterprivilege.FieldUpdatedAt:
		return m.UpdatedAt()
	case porterprivilege.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PorterPrivilegeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case porterprivilege.FieldUserID:
		return m.OldUserID(ctx)
	case porterprivilege.FieldPorterID:
		return m.OldPorterID(ctx)
	case porterprivilege.FieldPrivilege:
		return m.OldPrivilege(ctx)
	case porterprivilege.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case porterprivilege.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PorterPrivilege field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PorterPrivilegeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case porterprivilege.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case porterprivilege.FieldPorterID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPorterID(v)
		return nil
	case porterprivilege.FieldPrivilege:
		v, ok := value.(*modeltiphereth.PorterInstancePrivilege)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivilege(v)
		return nil
	case porterprivilege.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case porterprivilege.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PorterPrivilege field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PorterPrivilegeMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, porterprivilege.FieldUserID)
	}
	if m.addporter_id != nil {
		fields = append(fields, porterprivilege.FieldPorterID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PorterPrivilegeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case porterprivilege.FieldUserID:
		return m.AddedUserID()
	case porterprivilege.FieldPorterID:
		return m.AddedPorterID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PorterPrivilegeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case porterprivilege.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case porterprivilege.FieldPorterID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPorterID(v)
		return nil
	}
	return fmt.Errorf("unknown PorterPrivilege numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PorterPrivilegeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PorterPrivilegeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PorterPrivilegeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PorterPrivilege nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PorterPrivilegeMutation) ResetField(name string) error {
	switch name {
	case porterprivilege.FieldUserID:
		m.ResetUserID()
		return nil
	case porterprivilege.FieldPorterID:
		m.ResetPorterID()
		return nil
	case porterprivilege.FieldPrivilege:
		m.ResetPrivilege()
		return nil
	case porterprivilege.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case porterprivilege.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PorterPrivilege field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PorterPrivilegeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PorterPrivilegeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PorterPrivilegeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PorterPrivilegeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PorterPrivilegeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PorterPrivilegeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PorterPrivilegeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PorterPrivilege unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PorterPrivilegeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PorterPrivilege edge %s", name)
}

// SystemNotificationMutation represents an operation that mutates the SystemNotification nodes in the graph.
type SystemNotificationMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	user_id       *model.InternalID
	adduser_id    *model.InternalID
	_type         *systemnotification.Type
	level         *systemnotification.Level
	status        *systemnotification.Status
	title         *string
	content       *string
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SystemNotification, error)
	predicates    []predicate.SystemNotification
}

var _ ent.Mutation = (*SystemNotificationMutation)(nil)

// systemnotificationOption allows management of the mutation configuration using functional options.
type systemnotificationOption func(*SystemNotificationMutation)

// newSystemNotificationMutation creates new mutation for the SystemNotification entity.
func newSystemNotificationMutation(c config, op Op, opts ...systemnotificationOption) *SystemNotificationMutation {
	m := &SystemNotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemNotificationID sets the ID field of the mutation.
func withSystemNotificationID(id model.InternalID) systemnotificationOption {
	return func(m *SystemNotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemNotification
		)
		m.oldValue = func(ctx context.Context) (*SystemNotification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemNotification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemNotification sets the old SystemNotification of the mutation.
func withSystemNotification(node *SystemNotification) systemnotificationOption {
	return func(m *SystemNotificationMutation) {
		m.oldValue = func(context.Context) (*SystemNotification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemNotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemNotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemNotification entities.
func (m *SystemNotificationMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemNotificationMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemNotificationMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemNotification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SystemNotificationMutation) SetUserID(mi model.InternalID) {
	m.user_id = &mi
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SystemNotificationMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds mi to the "user_id" field.
func (m *SystemNotificationMutation) AddUserID(mi model.InternalID) {
	if m.adduser_id != nil {
		*m.adduser_id += mi
	} else {
		m.adduser_id = &mi
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *SystemNotificationMutation) AddedUserID() (r model.InternalID, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *SystemNotificationMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[systemnotification.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *SystemNotificationMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[systemnotification.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SystemNotificationMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, systemnotification.FieldUserID)
}

// SetType sets the "type" field.
func (m *SystemNotificationMutation) SetType(s systemnotification.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SystemNotificationMutation) GetType() (r systemnotification.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldType(ctx context.Context) (v systemnotification.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SystemNotificationMutation) ResetType() {
	m._type = nil
}

// SetLevel sets the "level" field.
func (m *SystemNotificationMutation) SetLevel(s systemnotification.Level) {
	m.level = &s
}

// Level returns the value of the "level" field in the mutation.
func (m *SystemNotificationMutation) Level() (r systemnotification.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldLevel(ctx context.Context) (v systemnotification.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *SystemNotificationMutation) ResetLevel() {
	m.level = nil
}

// SetStatus sets the "status" field.
func (m *SystemNotificationMutation) SetStatus(s systemnotification.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SystemNotificationMutation) Status() (r systemnotification.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldStatus(ctx context.Context) (v systemnotification.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SystemNotificationMutation) ResetStatus() {
	m.status = nil
}

// SetTitle sets the "title" field.
func (m *SystemNotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SystemNotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SystemNotificationMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *SystemNotificationMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SystemNotificationMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *SystemNotificationMutation) ResetContent() {
	m.content = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemNotificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemNotificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemNotificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemNotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemNotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemNotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the SystemNotificationMutation builder.
func (m *SystemNotificationMutation) Where(ps ...predicate.SystemNotification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemNotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemNotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemNotification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemNotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemNotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemNotification).
func (m *SystemNotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemNotificationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.user_id != nil {
		fields = append(fields, systemnotification.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, systemnotification.FieldType)
	}
	if m.level != nil {
		fields = append(fields, systemnotification.FieldLevel)
	}
	if m.status != nil {
		fields = append(fields, systemnotification.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, systemnotification.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, systemnotification.FieldContent)
	}
	if m.updated_at != nil {
		fields = append(fields, systemnotification.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, systemnotification.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemNotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemnotification.FieldUserID:
		return m.UserID()
	case systemnotification.FieldType:
		return m.GetType()
	case systemnotification.FieldLevel:
		return m.Level()
	case systemnotification.FieldStatus:
		return m.Status()
	case systemnotification.FieldTitle:
		return m.Title()
	case systemnotification.FieldContent:
		return m.Content()
	case systemnotification.FieldUpdatedAt:
		return m.UpdatedAt()
	case systemnotification.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemNotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemnotification.FieldUserID:
		return m.OldUserID(ctx)
	case systemnotification.FieldType:
		return m.OldType(ctx)
	case systemnotification.FieldLevel:
		return m.OldLevel(ctx)
	case systemnotification.FieldStatus:
		return m.OldStatus(ctx)
	case systemnotification.FieldTitle:
		return m.OldTitle(ctx)
	case systemnotification.FieldContent:
		return m.OldContent(ctx)
	case systemnotification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case systemnotification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemNotification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemNotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemnotification.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case systemnotification.FieldType:
		v, ok := value.(systemnotification.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case systemnotification.FieldLevel:
		v, ok := value.(systemnotification.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case systemnotification.FieldStatus:
		v, ok := value.(systemnotification.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case systemnotification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case systemnotification.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case systemnotification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case systemnotification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemNotification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemNotificationMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, systemnotification.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemNotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case systemnotification.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemNotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case systemnotification.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown SystemNotification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemNotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemnotification.FieldUserID) {
		fields = append(fields, systemnotification.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemNotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemNotificationMutation) ClearField(name string) error {
	switch name {
	case systemnotification.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown SystemNotification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemNotificationMutation) ResetField(name string) error {
	switch name {
	case systemnotification.FieldUserID:
		m.ResetUserID()
		return nil
	case systemnotification.FieldType:
		m.ResetType()
		return nil
	case systemnotification.FieldLevel:
		m.ResetLevel()
		return nil
	case systemnotification.FieldStatus:
		m.ResetStatus()
		return nil
	case systemnotification.FieldTitle:
		m.ResetTitle()
		return nil
	case systemnotification.FieldContent:
		m.ResetContent()
		return nil
	case systemnotification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case systemnotification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemNotification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemNotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemNotificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemNotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemNotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemNotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemNotificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemNotificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SystemNotification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemNotificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SystemNotification edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	name          *string
	description   *string
	public        *bool
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *model.InternalID
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id model.InternalID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserTag sets the "user_tag" field.
func (m *TagMutation) SetUserTag(mi model.InternalID) {
	m.owner = &mi
}

// UserTag returns the value of the "user_tag" field in the mutation.
func (m *TagMutation) UserTag() (r model.InternalID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserTag returns the old "user_tag" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUserTag(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserTag: %w", err)
	}
	return oldValue.UserTag, nil
}

// ResetUserTag resets all changes to the "user_tag" field.
func (m *TagMutation) ResetUserTag() {
	m.owner = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
}

// SetPublic sets the "public" field.
func (m *TagMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *TagMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *TagMutation) ResetPublic() {
	m.public = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TagMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TagMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[tag.FieldUserTag] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TagMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TagMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TagMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TagMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.owner != nil {
		fields = append(fields, tag.FieldUserTag)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.public != nil {
		fields = append(fields, tag.FieldPublic)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldUserTag:
		return m.UserTag()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldPublic:
		return m.Public()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldUserTag:
		return m.OldUserTag(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldPublic:
		return m.OldPublic(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldUserTag:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserTag(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldUserTag:
		m.ResetUserTag()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldPublic:
		m.ResetPublic()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, tag.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, tag.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *model.InternalID
	username                    *string
	password                    *string
	status                      *user.Status
	_type                       *user.Type
	updated_at                  *time.Time
	created_at                  *time.Time
	clearedFields               map[string]struct{}
	bind_account                map[model.InternalID]struct{}
	removedbind_account         map[model.InternalID]struct{}
	clearedbind_account         bool
	purchased_app               map[model.InternalID]struct{}
	removedpurchased_app        map[model.InternalID]struct{}
	clearedpurchased_app        bool
	app                         map[model.InternalID]struct{}
	removedapp                  map[model.InternalID]struct{}
	clearedapp                  bool
	app_inst                    map[model.InternalID]struct{}
	removedapp_inst             map[model.InternalID]struct{}
	clearedapp_inst             bool
	feed_config                 map[model.InternalID]struct{}
	removedfeed_config          map[model.InternalID]struct{}
	clearedfeed_config          bool
	feed_action_set             map[model.InternalID]struct{}
	removedfeed_action_set      map[model.InternalID]struct{}
	clearedfeed_action_set      bool
	feed_item_collection        map[model.InternalID]struct{}
	removedfeed_item_collection map[model.InternalID]struct{}
	clearedfeed_item_collection bool
	notify_source               map[model.InternalID]struct{}
	removednotify_source        map[model.InternalID]struct{}
	clearednotify_source        bool
	notify_target               map[model.InternalID]struct{}
	removednotify_target        map[model.InternalID]struct{}
	clearednotify_target        bool
	notify_flow                 map[model.InternalID]struct{}
	removednotify_flow          map[model.InternalID]struct{}
	clearednotify_flow          bool
	image                       map[model.InternalID]struct{}
	removedimage                map[model.InternalID]struct{}
	clearedimage                bool
	file                        map[model.InternalID]struct{}
	removedfile                 map[model.InternalID]struct{}
	clearedfile                 bool
	device_info                 map[model.InternalID]struct{}
	removeddevice_info          map[model.InternalID]struct{}
	cleareddevice_info          bool
	tag                         map[model.InternalID]struct{}
	removedtag                  map[model.InternalID]struct{}
	clearedtag                  bool
	creator                     *model.InternalID
	clearedcreator              bool
	created_user                map[model.InternalID]struct{}
	removedcreated_user         map[model.InternalID]struct{}
	clearedcreated_user         bool
	user_device                 map[int]struct{}
	removeduser_device          map[int]struct{}
	cleareduser_device          bool
	done                        bool
	oldValue                    func(context.Context) (*User, error)
	predicates                  []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id model.InternalID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *UserMutation) SetType(u user.Type) {
	m._type = &u
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserMutation) GetType() (r user.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldType(ctx context.Context) (v user.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserMutation) ResetType() {
	m._type = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddBindAccountIDs adds the "bind_account" edge to the Account entity by ids.
func (m *UserMutation) AddBindAccountIDs(ids ...model.InternalID) {
	if m.bind_account == nil {
		m.bind_account = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.bind_account[ids[i]] = struct{}{}
	}
}

// ClearBindAccount clears the "bind_account" edge to the Account entity.
func (m *UserMutation) ClearBindAccount() {
	m.clearedbind_account = true
}

// BindAccountCleared reports if the "bind_account" edge to the Account entity was cleared.
func (m *UserMutation) BindAccountCleared() bool {
	return m.clearedbind_account
}

// RemoveBindAccountIDs removes the "bind_account" edge to the Account entity by IDs.
func (m *UserMutation) RemoveBindAccountIDs(ids ...model.InternalID) {
	if m.removedbind_account == nil {
		m.removedbind_account = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.bind_account, ids[i])
		m.removedbind_account[ids[i]] = struct{}{}
	}
}

// RemovedBindAccount returns the removed IDs of the "bind_account" edge to the Account entity.
func (m *UserMutation) RemovedBindAccountIDs() (ids []model.InternalID) {
	for id := range m.removedbind_account {
		ids = append(ids, id)
	}
	return
}

// BindAccountIDs returns the "bind_account" edge IDs in the mutation.
func (m *UserMutation) BindAccountIDs() (ids []model.InternalID) {
	for id := range m.bind_account {
		ids = append(ids, id)
	}
	return
}

// ResetBindAccount resets all changes to the "bind_account" edge.
func (m *UserMutation) ResetBindAccount() {
	m.bind_account = nil
	m.clearedbind_account = false
	m.removedbind_account = nil
}

// AddPurchasedAppIDs adds the "purchased_app" edge to the AppInfo entity by ids.
func (m *UserMutation) AddPurchasedAppIDs(ids ...model.InternalID) {
	if m.purchased_app == nil {
		m.purchased_app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.purchased_app[ids[i]] = struct{}{}
	}
}

// ClearPurchasedApp clears the "purchased_app" edge to the AppInfo entity.
func (m *UserMutation) ClearPurchasedApp() {
	m.clearedpurchased_app = true
}

// PurchasedAppCleared reports if the "purchased_app" edge to the AppInfo entity was cleared.
func (m *UserMutation) PurchasedAppCleared() bool {
	return m.clearedpurchased_app
}

// RemovePurchasedAppIDs removes the "purchased_app" edge to the AppInfo entity by IDs.
func (m *UserMutation) RemovePurchasedAppIDs(ids ...model.InternalID) {
	if m.removedpurchased_app == nil {
		m.removedpurchased_app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.purchased_app, ids[i])
		m.removedpurchased_app[ids[i]] = struct{}{}
	}
}

// RemovedPurchasedApp returns the removed IDs of the "purchased_app" edge to the AppInfo entity.
func (m *UserMutation) RemovedPurchasedAppIDs() (ids []model.InternalID) {
	for id := range m.removedpurchased_app {
		ids = append(ids, id)
	}
	return
}

// PurchasedAppIDs returns the "purchased_app" edge IDs in the mutation.
func (m *UserMutation) PurchasedAppIDs() (ids []model.InternalID) {
	for id := range m.purchased_app {
		ids = append(ids, id)
	}
	return
}

// ResetPurchasedApp resets all changes to the "purchased_app" edge.
func (m *UserMutation) ResetPurchasedApp() {
	m.purchased_app = nil
	m.clearedpurchased_app = false
	m.removedpurchased_app = nil
}

// AddAppIDs adds the "app" edge to the App entity by ids.
func (m *UserMutation) AddAppIDs(ids ...model.InternalID) {
	if m.app == nil {
		m.app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.app[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "app" edge to the App entity.
func (m *UserMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *UserMutation) AppCleared() bool {
	return m.clearedapp
}

// RemoveAppIDs removes the "app" edge to the App entity by IDs.
func (m *UserMutation) RemoveAppIDs(ids ...model.InternalID) {
	if m.removedapp == nil {
		m.removedapp = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.app, ids[i])
		m.removedapp[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "app" edge to the App entity.
func (m *UserMutation) RemovedAppIDs() (ids []model.InternalID) {
	for id := range m.removedapp {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
func (m *UserMutation) AppIDs() (ids []model.InternalID) {
	for id := range m.app {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *UserMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
	m.removedapp = nil
}

// AddAppInstIDs adds the "app_inst" edge to the AppInst entity by ids.
func (m *UserMutation) AddAppInstIDs(ids ...model.InternalID) {
	if m.app_inst == nil {
		m.app_inst = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.app_inst[ids[i]] = struct{}{}
	}
}

// ClearAppInst clears the "app_inst" edge to the AppInst entity.
func (m *UserMutation) ClearAppInst() {
	m.clearedapp_inst = true
}

// AppInstCleared reports if the "app_inst" edge to the AppInst entity was cleared.
func (m *UserMutation) AppInstCleared() bool {
	return m.clearedapp_inst
}

// RemoveAppInstIDs removes the "app_inst" edge to the AppInst entity by IDs.
func (m *UserMutation) RemoveAppInstIDs(ids ...model.InternalID) {
	if m.removedapp_inst == nil {
		m.removedapp_inst = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.app_inst, ids[i])
		m.removedapp_inst[ids[i]] = struct{}{}
	}
}

// RemovedAppInst returns the removed IDs of the "app_inst" edge to the AppInst entity.
func (m *UserMutation) RemovedAppInstIDs() (ids []model.InternalID) {
	for id := range m.removedapp_inst {
		ids = append(ids, id)
	}
	return
}

// AppInstIDs returns the "app_inst" edge IDs in the mutation.
func (m *UserMutation) AppInstIDs() (ids []model.InternalID) {
	for id := range m.app_inst {
		ids = append(ids, id)
	}
	return
}

// ResetAppInst resets all changes to the "app_inst" edge.
func (m *UserMutation) ResetAppInst() {
	m.app_inst = nil
	m.clearedapp_inst = false
	m.removedapp_inst = nil
}

// AddFeedConfigIDs adds the "feed_config" edge to the FeedConfig entity by ids.
func (m *UserMutation) AddFeedConfigIDs(ids ...model.InternalID) {
	if m.feed_config == nil {
		m.feed_config = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_config[ids[i]] = struct{}{}
	}
}

// ClearFeedConfig clears the "feed_config" edge to the FeedConfig entity.
func (m *UserMutation) ClearFeedConfig() {
	m.clearedfeed_config = true
}

// FeedConfigCleared reports if the "feed_config" edge to the FeedConfig entity was cleared.
func (m *UserMutation) FeedConfigCleared() bool {
	return m.clearedfeed_config
}

// RemoveFeedConfigIDs removes the "feed_config" edge to the FeedConfig entity by IDs.
func (m *UserMutation) RemoveFeedConfigIDs(ids ...model.InternalID) {
	if m.removedfeed_config == nil {
		m.removedfeed_config = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_config, ids[i])
		m.removedfeed_config[ids[i]] = struct{}{}
	}
}

// RemovedFeedConfig returns the removed IDs of the "feed_config" edge to the FeedConfig entity.
func (m *UserMutation) RemovedFeedConfigIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_config {
		ids = append(ids, id)
	}
	return
}

// FeedConfigIDs returns the "feed_config" edge IDs in the mutation.
func (m *UserMutation) FeedConfigIDs() (ids []model.InternalID) {
	for id := range m.feed_config {
		ids = append(ids, id)
	}
	return
}

// ResetFeedConfig resets all changes to the "feed_config" edge.
func (m *UserMutation) ResetFeedConfig() {
	m.feed_config = nil
	m.clearedfeed_config = false
	m.removedfeed_config = nil
}

// AddFeedActionSetIDs adds the "feed_action_set" edge to the FeedActionSet entity by ids.
func (m *UserMutation) AddFeedActionSetIDs(ids ...model.InternalID) {
	if m.feed_action_set == nil {
		m.feed_action_set = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_action_set[ids[i]] = struct{}{}
	}
}

// ClearFeedActionSet clears the "feed_action_set" edge to the FeedActionSet entity.
func (m *UserMutation) ClearFeedActionSet() {
	m.clearedfeed_action_set = true
}

// FeedActionSetCleared reports if the "feed_action_set" edge to the FeedActionSet entity was cleared.
func (m *UserMutation) FeedActionSetCleared() bool {
	return m.clearedfeed_action_set
}

// RemoveFeedActionSetIDs removes the "feed_action_set" edge to the FeedActionSet entity by IDs.
func (m *UserMutation) RemoveFeedActionSetIDs(ids ...model.InternalID) {
	if m.removedfeed_action_set == nil {
		m.removedfeed_action_set = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_action_set, ids[i])
		m.removedfeed_action_set[ids[i]] = struct{}{}
	}
}

// RemovedFeedActionSet returns the removed IDs of the "feed_action_set" edge to the FeedActionSet entity.
func (m *UserMutation) RemovedFeedActionSetIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_action_set {
		ids = append(ids, id)
	}
	return
}

// FeedActionSetIDs returns the "feed_action_set" edge IDs in the mutation.
func (m *UserMutation) FeedActionSetIDs() (ids []model.InternalID) {
	for id := range m.feed_action_set {
		ids = append(ids, id)
	}
	return
}

// ResetFeedActionSet resets all changes to the "feed_action_set" edge.
func (m *UserMutation) ResetFeedActionSet() {
	m.feed_action_set = nil
	m.clearedfeed_action_set = false
	m.removedfeed_action_set = nil
}

// AddFeedItemCollectionIDs adds the "feed_item_collection" edge to the FeedItemCollection entity by ids.
func (m *UserMutation) AddFeedItemCollectionIDs(ids ...model.InternalID) {
	if m.feed_item_collection == nil {
		m.feed_item_collection = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_item_collection[ids[i]] = struct{}{}
	}
}

// ClearFeedItemCollection clears the "feed_item_collection" edge to the FeedItemCollection entity.
func (m *UserMutation) ClearFeedItemCollection() {
	m.clearedfeed_item_collection = true
}

// FeedItemCollectionCleared reports if the "feed_item_collection" edge to the FeedItemCollection entity was cleared.
func (m *UserMutation) FeedItemCollectionCleared() bool {
	return m.clearedfeed_item_collection
}

// RemoveFeedItemCollectionIDs removes the "feed_item_collection" edge to the FeedItemCollection entity by IDs.
func (m *UserMutation) RemoveFeedItemCollectionIDs(ids ...model.InternalID) {
	if m.removedfeed_item_collection == nil {
		m.removedfeed_item_collection = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_item_collection, ids[i])
		m.removedfeed_item_collection[ids[i]] = struct{}{}
	}
}

// RemovedFeedItemCollection returns the removed IDs of the "feed_item_collection" edge to the FeedItemCollection entity.
func (m *UserMutation) RemovedFeedItemCollectionIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_item_collection {
		ids = append(ids, id)
	}
	return
}

// FeedItemCollectionIDs returns the "feed_item_collection" edge IDs in the mutation.
func (m *UserMutation) FeedItemCollectionIDs() (ids []model.InternalID) {
	for id := range m.feed_item_collection {
		ids = append(ids, id)
	}
	return
}

// ResetFeedItemCollection resets all changes to the "feed_item_collection" edge.
func (m *UserMutation) ResetFeedItemCollection() {
	m.feed_item_collection = nil
	m.clearedfeed_item_collection = false
	m.removedfeed_item_collection = nil
}

// AddNotifySourceIDs adds the "notify_source" edge to the NotifySource entity by ids.
func (m *UserMutation) AddNotifySourceIDs(ids ...model.InternalID) {
	if m.notify_source == nil {
		m.notify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_source[ids[i]] = struct{}{}
	}
}

// ClearNotifySource clears the "notify_source" edge to the NotifySource entity.
func (m *UserMutation) ClearNotifySource() {
	m.clearednotify_source = true
}

// NotifySourceCleared reports if the "notify_source" edge to the NotifySource entity was cleared.
func (m *UserMutation) NotifySourceCleared() bool {
	return m.clearednotify_source
}

// RemoveNotifySourceIDs removes the "notify_source" edge to the NotifySource entity by IDs.
func (m *UserMutation) RemoveNotifySourceIDs(ids ...model.InternalID) {
	if m.removednotify_source == nil {
		m.removednotify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_source, ids[i])
		m.removednotify_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifySource returns the removed IDs of the "notify_source" edge to the NotifySource entity.
func (m *UserMutation) RemovedNotifySourceIDs() (ids []model.InternalID) {
	for id := range m.removednotify_source {
		ids = append(ids, id)
	}
	return
}

// NotifySourceIDs returns the "notify_source" edge IDs in the mutation.
func (m *UserMutation) NotifySourceIDs() (ids []model.InternalID) {
	for id := range m.notify_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifySource resets all changes to the "notify_source" edge.
func (m *UserMutation) ResetNotifySource() {
	m.notify_source = nil
	m.clearednotify_source = false
	m.removednotify_source = nil
}

// AddNotifyTargetIDs adds the "notify_target" edge to the NotifyTarget entity by ids.
func (m *UserMutation) AddNotifyTargetIDs(ids ...model.InternalID) {
	if m.notify_target == nil {
		m.notify_target = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_target[ids[i]] = struct{}{}
	}
}

// ClearNotifyTarget clears the "notify_target" edge to the NotifyTarget entity.
func (m *UserMutation) ClearNotifyTarget() {
	m.clearednotify_target = true
}

// NotifyTargetCleared reports if the "notify_target" edge to the NotifyTarget entity was cleared.
func (m *UserMutation) NotifyTargetCleared() bool {
	return m.clearednotify_target
}

// RemoveNotifyTargetIDs removes the "notify_target" edge to the NotifyTarget entity by IDs.
func (m *UserMutation) RemoveNotifyTargetIDs(ids ...model.InternalID) {
	if m.removednotify_target == nil {
		m.removednotify_target = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_target, ids[i])
		m.removednotify_target[ids[i]] = struct{}{}
	}
}

// RemovedNotifyTarget returns the removed IDs of the "notify_target" edge to the NotifyTarget entity.
func (m *UserMutation) RemovedNotifyTargetIDs() (ids []model.InternalID) {
	for id := range m.removednotify_target {
		ids = append(ids, id)
	}
	return
}

// NotifyTargetIDs returns the "notify_target" edge IDs in the mutation.
func (m *UserMutation) NotifyTargetIDs() (ids []model.InternalID) {
	for id := range m.notify_target {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyTarget resets all changes to the "notify_target" edge.
func (m *UserMutation) ResetNotifyTarget() {
	m.notify_target = nil
	m.clearednotify_target = false
	m.removednotify_target = nil
}

// AddNotifyFlowIDs adds the "notify_flow" edge to the NotifyFlow entity by ids.
func (m *UserMutation) AddNotifyFlowIDs(ids ...model.InternalID) {
	if m.notify_flow == nil {
		m.notify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_flow[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *UserMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *UserMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// RemoveNotifyFlowIDs removes the "notify_flow" edge to the NotifyFlow entity by IDs.
func (m *UserMutation) RemoveNotifyFlowIDs(ids ...model.InternalID) {
	if m.removednotify_flow == nil {
		m.removednotify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_flow, ids[i])
		m.removednotify_flow[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlow returns the removed IDs of the "notify_flow" edge to the NotifyFlow entity.
func (m *UserMutation) RemovedNotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.removednotify_flow {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
func (m *UserMutation) NotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.notify_flow {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *UserMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
	m.removednotify_flow = nil
}

// AddImageIDs adds the "image" edge to the Image entity by ids.
func (m *UserMutation) AddImageIDs(ids ...model.InternalID) {
	if m.image == nil {
		m.image = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.image[ids[i]] = struct{}{}
	}
}

// ClearImage clears the "image" edge to the Image entity.
func (m *UserMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *UserMutation) ImageCleared() bool {
	return m.clearedimage
}

// RemoveImageIDs removes the "image" edge to the Image entity by IDs.
func (m *UserMutation) RemoveImageIDs(ids ...model.InternalID) {
	if m.removedimage == nil {
		m.removedimage = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.image, ids[i])
		m.removedimage[ids[i]] = struct{}{}
	}
}

// RemovedImage returns the removed IDs of the "image" edge to the Image entity.
func (m *UserMutation) RemovedImageIDs() (ids []model.InternalID) {
	for id := range m.removedimage {
		ids = append(ids, id)
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
func (m *UserMutation) ImageIDs() (ids []model.InternalID) {
	for id := range m.image {
		ids = append(ids, id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *UserMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
	m.removedimage = nil
}

// AddFileIDs adds the "file" edge to the File entity by ids.
func (m *UserMutation) AddFileIDs(ids ...model.InternalID) {
	if m.file == nil {
		m.file = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.file[ids[i]] = struct{}{}
	}
}

// ClearFile clears the "file" edge to the File entity.
func (m *UserMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *UserMutation) FileCleared() bool {
	return m.clearedfile
}

// RemoveFileIDs removes the "file" edge to the File entity by IDs.
func (m *UserMutation) RemoveFileIDs(ids ...model.InternalID) {
	if m.removedfile == nil {
		m.removedfile = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.file, ids[i])
		m.removedfile[ids[i]] = struct{}{}
	}
}

// RemovedFile returns the removed IDs of the "file" edge to the File entity.
func (m *UserMutation) RemovedFileIDs() (ids []model.InternalID) {
	for id := range m.removedfile {
		ids = append(ids, id)
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
func (m *UserMutation) FileIDs() (ids []model.InternalID) {
	for id := range m.file {
		ids = append(ids, id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *UserMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
	m.removedfile = nil
}

// AddDeviceInfoIDs adds the "device_info" edge to the DeviceInfo entity by ids.
func (m *UserMutation) AddDeviceInfoIDs(ids ...model.InternalID) {
	if m.device_info == nil {
		m.device_info = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.device_info[ids[i]] = struct{}{}
	}
}

// ClearDeviceInfo clears the "device_info" edge to the DeviceInfo entity.
func (m *UserMutation) ClearDeviceInfo() {
	m.cleareddevice_info = true
}

// DeviceInfoCleared reports if the "device_info" edge to the DeviceInfo entity was cleared.
func (m *UserMutation) DeviceInfoCleared() bool {
	return m.cleareddevice_info
}

// RemoveDeviceInfoIDs removes the "device_info" edge to the DeviceInfo entity by IDs.
func (m *UserMutation) RemoveDeviceInfoIDs(ids ...model.InternalID) {
	if m.removeddevice_info == nil {
		m.removeddevice_info = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.device_info, ids[i])
		m.removeddevice_info[ids[i]] = struct{}{}
	}
}

// RemovedDeviceInfo returns the removed IDs of the "device_info" edge to the DeviceInfo entity.
func (m *UserMutation) RemovedDeviceInfoIDs() (ids []model.InternalID) {
	for id := range m.removeddevice_info {
		ids = append(ids, id)
	}
	return
}

// DeviceInfoIDs returns the "device_info" edge IDs in the mutation.
func (m *UserMutation) DeviceInfoIDs() (ids []model.InternalID) {
	for id := range m.device_info {
		ids = append(ids, id)
	}
	return
}

// ResetDeviceInfo resets all changes to the "device_info" edge.
func (m *UserMutation) ResetDeviceInfo() {
	m.device_info = nil
	m.cleareddevice_info = false
	m.removeddevice_info = nil
}

// AddTagIDs adds the "tag" edge to the Tag entity by ids.
func (m *UserMutation) AddTagIDs(ids ...model.InternalID) {
	if m.tag == nil {
		m.tag = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *UserMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *UserMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the "tag" edge to the Tag entity by IDs.
func (m *UserMutation) RemoveTagIDs(ids ...model.InternalID) {
	if m.removedtag == nil {
		m.removedtag = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.tag, ids[i])
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed IDs of the "tag" edge to the Tag entity.
func (m *UserMutation) RemovedTagIDs() (ids []model.InternalID) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
func (m *UserMutation) TagIDs() (ids []model.InternalID) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *UserMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *UserMutation) SetCreatorID(id model.InternalID) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *UserMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *UserMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *UserMutation) CreatorID() (id model.InternalID, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CreatorIDs() (ids []model.InternalID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *UserMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddCreatedUserIDs adds the "created_user" edge to the User entity by ids.
func (m *UserMutation) AddCreatedUserIDs(ids ...model.InternalID) {
	if m.created_user == nil {
		m.created_user = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.created_user[ids[i]] = struct{}{}
	}
}

// ClearCreatedUser clears the "created_user" edge to the User entity.
func (m *UserMutation) ClearCreatedUser() {
	m.clearedcreated_user = true
}

// CreatedUserCleared reports if the "created_user" edge to the User entity was cleared.
func (m *UserMutation) CreatedUserCleared() bool {
	return m.clearedcreated_user
}

// RemoveCreatedUserIDs removes the "created_user" edge to the User entity by IDs.
func (m *UserMutation) RemoveCreatedUserIDs(ids ...model.InternalID) {
	if m.removedcreated_user == nil {
		m.removedcreated_user = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.created_user, ids[i])
		m.removedcreated_user[ids[i]] = struct{}{}
	}
}

// RemovedCreatedUser returns the removed IDs of the "created_user" edge to the User entity.
func (m *UserMutation) RemovedCreatedUserIDs() (ids []model.InternalID) {
	for id := range m.removedcreated_user {
		ids = append(ids, id)
	}
	return
}

// CreatedUserIDs returns the "created_user" edge IDs in the mutation.
func (m *UserMutation) CreatedUserIDs() (ids []model.InternalID) {
	for id := range m.created_user {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedUser resets all changes to the "created_user" edge.
func (m *UserMutation) ResetCreatedUser() {
	m.created_user = nil
	m.clearedcreated_user = false
	m.removedcreated_user = nil
}

// AddUserDeviceIDs adds the "user_device" edge to the UserDevice entity by ids.
func (m *UserMutation) AddUserDeviceIDs(ids ...int) {
	if m.user_device == nil {
		m.user_device = make(map[int]struct{})
	}
	for i := range ids {
		m.user_device[ids[i]] = struct{}{}
	}
}

// ClearUserDevice clears the "user_device" edge to the UserDevice entity.
func (m *UserMutation) ClearUserDevice() {
	m.cleareduser_device = true
}

// UserDeviceCleared reports if the "user_device" edge to the UserDevice entity was cleared.
func (m *UserMutation) UserDeviceCleared() bool {
	return m.cleareduser_device
}

// RemoveUserDeviceIDs removes the "user_device" edge to the UserDevice entity by IDs.
func (m *UserMutation) RemoveUserDeviceIDs(ids ...int) {
	if m.removeduser_device == nil {
		m.removeduser_device = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_device, ids[i])
		m.removeduser_device[ids[i]] = struct{}{}
	}
}

// RemovedUserDevice returns the removed IDs of the "user_device" edge to the UserDevice entity.
func (m *UserMutation) RemovedUserDeviceIDs() (ids []int) {
	for id := range m.removeduser_device {
		ids = append(ids, id)
	}
	return
}

// UserDeviceIDs returns the "user_device" edge IDs in the mutation.
func (m *UserMutation) UserDeviceIDs() (ids []int) {
	for id := range m.user_device {
		ids = append(ids, id)
	}
	return
}

// ResetUserDevice resets all changes to the "user_device" edge.
func (m *UserMutation) ResetUserDevice() {
	m.user_device = nil
	m.cleareduser_device = false
	m.removeduser_device = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, user.FieldType)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldStatus:
		return m.Status()
	case user.FieldType:
		return m.GetType()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldType:
		return m.OldType(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldType:
		v, ok := value.(user.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldType:
		m.ResetType()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m.bind_account != nil {
		edges = append(edges, user.EdgeBindAccount)
	}
	if m.purchased_app != nil {
		edges = append(edges, user.EdgePurchasedApp)
	}
	if m.app != nil {
		edges = append(edges, user.EdgeApp)
	}
	if m.app_inst != nil {
		edges = append(edges, user.EdgeAppInst)
	}
	if m.feed_config != nil {
		edges = append(edges, user.EdgeFeedConfig)
	}
	if m.feed_action_set != nil {
		edges = append(edges, user.EdgeFeedActionSet)
	}
	if m.feed_item_collection != nil {
		edges = append(edges, user.EdgeFeedItemCollection)
	}
	if m.notify_source != nil {
		edges = append(edges, user.EdgeNotifySource)
	}
	if m.notify_target != nil {
		edges = append(edges, user.EdgeNotifyTarget)
	}
	if m.notify_flow != nil {
		edges = append(edges, user.EdgeNotifyFlow)
	}
	if m.image != nil {
		edges = append(edges, user.EdgeImage)
	}
	if m.file != nil {
		edges = append(edges, user.EdgeFile)
	}
	if m.device_info != nil {
		edges = append(edges, user.EdgeDeviceInfo)
	}
	if m.tag != nil {
		edges = append(edges, user.EdgeTag)
	}
	if m.creator != nil {
		edges = append(edges, user.EdgeCreator)
	}
	if m.created_user != nil {
		edges = append(edges, user.EdgeCreatedUser)
	}
	if m.user_device != nil {
		edges = append(edges, user.EdgeUserDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBindAccount:
		ids := make([]ent.Value, 0, len(m.bind_account))
		for id := range m.bind_account {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePurchasedApp:
		ids := make([]ent.Value, 0, len(m.purchased_app))
		for id := range m.purchased_app {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApp:
		ids := make([]ent.Value, 0, len(m.app))
		for id := range m.app {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAppInst:
		ids := make([]ent.Value, 0, len(m.app_inst))
		for id := range m.app_inst {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedConfig:
		ids := make([]ent.Value, 0, len(m.feed_config))
		for id := range m.feed_config {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedActionSet:
		ids := make([]ent.Value, 0, len(m.feed_action_set))
		for id := range m.feed_action_set {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedItemCollection:
		ids := make([]ent.Value, 0, len(m.feed_item_collection))
		for id := range m.feed_item_collection {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.notify_source))
		for id := range m.notify_source {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifyTarget:
		ids := make([]ent.Value, 0, len(m.notify_target))
		for id := range m.notify_target {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.notify_flow))
		for id := range m.notify_flow {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImage:
		ids := make([]ent.Value, 0, len(m.image))
		for id := range m.image {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFile:
		ids := make([]ent.Value, 0, len(m.file))
		for id := range m.file {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceInfo:
		ids := make([]ent.Value, 0, len(m.device_info))
		for id := range m.device_info {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCreatedUser:
		ids := make([]ent.Value, 0, len(m.created_user))
		for id := range m.created_user {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserDevice:
		ids := make([]ent.Value, 0, len(m.user_device))
		for id := range m.user_device {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removedbind_account != nil {
		edges = append(edges, user.EdgeBindAccount)
	}
	if m.removedpurchased_app != nil {
		edges = append(edges, user.EdgePurchasedApp)
	}
	if m.removedapp != nil {
		edges = append(edges, user.EdgeApp)
	}
	if m.removedapp_inst != nil {
		edges = append(edges, user.EdgeAppInst)
	}
	if m.removedfeed_config != nil {
		edges = append(edges, user.EdgeFeedConfig)
	}
	if m.removedfeed_action_set != nil {
		edges = append(edges, user.EdgeFeedActionSet)
	}
	if m.removedfeed_item_collection != nil {
		edges = append(edges, user.EdgeFeedItemCollection)
	}
	if m.removednotify_source != nil {
		edges = append(edges, user.EdgeNotifySource)
	}
	if m.removednotify_target != nil {
		edges = append(edges, user.EdgeNotifyTarget)
	}
	if m.removednotify_flow != nil {
		edges = append(edges, user.EdgeNotifyFlow)
	}
	if m.removedimage != nil {
		edges = append(edges, user.EdgeImage)
	}
	if m.removedfile != nil {
		edges = append(edges, user.EdgeFile)
	}
	if m.removeddevice_info != nil {
		edges = append(edges, user.EdgeDeviceInfo)
	}
	if m.removedtag != nil {
		edges = append(edges, user.EdgeTag)
	}
	if m.removedcreated_user != nil {
		edges = append(edges, user.EdgeCreatedUser)
	}
	if m.removeduser_device != nil {
		edges = append(edges, user.EdgeUserDevice)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBindAccount:
		ids := make([]ent.Value, 0, len(m.removedbind_account))
		for id := range m.removedbind_account {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePurchasedApp:
		ids := make([]ent.Value, 0, len(m.removedpurchased_app))
		for id := range m.removedpurchased_app {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removedapp))
		for id := range m.removedapp {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAppInst:
		ids := make([]ent.Value, 0, len(m.removedapp_inst))
		for id := range m.removedapp_inst {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedConfig:
		ids := make([]ent.Value, 0, len(m.removedfeed_config))
		for id := range m.removedfeed_config {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedActionSet:
		ids := make([]ent.Value, 0, len(m.removedfeed_action_set))
		for id := range m.removedfeed_action_set {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedItemCollection:
		ids := make([]ent.Value, 0, len(m.removedfeed_item_collection))
		for id := range m.removedfeed_item_collection {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.removednotify_source))
		for id := range m.removednotify_source {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifyTarget:
		ids := make([]ent.Value, 0, len(m.removednotify_target))
		for id := range m.removednotify_target {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.removednotify_flow))
		for id := range m.removednotify_flow {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImage:
		ids := make([]ent.Value, 0, len(m.removedimage))
		for id := range m.removedimage {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFile:
		ids := make([]ent.Value, 0, len(m.removedfile))
		for id := range m.removedfile {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDeviceInfo:
		ids := make([]ent.Value, 0, len(m.removeddevice_info))
		for id := range m.removeddevice_info {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedUser:
		ids := make([]ent.Value, 0, len(m.removedcreated_user))
		for id := range m.removedcreated_user {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserDevice:
		ids := make([]ent.Value, 0, len(m.removeduser_device))
		for id := range m.removeduser_device {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.clearedbind_account {
		edges = append(edges, user.EdgeBindAccount)
	}
	if m.clearedpurchased_app {
		edges = append(edges, user.EdgePurchasedApp)
	}
	if m.clearedapp {
		edges = append(edges, user.EdgeApp)
	}
	if m.clearedapp_inst {
		edges = append(edges, user.EdgeAppInst)
	}
	if m.clearedfeed_config {
		edges = append(edges, user.EdgeFeedConfig)
	}
	if m.clearedfeed_action_set {
		edges = append(edges, user.EdgeFeedActionSet)
	}
	if m.clearedfeed_item_collection {
		edges = append(edges, user.EdgeFeedItemCollection)
	}
	if m.clearednotify_source {
		edges = append(edges, user.EdgeNotifySource)
	}
	if m.clearednotify_target {
		edges = append(edges, user.EdgeNotifyTarget)
	}
	if m.clearednotify_flow {
		edges = append(edges, user.EdgeNotifyFlow)
	}
	if m.clearedimage {
		edges = append(edges, user.EdgeImage)
	}
	if m.clearedfile {
		edges = append(edges, user.EdgeFile)
	}
	if m.cleareddevice_info {
		edges = append(edges, user.EdgeDeviceInfo)
	}
	if m.clearedtag {
		edges = append(edges, user.EdgeTag)
	}
	if m.clearedcreator {
		edges = append(edges, user.EdgeCreator)
	}
	if m.clearedcreated_user {
		edges = append(edges, user.EdgeCreatedUser)
	}
	if m.cleareduser_device {
		edges = append(edges, user.EdgeUserDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBindAccount:
		return m.clearedbind_account
	case user.EdgePurchasedApp:
		return m.clearedpurchased_app
	case user.EdgeApp:
		return m.clearedapp
	case user.EdgeAppInst:
		return m.clearedapp_inst
	case user.EdgeFeedConfig:
		return m.clearedfeed_config
	case user.EdgeFeedActionSet:
		return m.clearedfeed_action_set
	case user.EdgeFeedItemCollection:
		return m.clearedfeed_item_collection
	case user.EdgeNotifySource:
		return m.clearednotify_source
	case user.EdgeNotifyTarget:
		return m.clearednotify_target
	case user.EdgeNotifyFlow:
		return m.clearednotify_flow
	case user.EdgeImage:
		return m.clearedimage
	case user.EdgeFile:
		return m.clearedfile
	case user.EdgeDeviceInfo:
		return m.cleareddevice_info
	case user.EdgeTag:
		return m.clearedtag
	case user.EdgeCreator:
		return m.clearedcreator
	case user.EdgeCreatedUser:
		return m.clearedcreated_user
	case user.EdgeUserDevice:
		return m.cleareduser_device
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBindAccount:
		m.ResetBindAccount()
		return nil
	case user.EdgePurchasedApp:
		m.ResetPurchasedApp()
		return nil
	case user.EdgeApp:
		m.ResetApp()
		return nil
	case user.EdgeAppInst:
		m.ResetAppInst()
		return nil
	case user.EdgeFeedConfig:
		m.ResetFeedConfig()
		return nil
	case user.EdgeFeedActionSet:
		m.ResetFeedActionSet()
		return nil
	case user.EdgeFeedItemCollection:
		m.ResetFeedItemCollection()
		return nil
	case user.EdgeNotifySource:
		m.ResetNotifySource()
		return nil
	case user.EdgeNotifyTarget:
		m.ResetNotifyTarget()
		return nil
	case user.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case user.EdgeImage:
		m.ResetImage()
		return nil
	case user.EdgeFile:
		m.ResetFile()
		return nil
	case user.EdgeDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case user.EdgeTag:
		m.ResetTag()
		return nil
	case user.EdgeCreator:
		m.ResetCreator()
		return nil
	case user.EdgeCreatedUser:
		m.ResetCreatedUser()
		return nil
	case user.EdgeUserDevice:
		m.ResetUserDevice()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserDeviceMutation represents an operation that mutates the UserDevice nodes in the graph.
type UserDeviceMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	updated_at         *time.Time
	created_at         *time.Time
	clearedFields      map[string]struct{}
	device_info        *model.InternalID
	cleareddevice_info bool
	user               *model.InternalID
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*UserDevice, error)
	predicates         []predicate.UserDevice
}

var _ ent.Mutation = (*UserDeviceMutation)(nil)

// userdeviceOption allows management of the mutation configuration using functional options.
type userdeviceOption func(*UserDeviceMutation)

// newUserDeviceMutation creates new mutation for the UserDevice entity.
func newUserDeviceMutation(c config, op Op, opts ...userdeviceOption) *UserDeviceMutation {
	m := &UserDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserDeviceID sets the ID field of the mutation.
func withUserDeviceID(id int) userdeviceOption {
	return func(m *UserDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserDevice
		)
		m.oldValue = func(ctx context.Context) (*UserDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserDevice sets the old UserDevice of the mutation.
func withUserDevice(node *UserDevice) userdeviceOption {
	return func(m *UserDeviceMutation) {
		m.oldValue = func(context.Context) (*UserDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserDeviceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserDeviceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserDeviceMutation) SetUserID(mi model.InternalID) {
	m.user = &mi
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserDeviceMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserDeviceMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceID sets the "device_id" field.
func (m *UserDeviceMutation) SetDeviceID(mi model.InternalID) {
	m.device_info = &mi
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *UserDeviceMutation) DeviceID() (r model.InternalID, exists bool) {
	v := m.device_info
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldDeviceID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *UserDeviceMutation) ResetDeviceID() {
	m.device_info = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserDeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserDeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserDeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserDeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserDeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserDevice entity.
// If the UserDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserDeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserDeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeviceInfoID sets the "device_info" edge to the DeviceInfo entity by id.
func (m *UserDeviceMutation) SetDeviceInfoID(id model.InternalID) {
	m.device_info = &id
}

// ClearDeviceInfo clears the "device_info" edge to the DeviceInfo entity.
func (m *UserDeviceMutation) ClearDeviceInfo() {
	m.cleareddevice_info = true
	m.clearedFields[userdevice.FieldDeviceID] = struct{}{}
}

// DeviceInfoCleared reports if the "device_info" edge to the DeviceInfo entity was cleared.
func (m *UserDeviceMutation) DeviceInfoCleared() bool {
	return m.cleareddevice_info
}

// DeviceInfoID returns the "device_info" edge ID in the mutation.
func (m *UserDeviceMutation) DeviceInfoID() (id model.InternalID, exists bool) {
	if m.device_info != nil {
		return *m.device_info, true
	}
	return
}

// DeviceInfoIDs returns the "device_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceInfoID instead. It exists only for internal usage by the builders.
func (m *UserDeviceMutation) DeviceInfoIDs() (ids []model.InternalID) {
	if id := m.device_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeviceInfo resets all changes to the "device_info" edge.
func (m *UserDeviceMutation) ResetDeviceInfo() {
	m.device_info = nil
	m.cleareddevice_info = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserDeviceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userdevice.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserDeviceMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserDeviceMutation) UserIDs() (ids []model.InternalID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserDeviceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserDeviceMutation builder.
func (m *UserDeviceMutation) Where(ps ...predicate.UserDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserDevice).
func (m *UserDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserDeviceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user != nil {
		fields = append(fields, userdevice.FieldUserID)
	}
	if m.device_info != nil {
		fields = append(fields, userdevice.FieldDeviceID)
	}
	if m.updated_at != nil {
		fields = append(fields, userdevice.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, userdevice.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userdevice.FieldUserID:
		return m.UserID()
	case userdevice.FieldDeviceID:
		return m.DeviceID()
	case userdevice.FieldUpdatedAt:
		return m.UpdatedAt()
	case userdevice.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userdevice.FieldUserID:
		return m.OldUserID(ctx)
	case userdevice.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case userdevice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userdevice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userdevice.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userdevice.FieldDeviceID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case userdevice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userdevice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserDeviceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserDeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserDeviceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserDeviceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserDeviceMutation) ResetField(name string) error {
	switch name {
	case userdevice.FieldUserID:
		m.ResetUserID()
		return nil
	case userdevice.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case userdevice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userdevice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.device_info != nil {
		edges = append(edges, userdevice.EdgeDeviceInfo)
	}
	if m.user != nil {
		edges = append(edges, userdevice.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserDeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userdevice.EdgeDeviceInfo:
		if id := m.device_info; id != nil {
			return []ent.Value{*id}
		}
	case userdevice.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserDeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddevice_info {
		edges = append(edges, userdevice.EdgeDeviceInfo)
	}
	if m.cleareduser {
		edges = append(edges, userdevice.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserDeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case userdevice.EdgeDeviceInfo:
		return m.cleareddevice_info
	case userdevice.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserDeviceMutation) ClearEdge(name string) error {
	switch name {
	case userdevice.EdgeDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	case userdevice.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserDeviceMutation) ResetEdge(name string) error {
	switch name {
	case userdevice.EdgeDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	case userdevice.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserDevice edge %s", name)
}

// UserSessionMutation represents an operation that mutates the UserSession nodes in the graph.
type UserSessionMutation struct {
	config
	op                 Op
	typ                string
	id                 *model.InternalID
	user_id            *model.InternalID
	adduser_id         *model.InternalID
	refresh_token      *string
	expire_at          *time.Time
	updated_at         *time.Time
	created_at         *time.Time
	clearedFields      map[string]struct{}
	device_info        *model.InternalID
	cleareddevice_info bool
	done               bool
	oldValue           func(context.Context) (*UserSession, error)
	predicates         []predicate.UserSession
}

var _ ent.Mutation = (*UserSessionMutation)(nil)

// usersessionOption allows management of the mutation configuration using functional options.
type usersessionOption func(*UserSessionMutation)

// newUserSessionMutation creates new mutation for the UserSession entity.
func newUserSessionMutation(c config, op Op, opts ...usersessionOption) *UserSessionMutation {
	m := &UserSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSessionID sets the ID field of the mutation.
func withUserSessionID(id model.InternalID) usersessionOption {
	return func(m *UserSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSession
		)
		m.oldValue = func(ctx context.Context) (*UserSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSession sets the old UserSession of the mutation.
func withUserSession(node *UserSession) usersessionOption {
	return func(m *UserSessionMutation) {
		m.oldValue = func(context.Context) (*UserSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSession entities.
func (m *UserSessionMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSessionMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSessionMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserSessionMutation) SetUserID(mi model.InternalID) {
	m.user_id = &mi
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSessionMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds mi to the "user_id" field.
func (m *UserSessionMutation) AddUserID(mi model.InternalID) {
	if m.adduser_id != nil {
		*m.adduser_id += mi
	} else {
		m.adduser_id = &mi
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserSessionMutation) AddedUserID() (r model.InternalID, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSessionMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetRefreshToken sets the "refresh_token" field.
func (m *UserSessionMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *UserSessionMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *UserSessionMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetExpireAt sets the "expire_at" field.
func (m *UserSessionMutation) SetExpireAt(t time.Time) {
	m.expire_at = &t
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *UserSessionMutation) ExpireAt() (r time.Time, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldExpireAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *UserSessionMutation) ResetExpireAt() {
	m.expire_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeviceInfoID sets the "device_info" edge to the DeviceInfo entity by id.
func (m *UserSessionMutation) SetDeviceInfoID(id model.InternalID) {
	m.device_info = &id
}

// ClearDeviceInfo clears the "device_info" edge to the DeviceInfo entity.
func (m *UserSessionMutation) ClearDeviceInfo() {
	m.cleareddevice_info = true
}

// DeviceInfoCleared reports if the "device_info" edge to the DeviceInfo entity was cleared.
func (m *UserSessionMutation) DeviceInfoCleared() bool {
	return m.cleareddevice_info
}

// DeviceInfoID returns the "device_info" edge ID in the mutation.
func (m *UserSessionMutation) DeviceInfoID() (id model.InternalID, exists bool) {
	if m.device_info != nil {
		return *m.device_info, true
	}
	return
}

// DeviceInfoIDs returns the "device_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceInfoID instead. It exists only for internal usage by the builders.
func (m *UserSessionMutation) DeviceInfoIDs() (ids []model.InternalID) {
	if id := m.device_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeviceInfo resets all changes to the "device_info" edge.
func (m *UserSessionMutation) ResetDeviceInfo() {
	m.device_info = nil
	m.cleareddevice_info = false
}

// Where appends a list predicates to the UserSessionMutation builder.
func (m *UserSessionMutation) Where(ps ...predicate.UserSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSession).
func (m *UserSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSessionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user_id != nil {
		fields = append(fields, usersession.FieldUserID)
	}
	if m.refresh_token != nil {
		fields = append(fields, usersession.FieldRefreshToken)
	}
	if m.expire_at != nil {
		fields = append(fields, usersession.FieldExpireAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersession.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, usersession.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersession.FieldUserID:
		return m.UserID()
	case usersession.FieldRefreshToken:
		return m.RefreshToken()
	case usersession.FieldExpireAt:
		return m.ExpireAt()
	case usersession.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersession.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersession.FieldUserID:
		return m.OldUserID(ctx)
	case usersession.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case usersession.FieldExpireAt:
		return m.OldExpireAt(ctx)
	case usersession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersession.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersession.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case usersession.FieldExpireAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	case usersession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSessionMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, usersession.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usersession.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usersession.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSessionMutation) ResetField(name string) error {
	switch name {
	case usersession.FieldUserID:
		m.ResetUserID()
		return nil
	case usersession.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case usersession.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	case usersession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.device_info != nil {
		edges = append(edges, usersession.EdgeDeviceInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersession.EdgeDeviceInfo:
		if id := m.device_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddevice_info {
		edges = append(edges, usersession.EdgeDeviceInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersession.EdgeDeviceInfo:
		return m.cleareddevice_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSessionMutation) ClearEdge(name string) error {
	switch name {
	case usersession.EdgeDeviceInfo:
		m.ClearDeviceInfo()
		return nil
	}
	return fmt.Errorf("unknown UserSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSessionMutation) ResetEdge(name string) error {
	switch name {
	case usersession.EdgeDeviceInfo:
		m.ResetDeviceInfo()
		return nil
	}
	return fmt.Errorf("unknown UserSession edge %s", name)
}
