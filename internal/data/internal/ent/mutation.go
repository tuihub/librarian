// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/tuihub/librarian/internal/data/internal/ent/account"
	"github.com/tuihub/librarian/internal/data/internal/ent/app"
	"github.com/tuihub/librarian/internal/data/internal/ent/appappcategory"
	"github.com/tuihub/librarian/internal/data/internal/ent/appcategory"
	"github.com/tuihub/librarian/internal/data/internal/ent/appinfo"
	"github.com/tuihub/librarian/internal/data/internal/ent/appruntime"
	"github.com/tuihub/librarian/internal/data/internal/ent/device"
	"github.com/tuihub/librarian/internal/data/internal/ent/feed"
	"github.com/tuihub/librarian/internal/data/internal/ent/feedactionset"
	"github.com/tuihub/librarian/internal/data/internal/ent/feedconfig"
	"github.com/tuihub/librarian/internal/data/internal/ent/feedconfigaction"
	"github.com/tuihub/librarian/internal/data/internal/ent/feeditem"
	"github.com/tuihub/librarian/internal/data/internal/ent/feeditemcollection"
	"github.com/tuihub/librarian/internal/data/internal/ent/file"
	"github.com/tuihub/librarian/internal/data/internal/ent/image"
	"github.com/tuihub/librarian/internal/data/internal/ent/notifyflow"
	"github.com/tuihub/librarian/internal/data/internal/ent/notifyflowsource"
	"github.com/tuihub/librarian/internal/data/internal/ent/notifyflowtarget"
	"github.com/tuihub/librarian/internal/data/internal/ent/notifysource"
	"github.com/tuihub/librarian/internal/data/internal/ent/notifytarget"
	"github.com/tuihub/librarian/internal/data/internal/ent/portercontext"
	"github.com/tuihub/librarian/internal/data/internal/ent/porterinstance"
	"github.com/tuihub/librarian/internal/data/internal/ent/predicate"
	"github.com/tuihub/librarian/internal/data/internal/ent/sentinelappbinary"
	"github.com/tuihub/librarian/internal/data/internal/ent/sentinelappbinaryfile"
	"github.com/tuihub/librarian/internal/data/internal/ent/sentinelinfo"
	"github.com/tuihub/librarian/internal/data/internal/ent/sentinellibrary"
	"github.com/tuihub/librarian/internal/data/internal/ent/session"
	"github.com/tuihub/librarian/internal/data/internal/ent/storeapp"
	"github.com/tuihub/librarian/internal/data/internal/ent/storeappbinary"
	"github.com/tuihub/librarian/internal/data/internal/ent/systemnotification"
	"github.com/tuihub/librarian/internal/data/internal/ent/tag"
	"github.com/tuihub/librarian/internal/data/internal/ent/user"
	"github.com/tuihub/librarian/internal/model"
	"github.com/tuihub/librarian/internal/model/modelfeed"
	"github.com/tuihub/librarian/internal/model/modelsupervisor"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount               = "Account"
	TypeApp                   = "App"
	TypeAppAppCategory        = "AppAppCategory"
	TypeAppCategory           = "AppCategory"
	TypeAppInfo               = "AppInfo"
	TypeAppRunTime            = "AppRunTime"
	TypeDevice                = "Device"
	TypeFeed                  = "Feed"
	TypeFeedActionSet         = "FeedActionSet"
	TypeFeedConfig            = "FeedConfig"
	TypeFeedConfigAction      = "FeedConfigAction"
	TypeFeedItem              = "FeedItem"
	TypeFeedItemCollection    = "FeedItemCollection"
	TypeFile                  = "File"
	TypeImage                 = "Image"
	TypeNotifyFlow            = "NotifyFlow"
	TypeNotifyFlowSource      = "NotifyFlowSource"
	TypeNotifyFlowTarget      = "NotifyFlowTarget"
	TypeNotifySource          = "NotifySource"
	TypeNotifyTarget          = "NotifyTarget"
	TypePorterContext         = "PorterContext"
	TypePorterInstance        = "PorterInstance"
	TypeSentinelAppBinary     = "SentinelAppBinary"
	TypeSentinelAppBinaryFile = "SentinelAppBinaryFile"
	TypeSentinelInfo          = "SentinelInfo"
	TypeSentinelLibrary       = "SentinelLibrary"
	TypeSession               = "Session"
	TypeStoreApp              = "StoreApp"
	TypeStoreAppBinary        = "StoreAppBinary"
	TypeSystemNotification    = "SystemNotification"
	TypeTag                   = "Tag"
	TypeUser                  = "User"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                  Op
	typ                 string
	id                  *model.InternalID
	platform            *string
	platform_account_id *string
	name                *string
	profile_url         *string
	avatar_url          *string
	updated_at          *time.Time
	created_at          *time.Time
	clearedFields       map[string]struct{}
	bound_user          *model.InternalID
	clearedbound_user   bool
	done                bool
	oldValue            func(context.Context) (*Account, error)
	predicates          []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id model.InternalID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlatform sets the "platform" field.
func (m *AccountMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *AccountMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *AccountMutation) ResetPlatform() {
	m.platform = nil
}

// SetPlatformAccountID sets the "platform_account_id" field.
func (m *AccountMutation) SetPlatformAccountID(s string) {
	m.platform_account_id = &s
}

// PlatformAccountID returns the value of the "platform_account_id" field in the mutation.
func (m *AccountMutation) PlatformAccountID() (r string, exists bool) {
	v := m.platform_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformAccountID returns the old "platform_account_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPlatformAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformAccountID: %w", err)
	}
	return oldValue.PlatformAccountID, nil
}

// ResetPlatformAccountID resets all changes to the "platform_account_id" field.
func (m *AccountMutation) ResetPlatformAccountID() {
	m.platform_account_id = nil
}

// SetBoundUserID sets the "bound_user_id" field.
func (m *AccountMutation) SetBoundUserID(mi model.InternalID) {
	m.bound_user = &mi
}

// BoundUserID returns the value of the "bound_user_id" field in the mutation.
func (m *AccountMutation) BoundUserID() (r model.InternalID, exists bool) {
	v := m.bound_user
	if v == nil {
		return
	}
	return *v, true
}

// OldBoundUserID returns the old "bound_user_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldBoundUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoundUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoundUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoundUserID: %w", err)
	}
	return oldValue.BoundUserID, nil
}

// ClearBoundUserID clears the value of the "bound_user_id" field.
func (m *AccountMutation) ClearBoundUserID() {
	m.bound_user = nil
	m.clearedFields[account.FieldBoundUserID] = struct{}{}
}

// BoundUserIDCleared returns if the "bound_user_id" field was cleared in this mutation.
func (m *AccountMutation) BoundUserIDCleared() bool {
	_, ok := m.clearedFields[account.FieldBoundUserID]
	return ok
}

// ResetBoundUserID resets all changes to the "bound_user_id" field.
func (m *AccountMutation) ResetBoundUserID() {
	m.bound_user = nil
	delete(m.clearedFields, account.FieldBoundUserID)
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetProfileURL sets the "profile_url" field.
func (m *AccountMutation) SetProfileURL(s string) {
	m.profile_url = &s
}

// ProfileURL returns the value of the "profile_url" field in the mutation.
func (m *AccountMutation) ProfileURL() (r string, exists bool) {
	v := m.profile_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileURL returns the old "profile_url" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldProfileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileURL: %w", err)
	}
	return oldValue.ProfileURL, nil
}

// ResetProfileURL resets all changes to the "profile_url" field.
func (m *AccountMutation) ResetProfileURL() {
	m.profile_url = nil
}

// SetAvatarURL sets the "avatar_url" field.
func (m *AccountMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *AccountMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *AccountMutation) ResetAvatarURL() {
	m.avatar_url = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearBoundUser clears the "bound_user" edge to the User entity.
func (m *AccountMutation) ClearBoundUser() {
	m.clearedbound_user = true
	m.clearedFields[account.FieldBoundUserID] = struct{}{}
}

// BoundUserCleared reports if the "bound_user" edge to the User entity was cleared.
func (m *AccountMutation) BoundUserCleared() bool {
	return m.BoundUserIDCleared() || m.clearedbound_user
}

// BoundUserIDs returns the "bound_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BoundUserID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) BoundUserIDs() (ids []model.InternalID) {
	if id := m.bound_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBoundUser resets all changes to the "bound_user" edge.
func (m *AccountMutation) ResetBoundUser() {
	m.bound_user = nil
	m.clearedbound_user = false
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.platform != nil {
		fields = append(fields, account.FieldPlatform)
	}
	if m.platform_account_id != nil {
		fields = append(fields, account.FieldPlatformAccountID)
	}
	if m.bound_user != nil {
		fields = append(fields, account.FieldBoundUserID)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.profile_url != nil {
		fields = append(fields, account.FieldProfileURL)
	}
	if m.avatar_url != nil {
		fields = append(fields, account.FieldAvatarURL)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldPlatform:
		return m.Platform()
	case account.FieldPlatformAccountID:
		return m.PlatformAccountID()
	case account.FieldBoundUserID:
		return m.BoundUserID()
	case account.FieldName:
		return m.Name()
	case account.FieldProfileURL:
		return m.ProfileURL()
	case account.FieldAvatarURL:
		return m.AvatarURL()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldPlatform:
		return m.OldPlatform(ctx)
	case account.FieldPlatformAccountID:
		return m.OldPlatformAccountID(ctx)
	case account.FieldBoundUserID:
		return m.OldBoundUserID(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldProfileURL:
		return m.OldProfileURL(ctx)
	case account.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case account.FieldPlatformAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformAccountID(v)
		return nil
	case account.FieldBoundUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoundUserID(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldProfileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileURL(v)
		return nil
	case account.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldBoundUserID) {
		fields = append(fields, account.FieldBoundUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldBoundUserID:
		m.ClearBoundUserID()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldPlatform:
		m.ResetPlatform()
		return nil
	case account.FieldPlatformAccountID:
		m.ResetPlatformAccountID()
		return nil
	case account.FieldBoundUserID:
		m.ResetBoundUserID()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldProfileURL:
		m.ResetProfileURL()
		return nil
	case account.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bound_user != nil {
		edges = append(edges, account.EdgeBoundUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeBoundUser:
		if id := m.bound_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbound_user {
		edges = append(edges, account.EdgeBoundUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeBoundUser:
		return m.clearedbound_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeBoundUser:
		m.ClearBoundUser()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeBoundUser:
		m.ResetBoundUser()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                      Op
	typ                     string
	id                      *model.InternalID
	version_number          *uint64
	addversion_number       *int64
	version_date            *time.Time
	app_sources             *map[string]string
	public                  *bool
	bound_store_app_id      *model.InternalID
	addbound_store_app_id   *model.InternalID
	stop_store_manage       *bool
	name                    *string
	_type                   *app.Type
	short_description       *string
	description             *string
	icon_image_url          *string
	icon_image_id           *model.InternalID
	addicon_image_id        *model.InternalID
	background_image_url    *string
	background_image_id     *model.InternalID
	addbackground_image_id  *model.InternalID
	cover_image_url         *string
	cover_image_id          *model.InternalID
	addcover_image_id       *model.InternalID
	release_date            *string
	developer               *string
	publisher               *string
	tags                    *[]string
	appendtags              []string
	alternative_names       *[]string
	appendalternative_names []string
	updated_at              *time.Time
	created_at              *time.Time
	clearedFields           map[string]struct{}
	user                    *model.InternalID
	cleareduser             bool
	device                  *model.InternalID
	cleareddevice           bool
	app_run_time            map[model.InternalID]struct{}
	removedapp_run_time     map[model.InternalID]struct{}
	clearedapp_run_time     bool
	app_category            map[model.InternalID]struct{}
	removedapp_category     map[model.InternalID]struct{}
	clearedapp_category     bool
	app_app_category        map[int]struct{}
	removedapp_app_category map[int]struct{}
	clearedapp_app_category bool
	done                    bool
	oldValue                func(context.Context) (*App, error)
	predicates              []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id model.InternalID) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVersionNumber sets the "version_number" field.
func (m *AppMutation) SetVersionNumber(u uint64) {
	m.version_number = &u
	m.addversion_number = nil
}

// VersionNumber returns the value of the "version_number" field in the mutation.
func (m *AppMutation) VersionNumber() (r uint64, exists bool) {
	v := m.version_number
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionNumber returns the old "version_number" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldVersionNumber(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionNumber: %w", err)
	}
	return oldValue.VersionNumber, nil
}

// AddVersionNumber adds u to the "version_number" field.
func (m *AppMutation) AddVersionNumber(u int64) {
	if m.addversion_number != nil {
		*m.addversion_number += u
	} else {
		m.addversion_number = &u
	}
}

// AddedVersionNumber returns the value that was added to the "version_number" field in this mutation.
func (m *AppMutation) AddedVersionNumber() (r int64, exists bool) {
	v := m.addversion_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionNumber resets all changes to the "version_number" field.
func (m *AppMutation) ResetVersionNumber() {
	m.version_number = nil
	m.addversion_number = nil
}

// SetVersionDate sets the "version_date" field.
func (m *AppMutation) SetVersionDate(t time.Time) {
	m.version_date = &t
}

// VersionDate returns the value of the "version_date" field in the mutation.
func (m *AppMutation) VersionDate() (r time.Time, exists bool) {
	v := m.version_date
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionDate returns the old "version_date" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldVersionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionDate: %w", err)
	}
	return oldValue.VersionDate, nil
}

// ResetVersionDate resets all changes to the "version_date" field.
func (m *AppMutation) ResetVersionDate() {
	m.version_date = nil
}

// SetUserID sets the "user_id" field.
func (m *AppMutation) SetUserID(mi model.InternalID) {
	m.user = &mi
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppMutation) ResetUserID() {
	m.user = nil
}

// SetCreatorDeviceID sets the "creator_device_id" field.
func (m *AppMutation) SetCreatorDeviceID(mi model.InternalID) {
	m.device = &mi
}

// CreatorDeviceID returns the value of the "creator_device_id" field in the mutation.
func (m *AppMutation) CreatorDeviceID() (r model.InternalID, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorDeviceID returns the old "creator_device_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatorDeviceID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorDeviceID: %w", err)
	}
	return oldValue.CreatorDeviceID, nil
}

// ResetCreatorDeviceID resets all changes to the "creator_device_id" field.
func (m *AppMutation) ResetCreatorDeviceID() {
	m.device = nil
}

// SetAppSources sets the "app_sources" field.
func (m *AppMutation) SetAppSources(value map[string]string) {
	m.app_sources = &value
}

// AppSources returns the value of the "app_sources" field in the mutation.
func (m *AppMutation) AppSources() (r map[string]string, exists bool) {
	v := m.app_sources
	if v == nil {
		return
	}
	return *v, true
}

// OldAppSources returns the old "app_sources" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAppSources(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppSources is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppSources requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppSources: %w", err)
	}
	return oldValue.AppSources, nil
}

// ResetAppSources resets all changes to the "app_sources" field.
func (m *AppMutation) ResetAppSources() {
	m.app_sources = nil
}

// SetPublic sets the "public" field.
func (m *AppMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *AppMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *AppMutation) ResetPublic() {
	m.public = nil
}

// SetBoundStoreAppID sets the "bound_store_app_id" field.
func (m *AppMutation) SetBoundStoreAppID(mi model.InternalID) {
	m.bound_store_app_id = &mi
	m.addbound_store_app_id = nil
}

// BoundStoreAppID returns the value of the "bound_store_app_id" field in the mutation.
func (m *AppMutation) BoundStoreAppID() (r model.InternalID, exists bool) {
	v := m.bound_store_app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBoundStoreAppID returns the old "bound_store_app_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldBoundStoreAppID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoundStoreAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoundStoreAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoundStoreAppID: %w", err)
	}
	return oldValue.BoundStoreAppID, nil
}

// AddBoundStoreAppID adds mi to the "bound_store_app_id" field.
func (m *AppMutation) AddBoundStoreAppID(mi model.InternalID) {
	if m.addbound_store_app_id != nil {
		*m.addbound_store_app_id += mi
	} else {
		m.addbound_store_app_id = &mi
	}
}

// AddedBoundStoreAppID returns the value that was added to the "bound_store_app_id" field in this mutation.
func (m *AppMutation) AddedBoundStoreAppID() (r model.InternalID, exists bool) {
	v := m.addbound_store_app_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearBoundStoreAppID clears the value of the "bound_store_app_id" field.
func (m *AppMutation) ClearBoundStoreAppID() {
	m.bound_store_app_id = nil
	m.addbound_store_app_id = nil
	m.clearedFields[app.FieldBoundStoreAppID] = struct{}{}
}

// BoundStoreAppIDCleared returns if the "bound_store_app_id" field was cleared in this mutation.
func (m *AppMutation) BoundStoreAppIDCleared() bool {
	_, ok := m.clearedFields[app.FieldBoundStoreAppID]
	return ok
}

// ResetBoundStoreAppID resets all changes to the "bound_store_app_id" field.
func (m *AppMutation) ResetBoundStoreAppID() {
	m.bound_store_app_id = nil
	m.addbound_store_app_id = nil
	delete(m.clearedFields, app.FieldBoundStoreAppID)
}

// SetStopStoreManage sets the "stop_store_manage" field.
func (m *AppMutation) SetStopStoreManage(b bool) {
	m.stop_store_manage = &b
}

// StopStoreManage returns the value of the "stop_store_manage" field in the mutation.
func (m *AppMutation) StopStoreManage() (r bool, exists bool) {
	v := m.stop_store_manage
	if v == nil {
		return
	}
	return *v, true
}

// OldStopStoreManage returns the old "stop_store_manage" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldStopStoreManage(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStopStoreManage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStopStoreManage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStopStoreManage: %w", err)
	}
	return oldValue.StopStoreManage, nil
}

// ClearStopStoreManage clears the value of the "stop_store_manage" field.
func (m *AppMutation) ClearStopStoreManage() {
	m.stop_store_manage = nil
	m.clearedFields[app.FieldStopStoreManage] = struct{}{}
}

// StopStoreManageCleared returns if the "stop_store_manage" field was cleared in this mutation.
func (m *AppMutation) StopStoreManageCleared() bool {
	_, ok := m.clearedFields[app.FieldStopStoreManage]
	return ok
}

// ResetStopStoreManage resets all changes to the "stop_store_manage" field.
func (m *AppMutation) ResetStopStoreManage() {
	m.stop_store_manage = nil
	delete(m.clearedFields, app.FieldStopStoreManage)
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *AppMutation) SetType(a app.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AppMutation) GetType() (r app.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldType(ctx context.Context) (v app.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AppMutation) ResetType() {
	m._type = nil
}

// SetShortDescription sets the "short_description" field.
func (m *AppMutation) SetShortDescription(s string) {
	m.short_description = &s
}

// ShortDescription returns the value of the "short_description" field in the mutation.
func (m *AppMutation) ShortDescription() (r string, exists bool) {
	v := m.short_description
	if v == nil {
		return
	}
	return *v, true
}

// OldShortDescription returns the old "short_description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldShortDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortDescription: %w", err)
	}
	return oldValue.ShortDescription, nil
}

// ClearShortDescription clears the value of the "short_description" field.
func (m *AppMutation) ClearShortDescription() {
	m.short_description = nil
	m.clearedFields[app.FieldShortDescription] = struct{}{}
}

// ShortDescriptionCleared returns if the "short_description" field was cleared in this mutation.
func (m *AppMutation) ShortDescriptionCleared() bool {
	_, ok := m.clearedFields[app.FieldShortDescription]
	return ok
}

// ResetShortDescription resets all changes to the "short_description" field.
func (m *AppMutation) ResetShortDescription() {
	m.short_description = nil
	delete(m.clearedFields, app.FieldShortDescription)
}

// SetDescription sets the "description" field.
func (m *AppMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AppMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[app.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AppMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[app.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AppMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, app.FieldDescription)
}

// SetIconImageURL sets the "icon_image_url" field.
func (m *AppMutation) SetIconImageURL(s string) {
	m.icon_image_url = &s
}

// IconImageURL returns the value of the "icon_image_url" field in the mutation.
func (m *AppMutation) IconImageURL() (r string, exists bool) {
	v := m.icon_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconImageURL returns the old "icon_image_url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldIconImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconImageURL: %w", err)
	}
	return oldValue.IconImageURL, nil
}

// ClearIconImageURL clears the value of the "icon_image_url" field.
func (m *AppMutation) ClearIconImageURL() {
	m.icon_image_url = nil
	m.clearedFields[app.FieldIconImageURL] = struct{}{}
}

// IconImageURLCleared returns if the "icon_image_url" field was cleared in this mutation.
func (m *AppMutation) IconImageURLCleared() bool {
	_, ok := m.clearedFields[app.FieldIconImageURL]
	return ok
}

// ResetIconImageURL resets all changes to the "icon_image_url" field.
func (m *AppMutation) ResetIconImageURL() {
	m.icon_image_url = nil
	delete(m.clearedFields, app.FieldIconImageURL)
}

// SetIconImageID sets the "icon_image_id" field.
func (m *AppMutation) SetIconImageID(mi model.InternalID) {
	m.icon_image_id = &mi
	m.addicon_image_id = nil
}

// IconImageID returns the value of the "icon_image_id" field in the mutation.
func (m *AppMutation) IconImageID() (r model.InternalID, exists bool) {
	v := m.icon_image_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIconImageID returns the old "icon_image_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldIconImageID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconImageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconImageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconImageID: %w", err)
	}
	return oldValue.IconImageID, nil
}

// AddIconImageID adds mi to the "icon_image_id" field.
func (m *AppMutation) AddIconImageID(mi model.InternalID) {
	if m.addicon_image_id != nil {
		*m.addicon_image_id += mi
	} else {
		m.addicon_image_id = &mi
	}
}

// AddedIconImageID returns the value that was added to the "icon_image_id" field in this mutation.
func (m *AppMutation) AddedIconImageID() (r model.InternalID, exists bool) {
	v := m.addicon_image_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetIconImageID resets all changes to the "icon_image_id" field.
func (m *AppMutation) ResetIconImageID() {
	m.icon_image_id = nil
	m.addicon_image_id = nil
}

// SetBackgroundImageURL sets the "background_image_url" field.
func (m *AppMutation) SetBackgroundImageURL(s string) {
	m.background_image_url = &s
}

// BackgroundImageURL returns the value of the "background_image_url" field in the mutation.
func (m *AppMutation) BackgroundImageURL() (r string, exists bool) {
	v := m.background_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundImageURL returns the old "background_image_url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldBackgroundImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundImageURL: %w", err)
	}
	return oldValue.BackgroundImageURL, nil
}

// ClearBackgroundImageURL clears the value of the "background_image_url" field.
func (m *AppMutation) ClearBackgroundImageURL() {
	m.background_image_url = nil
	m.clearedFields[app.FieldBackgroundImageURL] = struct{}{}
}

// BackgroundImageURLCleared returns if the "background_image_url" field was cleared in this mutation.
func (m *AppMutation) BackgroundImageURLCleared() bool {
	_, ok := m.clearedFields[app.FieldBackgroundImageURL]
	return ok
}

// ResetBackgroundImageURL resets all changes to the "background_image_url" field.
func (m *AppMutation) ResetBackgroundImageURL() {
	m.background_image_url = nil
	delete(m.clearedFields, app.FieldBackgroundImageURL)
}

// SetBackgroundImageID sets the "background_image_id" field.
func (m *AppMutation) SetBackgroundImageID(mi model.InternalID) {
	m.background_image_id = &mi
	m.addbackground_image_id = nil
}

// BackgroundImageID returns the value of the "background_image_id" field in the mutation.
func (m *AppMutation) BackgroundImageID() (r model.InternalID, exists bool) {
	v := m.background_image_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundImageID returns the old "background_image_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldBackgroundImageID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundImageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundImageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundImageID: %w", err)
	}
	return oldValue.BackgroundImageID, nil
}

// AddBackgroundImageID adds mi to the "background_image_id" field.
func (m *AppMutation) AddBackgroundImageID(mi model.InternalID) {
	if m.addbackground_image_id != nil {
		*m.addbackground_image_id += mi
	} else {
		m.addbackground_image_id = &mi
	}
}

// AddedBackgroundImageID returns the value that was added to the "background_image_id" field in this mutation.
func (m *AppMutation) AddedBackgroundImageID() (r model.InternalID, exists bool) {
	v := m.addbackground_image_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBackgroundImageID resets all changes to the "background_image_id" field.
func (m *AppMutation) ResetBackgroundImageID() {
	m.background_image_id = nil
	m.addbackground_image_id = nil
}

// SetCoverImageURL sets the "cover_image_url" field.
func (m *AppMutation) SetCoverImageURL(s string) {
	m.cover_image_url = &s
}

// CoverImageURL returns the value of the "cover_image_url" field in the mutation.
func (m *AppMutation) CoverImageURL() (r string, exists bool) {
	v := m.cover_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImageURL returns the old "cover_image_url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCoverImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImageURL: %w", err)
	}
	return oldValue.CoverImageURL, nil
}

// ClearCoverImageURL clears the value of the "cover_image_url" field.
func (m *AppMutation) ClearCoverImageURL() {
	m.cover_image_url = nil
	m.clearedFields[app.FieldCoverImageURL] = struct{}{}
}

// CoverImageURLCleared returns if the "cover_image_url" field was cleared in this mutation.
func (m *AppMutation) CoverImageURLCleared() bool {
	_, ok := m.clearedFields[app.FieldCoverImageURL]
	return ok
}

// ResetCoverImageURL resets all changes to the "cover_image_url" field.
func (m *AppMutation) ResetCoverImageURL() {
	m.cover_image_url = nil
	delete(m.clearedFields, app.FieldCoverImageURL)
}

// SetCoverImageID sets the "cover_image_id" field.
func (m *AppMutation) SetCoverImageID(mi model.InternalID) {
	m.cover_image_id = &mi
	m.addcover_image_id = nil
}

// CoverImageID returns the value of the "cover_image_id" field in the mutation.
func (m *AppMutation) CoverImageID() (r model.InternalID, exists bool) {
	v := m.cover_image_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImageID returns the old "cover_image_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCoverImageID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImageID: %w", err)
	}
	return oldValue.CoverImageID, nil
}

// AddCoverImageID adds mi to the "cover_image_id" field.
func (m *AppMutation) AddCoverImageID(mi model.InternalID) {
	if m.addcover_image_id != nil {
		*m.addcover_image_id += mi
	} else {
		m.addcover_image_id = &mi
	}
}

// AddedCoverImageID returns the value that was added to the "cover_image_id" field in this mutation.
func (m *AppMutation) AddedCoverImageID() (r model.InternalID, exists bool) {
	v := m.addcover_image_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoverImageID resets all changes to the "cover_image_id" field.
func (m *AppMutation) ResetCoverImageID() {
	m.cover_image_id = nil
	m.addcover_image_id = nil
}

// SetReleaseDate sets the "release_date" field.
func (m *AppMutation) SetReleaseDate(s string) {
	m.release_date = &s
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *AppMutation) ReleaseDate() (r string, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldReleaseDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ClearReleaseDate clears the value of the "release_date" field.
func (m *AppMutation) ClearReleaseDate() {
	m.release_date = nil
	m.clearedFields[app.FieldReleaseDate] = struct{}{}
}

// ReleaseDateCleared returns if the "release_date" field was cleared in this mutation.
func (m *AppMutation) ReleaseDateCleared() bool {
	_, ok := m.clearedFields[app.FieldReleaseDate]
	return ok
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *AppMutation) ResetReleaseDate() {
	m.release_date = nil
	delete(m.clearedFields, app.FieldReleaseDate)
}

// SetDeveloper sets the "developer" field.
func (m *AppMutation) SetDeveloper(s string) {
	m.developer = &s
}

// Developer returns the value of the "developer" field in the mutation.
func (m *AppMutation) Developer() (r string, exists bool) {
	v := m.developer
	if v == nil {
		return
	}
	return *v, true
}

// OldDeveloper returns the old "developer" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDeveloper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeveloper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeveloper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeveloper: %w", err)
	}
	return oldValue.Developer, nil
}

// ClearDeveloper clears the value of the "developer" field.
func (m *AppMutation) ClearDeveloper() {
	m.developer = nil
	m.clearedFields[app.FieldDeveloper] = struct{}{}
}

// DeveloperCleared returns if the "developer" field was cleared in this mutation.
func (m *AppMutation) DeveloperCleared() bool {
	_, ok := m.clearedFields[app.FieldDeveloper]
	return ok
}

// ResetDeveloper resets all changes to the "developer" field.
func (m *AppMutation) ResetDeveloper() {
	m.developer = nil
	delete(m.clearedFields, app.FieldDeveloper)
}

// SetPublisher sets the "publisher" field.
func (m *AppMutation) SetPublisher(s string) {
	m.publisher = &s
}

// Publisher returns the value of the "publisher" field in the mutation.
func (m *AppMutation) Publisher() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisher returns the old "publisher" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldPublisher(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisher: %w", err)
	}
	return oldValue.Publisher, nil
}

// ClearPublisher clears the value of the "publisher" field.
func (m *AppMutation) ClearPublisher() {
	m.publisher = nil
	m.clearedFields[app.FieldPublisher] = struct{}{}
}

// PublisherCleared returns if the "publisher" field was cleared in this mutation.
func (m *AppMutation) PublisherCleared() bool {
	_, ok := m.clearedFields[app.FieldPublisher]
	return ok
}

// ResetPublisher resets all changes to the "publisher" field.
func (m *AppMutation) ResetPublisher() {
	m.publisher = nil
	delete(m.clearedFields, app.FieldPublisher)
}

// SetTags sets the "tags" field.
func (m *AppMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *AppMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *AppMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *AppMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *AppMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetAlternativeNames sets the "alternative_names" field.
func (m *AppMutation) SetAlternativeNames(s []string) {
	m.alternative_names = &s
	m.appendalternative_names = nil
}

// AlternativeNames returns the value of the "alternative_names" field in the mutation.
func (m *AppMutation) AlternativeNames() (r []string, exists bool) {
	v := m.alternative_names
	if v == nil {
		return
	}
	return *v, true
}

// OldAlternativeNames returns the old "alternative_names" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAlternativeNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlternativeNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlternativeNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlternativeNames: %w", err)
	}
	return oldValue.AlternativeNames, nil
}

// AppendAlternativeNames adds s to the "alternative_names" field.
func (m *AppMutation) AppendAlternativeNames(s []string) {
	m.appendalternative_names = append(m.appendalternative_names, s...)
}

// AppendedAlternativeNames returns the list of values that were appended to the "alternative_names" field in this mutation.
func (m *AppMutation) AppendedAlternativeNames() ([]string, bool) {
	if len(m.appendalternative_names) == 0 {
		return nil, false
	}
	return m.appendalternative_names, true
}

// ResetAlternativeNames resets all changes to the "alternative_names" field.
func (m *AppMutation) ResetAlternativeNames() {
	m.alternative_names = nil
	m.appendalternative_names = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *AppMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[app.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AppMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AppMutation) UserIDs() (ids []model.InternalID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AppMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetDeviceID sets the "device" edge to the Device entity by id.
func (m *AppMutation) SetDeviceID(id model.InternalID) {
	m.device = &id
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *AppMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[app.FieldCreatorDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *AppMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// DeviceID returns the "device" edge ID in the mutation.
func (m *AppMutation) DeviceID() (id model.InternalID, exists bool) {
	if m.device != nil {
		return *m.device, true
	}
	return
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *AppMutation) DeviceIDs() (ids []model.InternalID) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *AppMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// AddAppRunTimeIDs adds the "app_run_time" edge to the AppRunTime entity by ids.
func (m *AppMutation) AddAppRunTimeIDs(ids ...model.InternalID) {
	if m.app_run_time == nil {
		m.app_run_time = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.app_run_time[ids[i]] = struct{}{}
	}
}

// ClearAppRunTime clears the "app_run_time" edge to the AppRunTime entity.
func (m *AppMutation) ClearAppRunTime() {
	m.clearedapp_run_time = true
}

// AppRunTimeCleared reports if the "app_run_time" edge to the AppRunTime entity was cleared.
func (m *AppMutation) AppRunTimeCleared() bool {
	return m.clearedapp_run_time
}

// RemoveAppRunTimeIDs removes the "app_run_time" edge to the AppRunTime entity by IDs.
func (m *AppMutation) RemoveAppRunTimeIDs(ids ...model.InternalID) {
	if m.removedapp_run_time == nil {
		m.removedapp_run_time = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.app_run_time, ids[i])
		m.removedapp_run_time[ids[i]] = struct{}{}
	}
}

// RemovedAppRunTime returns the removed IDs of the "app_run_time" edge to the AppRunTime entity.
func (m *AppMutation) RemovedAppRunTimeIDs() (ids []model.InternalID) {
	for id := range m.removedapp_run_time {
		ids = append(ids, id)
	}
	return
}

// AppRunTimeIDs returns the "app_run_time" edge IDs in the mutation.
func (m *AppMutation) AppRunTimeIDs() (ids []model.InternalID) {
	for id := range m.app_run_time {
		ids = append(ids, id)
	}
	return
}

// ResetAppRunTime resets all changes to the "app_run_time" edge.
func (m *AppMutation) ResetAppRunTime() {
	m.app_run_time = nil
	m.clearedapp_run_time = false
	m.removedapp_run_time = nil
}

// AddAppCategoryIDs adds the "app_category" edge to the AppCategory entity by ids.
func (m *AppMutation) AddAppCategoryIDs(ids ...model.InternalID) {
	if m.app_category == nil {
		m.app_category = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.app_category[ids[i]] = struct{}{}
	}
}

// ClearAppCategory clears the "app_category" edge to the AppCategory entity.
func (m *AppMutation) ClearAppCategory() {
	m.clearedapp_category = true
}

// AppCategoryCleared reports if the "app_category" edge to the AppCategory entity was cleared.
func (m *AppMutation) AppCategoryCleared() bool {
	return m.clearedapp_category
}

// RemoveAppCategoryIDs removes the "app_category" edge to the AppCategory entity by IDs.
func (m *AppMutation) RemoveAppCategoryIDs(ids ...model.InternalID) {
	if m.removedapp_category == nil {
		m.removedapp_category = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.app_category, ids[i])
		m.removedapp_category[ids[i]] = struct{}{}
	}
}

// RemovedAppCategory returns the removed IDs of the "app_category" edge to the AppCategory entity.
func (m *AppMutation) RemovedAppCategoryIDs() (ids []model.InternalID) {
	for id := range m.removedapp_category {
		ids = append(ids, id)
	}
	return
}

// AppCategoryIDs returns the "app_category" edge IDs in the mutation.
func (m *AppMutation) AppCategoryIDs() (ids []model.InternalID) {
	for id := range m.app_category {
		ids = append(ids, id)
	}
	return
}

// ResetAppCategory resets all changes to the "app_category" edge.
func (m *AppMutation) ResetAppCategory() {
	m.app_category = nil
	m.clearedapp_category = false
	m.removedapp_category = nil
}

// AddAppAppCategoryIDs adds the "app_app_category" edge to the AppAppCategory entity by ids.
func (m *AppMutation) AddAppAppCategoryIDs(ids ...int) {
	if m.app_app_category == nil {
		m.app_app_category = make(map[int]struct{})
	}
	for i := range ids {
		m.app_app_category[ids[i]] = struct{}{}
	}
}

// ClearAppAppCategory clears the "app_app_category" edge to the AppAppCategory entity.
func (m *AppMutation) ClearAppAppCategory() {
	m.clearedapp_app_category = true
}

// AppAppCategoryCleared reports if the "app_app_category" edge to the AppAppCategory entity was cleared.
func (m *AppMutation) AppAppCategoryCleared() bool {
	return m.clearedapp_app_category
}

// RemoveAppAppCategoryIDs removes the "app_app_category" edge to the AppAppCategory entity by IDs.
func (m *AppMutation) RemoveAppAppCategoryIDs(ids ...int) {
	if m.removedapp_app_category == nil {
		m.removedapp_app_category = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.app_app_category, ids[i])
		m.removedapp_app_category[ids[i]] = struct{}{}
	}
}

// RemovedAppAppCategory returns the removed IDs of the "app_app_category" edge to the AppAppCategory entity.
func (m *AppMutation) RemovedAppAppCategoryIDs() (ids []int) {
	for id := range m.removedapp_app_category {
		ids = append(ids, id)
	}
	return
}

// AppAppCategoryIDs returns the "app_app_category" edge IDs in the mutation.
func (m *AppMutation) AppAppCategoryIDs() (ids []int) {
	for id := range m.app_app_category {
		ids = append(ids, id)
	}
	return
}

// ResetAppAppCategory resets all changes to the "app_app_category" edge.
func (m *AppMutation) ResetAppAppCategory() {
	m.app_app_category = nil
	m.clearedapp_app_category = false
	m.removedapp_app_category = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.version_number != nil {
		fields = append(fields, app.FieldVersionNumber)
	}
	if m.version_date != nil {
		fields = append(fields, app.FieldVersionDate)
	}
	if m.user != nil {
		fields = append(fields, app.FieldUserID)
	}
	if m.device != nil {
		fields = append(fields, app.FieldCreatorDeviceID)
	}
	if m.app_sources != nil {
		fields = append(fields, app.FieldAppSources)
	}
	if m.public != nil {
		fields = append(fields, app.FieldPublic)
	}
	if m.bound_store_app_id != nil {
		fields = append(fields, app.FieldBoundStoreAppID)
	}
	if m.stop_store_manage != nil {
		fields = append(fields, app.FieldStopStoreManage)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m._type != nil {
		fields = append(fields, app.FieldType)
	}
	if m.short_description != nil {
		fields = append(fields, app.FieldShortDescription)
	}
	if m.description != nil {
		fields = append(fields, app.FieldDescription)
	}
	if m.icon_image_url != nil {
		fields = append(fields, app.FieldIconImageURL)
	}
	if m.icon_image_id != nil {
		fields = append(fields, app.FieldIconImageID)
	}
	if m.background_image_url != nil {
		fields = append(fields, app.FieldBackgroundImageURL)
	}
	if m.background_image_id != nil {
		fields = append(fields, app.FieldBackgroundImageID)
	}
	if m.cover_image_url != nil {
		fields = append(fields, app.FieldCoverImageURL)
	}
	if m.cover_image_id != nil {
		fields = append(fields, app.FieldCoverImageID)
	}
	if m.release_date != nil {
		fields = append(fields, app.FieldReleaseDate)
	}
	if m.developer != nil {
		fields = append(fields, app.FieldDeveloper)
	}
	if m.publisher != nil {
		fields = append(fields, app.FieldPublisher)
	}
	if m.tags != nil {
		fields = append(fields, app.FieldTags)
	}
	if m.alternative_names != nil {
		fields = append(fields, app.FieldAlternativeNames)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldVersionNumber:
		return m.VersionNumber()
	case app.FieldVersionDate:
		return m.VersionDate()
	case app.FieldUserID:
		return m.UserID()
	case app.FieldCreatorDeviceID:
		return m.CreatorDeviceID()
	case app.FieldAppSources:
		return m.AppSources()
	case app.FieldPublic:
		return m.Public()
	case app.FieldBoundStoreAppID:
		return m.BoundStoreAppID()
	case app.FieldStopStoreManage:
		return m.StopStoreManage()
	case app.FieldName:
		return m.Name()
	case app.FieldType:
		return m.GetType()
	case app.FieldShortDescription:
		return m.ShortDescription()
	case app.FieldDescription:
		return m.Description()
	case app.FieldIconImageURL:
		return m.IconImageURL()
	case app.FieldIconImageID:
		return m.IconImageID()
	case app.FieldBackgroundImageURL:
		return m.BackgroundImageURL()
	case app.FieldBackgroundImageID:
		return m.BackgroundImageID()
	case app.FieldCoverImageURL:
		return m.CoverImageURL()
	case app.FieldCoverImageID:
		return m.CoverImageID()
	case app.FieldReleaseDate:
		return m.ReleaseDate()
	case app.FieldDeveloper:
		return m.Developer()
	case app.FieldPublisher:
		return m.Publisher()
	case app.FieldTags:
		return m.Tags()
	case app.FieldAlternativeNames:
		return m.AlternativeNames()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldVersionNumber:
		return m.OldVersionNumber(ctx)
	case app.FieldVersionDate:
		return m.OldVersionDate(ctx)
	case app.FieldUserID:
		return m.OldUserID(ctx)
	case app.FieldCreatorDeviceID:
		return m.OldCreatorDeviceID(ctx)
	case app.FieldAppSources:
		return m.OldAppSources(ctx)
	case app.FieldPublic:
		return m.OldPublic(ctx)
	case app.FieldBoundStoreAppID:
		return m.OldBoundStoreAppID(ctx)
	case app.FieldStopStoreManage:
		return m.OldStopStoreManage(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldType:
		return m.OldType(ctx)
	case app.FieldShortDescription:
		return m.OldShortDescription(ctx)
	case app.FieldDescription:
		return m.OldDescription(ctx)
	case app.FieldIconImageURL:
		return m.OldIconImageURL(ctx)
	case app.FieldIconImageID:
		return m.OldIconImageID(ctx)
	case app.FieldBackgroundImageURL:
		return m.OldBackgroundImageURL(ctx)
	case app.FieldBackgroundImageID:
		return m.OldBackgroundImageID(ctx)
	case app.FieldCoverImageURL:
		return m.OldCoverImageURL(ctx)
	case app.FieldCoverImageID:
		return m.OldCoverImageID(ctx)
	case app.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case app.FieldDeveloper:
		return m.OldDeveloper(ctx)
	case app.FieldPublisher:
		return m.OldPublisher(ctx)
	case app.FieldTags:
		return m.OldTags(ctx)
	case app.FieldAlternativeNames:
		return m.OldAlternativeNames(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldVersionNumber:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionNumber(v)
		return nil
	case app.FieldVersionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionDate(v)
		return nil
	case app.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case app.FieldCreatorDeviceID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorDeviceID(v)
		return nil
	case app.FieldAppSources:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppSources(v)
		return nil
	case app.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case app.FieldBoundStoreAppID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoundStoreAppID(v)
		return nil
	case app.FieldStopStoreManage:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStopStoreManage(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldType:
		v, ok := value.(app.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case app.FieldShortDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortDescription(v)
		return nil
	case app.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case app.FieldIconImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconImageURL(v)
		return nil
	case app.FieldIconImageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconImageID(v)
		return nil
	case app.FieldBackgroundImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundImageURL(v)
		return nil
	case app.FieldBackgroundImageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundImageID(v)
		return nil
	case app.FieldCoverImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImageURL(v)
		return nil
	case app.FieldCoverImageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImageID(v)
		return nil
	case app.FieldReleaseDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case app.FieldDeveloper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeveloper(v)
		return nil
	case app.FieldPublisher:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisher(v)
		return nil
	case app.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case app.FieldAlternativeNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlternativeNames(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	if m.addversion_number != nil {
		fields = append(fields, app.FieldVersionNumber)
	}
	if m.addbound_store_app_id != nil {
		fields = append(fields, app.FieldBoundStoreAppID)
	}
	if m.addicon_image_id != nil {
		fields = append(fields, app.FieldIconImageID)
	}
	if m.addbackground_image_id != nil {
		fields = append(fields, app.FieldBackgroundImageID)
	}
	if m.addcover_image_id != nil {
		fields = append(fields, app.FieldCoverImageID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case app.FieldVersionNumber:
		return m.AddedVersionNumber()
	case app.FieldBoundStoreAppID:
		return m.AddedBoundStoreAppID()
	case app.FieldIconImageID:
		return m.AddedIconImageID()
	case app.FieldBackgroundImageID:
		return m.AddedBackgroundImageID()
	case app.FieldCoverImageID:
		return m.AddedCoverImageID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	case app.FieldVersionNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionNumber(v)
		return nil
	case app.FieldBoundStoreAppID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBoundStoreAppID(v)
		return nil
	case app.FieldIconImageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIconImageID(v)
		return nil
	case app.FieldBackgroundImageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBackgroundImageID(v)
		return nil
	case app.FieldCoverImageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoverImageID(v)
		return nil
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldBoundStoreAppID) {
		fields = append(fields, app.FieldBoundStoreAppID)
	}
	if m.FieldCleared(app.FieldStopStoreManage) {
		fields = append(fields, app.FieldStopStoreManage)
	}
	if m.FieldCleared(app.FieldShortDescription) {
		fields = append(fields, app.FieldShortDescription)
	}
	if m.FieldCleared(app.FieldDescription) {
		fields = append(fields, app.FieldDescription)
	}
	if m.FieldCleared(app.FieldIconImageURL) {
		fields = append(fields, app.FieldIconImageURL)
	}
	if m.FieldCleared(app.FieldBackgroundImageURL) {
		fields = append(fields, app.FieldBackgroundImageURL)
	}
	if m.FieldCleared(app.FieldCoverImageURL) {
		fields = append(fields, app.FieldCoverImageURL)
	}
	if m.FieldCleared(app.FieldReleaseDate) {
		fields = append(fields, app.FieldReleaseDate)
	}
	if m.FieldCleared(app.FieldDeveloper) {
		fields = append(fields, app.FieldDeveloper)
	}
	if m.FieldCleared(app.FieldPublisher) {
		fields = append(fields, app.FieldPublisher)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldBoundStoreAppID:
		m.ClearBoundStoreAppID()
		return nil
	case app.FieldStopStoreManage:
		m.ClearStopStoreManage()
		return nil
	case app.FieldShortDescription:
		m.ClearShortDescription()
		return nil
	case app.FieldDescription:
		m.ClearDescription()
		return nil
	case app.FieldIconImageURL:
		m.ClearIconImageURL()
		return nil
	case app.FieldBackgroundImageURL:
		m.ClearBackgroundImageURL()
		return nil
	case app.FieldCoverImageURL:
		m.ClearCoverImageURL()
		return nil
	case app.FieldReleaseDate:
		m.ClearReleaseDate()
		return nil
	case app.FieldDeveloper:
		m.ClearDeveloper()
		return nil
	case app.FieldPublisher:
		m.ClearPublisher()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldVersionNumber:
		m.ResetVersionNumber()
		return nil
	case app.FieldVersionDate:
		m.ResetVersionDate()
		return nil
	case app.FieldUserID:
		m.ResetUserID()
		return nil
	case app.FieldCreatorDeviceID:
		m.ResetCreatorDeviceID()
		return nil
	case app.FieldAppSources:
		m.ResetAppSources()
		return nil
	case app.FieldPublic:
		m.ResetPublic()
		return nil
	case app.FieldBoundStoreAppID:
		m.ResetBoundStoreAppID()
		return nil
	case app.FieldStopStoreManage:
		m.ResetStopStoreManage()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldType:
		m.ResetType()
		return nil
	case app.FieldShortDescription:
		m.ResetShortDescription()
		return nil
	case app.FieldDescription:
		m.ResetDescription()
		return nil
	case app.FieldIconImageURL:
		m.ResetIconImageURL()
		return nil
	case app.FieldIconImageID:
		m.ResetIconImageID()
		return nil
	case app.FieldBackgroundImageURL:
		m.ResetBackgroundImageURL()
		return nil
	case app.FieldBackgroundImageID:
		m.ResetBackgroundImageID()
		return nil
	case app.FieldCoverImageURL:
		m.ResetCoverImageURL()
		return nil
	case app.FieldCoverImageID:
		m.ResetCoverImageID()
		return nil
	case app.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case app.FieldDeveloper:
		m.ResetDeveloper()
		return nil
	case app.FieldPublisher:
		m.ResetPublisher()
		return nil
	case app.FieldTags:
		m.ResetTags()
		return nil
	case app.FieldAlternativeNames:
		m.ResetAlternativeNames()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, app.EdgeUser)
	}
	if m.device != nil {
		edges = append(edges, app.EdgeDevice)
	}
	if m.app_run_time != nil {
		edges = append(edges, app.EdgeAppRunTime)
	}
	if m.app_category != nil {
		edges = append(edges, app.EdgeAppCategory)
	}
	if m.app_app_category != nil {
		edges = append(edges, app.EdgeAppAppCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeAppRunTime:
		ids := make([]ent.Value, 0, len(m.app_run_time))
		for id := range m.app_run_time {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAppCategory:
		ids := make([]ent.Value, 0, len(m.app_category))
		for id := range m.app_category {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAppAppCategory:
		ids := make([]ent.Value, 0, len(m.app_app_category))
		for id := range m.app_app_category {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedapp_run_time != nil {
		edges = append(edges, app.EdgeAppRunTime)
	}
	if m.removedapp_category != nil {
		edges = append(edges, app.EdgeAppCategory)
	}
	if m.removedapp_app_category != nil {
		edges = append(edges, app.EdgeAppAppCategory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeAppRunTime:
		ids := make([]ent.Value, 0, len(m.removedapp_run_time))
		for id := range m.removedapp_run_time {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAppCategory:
		ids := make([]ent.Value, 0, len(m.removedapp_category))
		for id := range m.removedapp_category {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAppAppCategory:
		ids := make([]ent.Value, 0, len(m.removedapp_app_category))
		for id := range m.removedapp_app_category {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, app.EdgeUser)
	}
	if m.cleareddevice {
		edges = append(edges, app.EdgeDevice)
	}
	if m.clearedapp_run_time {
		edges = append(edges, app.EdgeAppRunTime)
	}
	if m.clearedapp_category {
		edges = append(edges, app.EdgeAppCategory)
	}
	if m.clearedapp_app_category {
		edges = append(edges, app.EdgeAppAppCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeUser:
		return m.cleareduser
	case app.EdgeDevice:
		return m.cleareddevice
	case app.EdgeAppRunTime:
		return m.clearedapp_run_time
	case app.EdgeAppCategory:
		return m.clearedapp_category
	case app.EdgeAppAppCategory:
		return m.clearedapp_app_category
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	case app.EdgeUser:
		m.ClearUser()
		return nil
	case app.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeUser:
		m.ResetUser()
		return nil
	case app.EdgeDevice:
		m.ResetDevice()
		return nil
	case app.EdgeAppRunTime:
		m.ResetAppRunTime()
		return nil
	case app.EdgeAppCategory:
		m.ResetAppCategory()
		return nil
	case app.EdgeAppAppCategory:
		m.ResetAppAppCategory()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AppAppCategoryMutation represents an operation that mutates the AppAppCategory nodes in the graph.
type AppAppCategoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	clearedFields       map[string]struct{}
	app_category        *model.InternalID
	clearedapp_category bool
	app                 *model.InternalID
	clearedapp          bool
	done                bool
	oldValue            func(context.Context) (*AppAppCategory, error)
	predicates          []predicate.AppAppCategory
}

var _ ent.Mutation = (*AppAppCategoryMutation)(nil)

// appappcategoryOption allows management of the mutation configuration using functional options.
type appappcategoryOption func(*AppAppCategoryMutation)

// newAppAppCategoryMutation creates new mutation for the AppAppCategory entity.
func newAppAppCategoryMutation(c config, op Op, opts ...appappcategoryOption) *AppAppCategoryMutation {
	m := &AppAppCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeAppAppCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppAppCategoryID sets the ID field of the mutation.
func withAppAppCategoryID(id int) appappcategoryOption {
	return func(m *AppAppCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *AppAppCategory
		)
		m.oldValue = func(ctx context.Context) (*AppAppCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppAppCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppAppCategory sets the old AppAppCategory of the mutation.
func withAppAppCategory(node *AppAppCategory) appappcategoryOption {
	return func(m *AppAppCategoryMutation) {
		m.oldValue = func(context.Context) (*AppAppCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppAppCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppAppCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppAppCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppAppCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppAppCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppCategoryID sets the "app_category_id" field.
func (m *AppAppCategoryMutation) SetAppCategoryID(mi model.InternalID) {
	m.app_category = &mi
}

// AppCategoryID returns the value of the "app_category_id" field in the mutation.
func (m *AppAppCategoryMutation) AppCategoryID() (r model.InternalID, exists bool) {
	v := m.app_category
	if v == nil {
		return
	}
	return *v, true
}

// OldAppCategoryID returns the old "app_category_id" field's value of the AppAppCategory entity.
// If the AppAppCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppAppCategoryMutation) OldAppCategoryID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppCategoryID: %w", err)
	}
	return oldValue.AppCategoryID, nil
}

// ResetAppCategoryID resets all changes to the "app_category_id" field.
func (m *AppAppCategoryMutation) ResetAppCategoryID() {
	m.app_category = nil
}

// SetAppID sets the "app_id" field.
func (m *AppAppCategoryMutation) SetAppID(mi model.InternalID) {
	m.app = &mi
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppAppCategoryMutation) AppID() (r model.InternalID, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppAppCategory entity.
// If the AppAppCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppAppCategoryMutation) OldAppID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppAppCategoryMutation) ResetAppID() {
	m.app = nil
}

// ClearAppCategory clears the "app_category" edge to the AppCategory entity.
func (m *AppAppCategoryMutation) ClearAppCategory() {
	m.clearedapp_category = true
	m.clearedFields[appappcategory.FieldAppCategoryID] = struct{}{}
}

// AppCategoryCleared reports if the "app_category" edge to the AppCategory entity was cleared.
func (m *AppAppCategoryMutation) AppCategoryCleared() bool {
	return m.clearedapp_category
}

// AppCategoryIDs returns the "app_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppCategoryID instead. It exists only for internal usage by the builders.
func (m *AppAppCategoryMutation) AppCategoryIDs() (ids []model.InternalID) {
	if id := m.app_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppCategory resets all changes to the "app_category" edge.
func (m *AppAppCategoryMutation) ResetAppCategory() {
	m.app_category = nil
	m.clearedapp_category = false
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppAppCategoryMutation) ClearApp() {
	m.clearedapp = true
	m.clearedFields[appappcategory.FieldAppID] = struct{}{}
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppAppCategoryMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppAppCategoryMutation) AppIDs() (ids []model.InternalID) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppAppCategoryMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the AppAppCategoryMutation builder.
func (m *AppAppCategoryMutation) Where(ps ...predicate.AppAppCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppAppCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppAppCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppAppCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppAppCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppAppCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppAppCategory).
func (m *AppAppCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppAppCategoryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.app_category != nil {
		fields = append(fields, appappcategory.FieldAppCategoryID)
	}
	if m.app != nil {
		fields = append(fields, appappcategory.FieldAppID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppAppCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appappcategory.FieldAppCategoryID:
		return m.AppCategoryID()
	case appappcategory.FieldAppID:
		return m.AppID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppAppCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appappcategory.FieldAppCategoryID:
		return m.OldAppCategoryID(ctx)
	case appappcategory.FieldAppID:
		return m.OldAppID(ctx)
	}
	return nil, fmt.Errorf("unknown AppAppCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppAppCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appappcategory.FieldAppCategoryID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppCategoryID(v)
		return nil
	case appappcategory.FieldAppID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	}
	return fmt.Errorf("unknown AppAppCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppAppCategoryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppAppCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppAppCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppAppCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppAppCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppAppCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppAppCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppAppCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppAppCategoryMutation) ResetField(name string) error {
	switch name {
	case appappcategory.FieldAppCategoryID:
		m.ResetAppCategoryID()
		return nil
	case appappcategory.FieldAppID:
		m.ResetAppID()
		return nil
	}
	return fmt.Errorf("unknown AppAppCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppAppCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app_category != nil {
		edges = append(edges, appappcategory.EdgeAppCategory)
	}
	if m.app != nil {
		edges = append(edges, appappcategory.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppAppCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appappcategory.EdgeAppCategory:
		if id := m.app_category; id != nil {
			return []ent.Value{*id}
		}
	case appappcategory.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppAppCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppAppCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppAppCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp_category {
		edges = append(edges, appappcategory.EdgeAppCategory)
	}
	if m.clearedapp {
		edges = append(edges, appappcategory.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppAppCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case appappcategory.EdgeAppCategory:
		return m.clearedapp_category
	case appappcategory.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppAppCategoryMutation) ClearEdge(name string) error {
	switch name {
	case appappcategory.EdgeAppCategory:
		m.ClearAppCategory()
		return nil
	case appappcategory.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppAppCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppAppCategoryMutation) ResetEdge(name string) error {
	switch name {
	case appappcategory.EdgeAppCategory:
		m.ResetAppCategory()
		return nil
	case appappcategory.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown AppAppCategory edge %s", name)
}

// AppCategoryMutation represents an operation that mutates the AppCategory nodes in the graph.
type AppCategoryMutation struct {
	config
	op                      Op
	typ                     string
	id                      *model.InternalID
	user_id                 *model.InternalID
	adduser_id              *model.InternalID
	version_number          *uint64
	addversion_number       *int64
	version_date            *time.Time
	name                    *string
	updated_at              *time.Time
	created_at              *time.Time
	clearedFields           map[string]struct{}
	app                     map[model.InternalID]struct{}
	removedapp              map[model.InternalID]struct{}
	clearedapp              bool
	app_app_category        map[int]struct{}
	removedapp_app_category map[int]struct{}
	clearedapp_app_category bool
	done                    bool
	oldValue                func(context.Context) (*AppCategory, error)
	predicates              []predicate.AppCategory
}

var _ ent.Mutation = (*AppCategoryMutation)(nil)

// appcategoryOption allows management of the mutation configuration using functional options.
type appcategoryOption func(*AppCategoryMutation)

// newAppCategoryMutation creates new mutation for the AppCategory entity.
func newAppCategoryMutation(c config, op Op, opts ...appcategoryOption) *AppCategoryMutation {
	m := &AppCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeAppCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppCategoryID sets the ID field of the mutation.
func withAppCategoryID(id model.InternalID) appcategoryOption {
	return func(m *AppCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *AppCategory
		)
		m.oldValue = func(ctx context.Context) (*AppCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppCategory sets the old AppCategory of the mutation.
func withAppCategory(node *AppCategory) appcategoryOption {
	return func(m *AppCategoryMutation) {
		m.oldValue = func(context.Context) (*AppCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppCategory entities.
func (m *AppCategoryMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppCategoryMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppCategoryMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AppCategoryMutation) SetUserID(mi model.InternalID) {
	m.user_id = &mi
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppCategoryMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppCategory entity.
// If the AppCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCategoryMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds mi to the "user_id" field.
func (m *AppCategoryMutation) AddUserID(mi model.InternalID) {
	if m.adduser_id != nil {
		*m.adduser_id += mi
	} else {
		m.adduser_id = &mi
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AppCategoryMutation) AddedUserID() (r model.InternalID, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppCategoryMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetVersionNumber sets the "version_number" field.
func (m *AppCategoryMutation) SetVersionNumber(u uint64) {
	m.version_number = &u
	m.addversion_number = nil
}

// VersionNumber returns the value of the "version_number" field in the mutation.
func (m *AppCategoryMutation) VersionNumber() (r uint64, exists bool) {
	v := m.version_number
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionNumber returns the old "version_number" field's value of the AppCategory entity.
// If the AppCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCategoryMutation) OldVersionNumber(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionNumber: %w", err)
	}
	return oldValue.VersionNumber, nil
}

// AddVersionNumber adds u to the "version_number" field.
func (m *AppCategoryMutation) AddVersionNumber(u int64) {
	if m.addversion_number != nil {
		*m.addversion_number += u
	} else {
		m.addversion_number = &u
	}
}

// AddedVersionNumber returns the value that was added to the "version_number" field in this mutation.
func (m *AppCategoryMutation) AddedVersionNumber() (r int64, exists bool) {
	v := m.addversion_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionNumber resets all changes to the "version_number" field.
func (m *AppCategoryMutation) ResetVersionNumber() {
	m.version_number = nil
	m.addversion_number = nil
}

// SetVersionDate sets the "version_date" field.
func (m *AppCategoryMutation) SetVersionDate(t time.Time) {
	m.version_date = &t
}

// VersionDate returns the value of the "version_date" field in the mutation.
func (m *AppCategoryMutation) VersionDate() (r time.Time, exists bool) {
	v := m.version_date
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionDate returns the old "version_date" field's value of the AppCategory entity.
// If the AppCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCategoryMutation) OldVersionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionDate: %w", err)
	}
	return oldValue.VersionDate, nil
}

// ResetVersionDate resets all changes to the "version_date" field.
func (m *AppCategoryMutation) ResetVersionDate() {
	m.version_date = nil
}

// SetName sets the "name" field.
func (m *AppCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppCategory entity.
// If the AppCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppCategoryMutation) ResetName() {
	m.name = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppCategory entity.
// If the AppCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppCategory entity.
// If the AppCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddAppIDs adds the "app" edge to the App entity by ids.
func (m *AppCategoryMutation) AddAppIDs(ids ...model.InternalID) {
	if m.app == nil {
		m.app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.app[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppCategoryMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppCategoryMutation) AppCleared() bool {
	return m.clearedapp
}

// RemoveAppIDs removes the "app" edge to the App entity by IDs.
func (m *AppCategoryMutation) RemoveAppIDs(ids ...model.InternalID) {
	if m.removedapp == nil {
		m.removedapp = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.app, ids[i])
		m.removedapp[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "app" edge to the App entity.
func (m *AppCategoryMutation) RemovedAppIDs() (ids []model.InternalID) {
	for id := range m.removedapp {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
func (m *AppCategoryMutation) AppIDs() (ids []model.InternalID) {
	for id := range m.app {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppCategoryMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
	m.removedapp = nil
}

// AddAppAppCategoryIDs adds the "app_app_category" edge to the AppAppCategory entity by ids.
func (m *AppCategoryMutation) AddAppAppCategoryIDs(ids ...int) {
	if m.app_app_category == nil {
		m.app_app_category = make(map[int]struct{})
	}
	for i := range ids {
		m.app_app_category[ids[i]] = struct{}{}
	}
}

// ClearAppAppCategory clears the "app_app_category" edge to the AppAppCategory entity.
func (m *AppCategoryMutation) ClearAppAppCategory() {
	m.clearedapp_app_category = true
}

// AppAppCategoryCleared reports if the "app_app_category" edge to the AppAppCategory entity was cleared.
func (m *AppCategoryMutation) AppAppCategoryCleared() bool {
	return m.clearedapp_app_category
}

// RemoveAppAppCategoryIDs removes the "app_app_category" edge to the AppAppCategory entity by IDs.
func (m *AppCategoryMutation) RemoveAppAppCategoryIDs(ids ...int) {
	if m.removedapp_app_category == nil {
		m.removedapp_app_category = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.app_app_category, ids[i])
		m.removedapp_app_category[ids[i]] = struct{}{}
	}
}

// RemovedAppAppCategory returns the removed IDs of the "app_app_category" edge to the AppAppCategory entity.
func (m *AppCategoryMutation) RemovedAppAppCategoryIDs() (ids []int) {
	for id := range m.removedapp_app_category {
		ids = append(ids, id)
	}
	return
}

// AppAppCategoryIDs returns the "app_app_category" edge IDs in the mutation.
func (m *AppCategoryMutation) AppAppCategoryIDs() (ids []int) {
	for id := range m.app_app_category {
		ids = append(ids, id)
	}
	return
}

// ResetAppAppCategory resets all changes to the "app_app_category" edge.
func (m *AppCategoryMutation) ResetAppAppCategory() {
	m.app_app_category = nil
	m.clearedapp_app_category = false
	m.removedapp_app_category = nil
}

// Where appends a list predicates to the AppCategoryMutation builder.
func (m *AppCategoryMutation) Where(ps ...predicate.AppCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppCategory).
func (m *AppCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppCategoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user_id != nil {
		fields = append(fields, appcategory.FieldUserID)
	}
	if m.version_number != nil {
		fields = append(fields, appcategory.FieldVersionNumber)
	}
	if m.version_date != nil {
		fields = append(fields, appcategory.FieldVersionDate)
	}
	if m.name != nil {
		fields = append(fields, appcategory.FieldName)
	}
	if m.updated_at != nil {
		fields = append(fields, appcategory.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, appcategory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appcategory.FieldUserID:
		return m.UserID()
	case appcategory.FieldVersionNumber:
		return m.VersionNumber()
	case appcategory.FieldVersionDate:
		return m.VersionDate()
	case appcategory.FieldName:
		return m.Name()
	case appcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case appcategory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appcategory.FieldUserID:
		return m.OldUserID(ctx)
	case appcategory.FieldVersionNumber:
		return m.OldVersionNumber(ctx)
	case appcategory.FieldVersionDate:
		return m.OldVersionDate(ctx)
	case appcategory.FieldName:
		return m.OldName(ctx)
	case appcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appcategory.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appcategory.FieldVersionNumber:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionNumber(v)
		return nil
	case appcategory.FieldVersionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionDate(v)
		return nil
	case appcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppCategoryMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, appcategory.FieldUserID)
	}
	if m.addversion_number != nil {
		fields = append(fields, appcategory.FieldVersionNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appcategory.FieldUserID:
		return m.AddedUserID()
	case appcategory.FieldVersionNumber:
		return m.AddedVersionNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appcategory.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case appcategory.FieldVersionNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionNumber(v)
		return nil
	}
	return fmt.Errorf("unknown AppCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppCategoryMutation) ResetField(name string) error {
	switch name {
	case appcategory.FieldUserID:
		m.ResetUserID()
		return nil
	case appcategory.FieldVersionNumber:
		m.ResetVersionNumber()
		return nil
	case appcategory.FieldVersionDate:
		m.ResetVersionDate()
		return nil
	case appcategory.FieldName:
		m.ResetName()
		return nil
	case appcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.app != nil {
		edges = append(edges, appcategory.EdgeApp)
	}
	if m.app_app_category != nil {
		edges = append(edges, appcategory.EdgeAppAppCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appcategory.EdgeApp:
		ids := make([]ent.Value, 0, len(m.app))
		for id := range m.app {
			ids = append(ids, id)
		}
		return ids
	case appcategory.EdgeAppAppCategory:
		ids := make([]ent.Value, 0, len(m.app_app_category))
		for id := range m.app_app_category {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedapp != nil {
		edges = append(edges, appcategory.EdgeApp)
	}
	if m.removedapp_app_category != nil {
		edges = append(edges, appcategory.EdgeAppAppCategory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case appcategory.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removedapp))
		for id := range m.removedapp {
			ids = append(ids, id)
		}
		return ids
	case appcategory.EdgeAppAppCategory:
		ids := make([]ent.Value, 0, len(m.removedapp_app_category))
		for id := range m.removedapp_app_category {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapp {
		edges = append(edges, appcategory.EdgeApp)
	}
	if m.clearedapp_app_category {
		edges = append(edges, appcategory.EdgeAppAppCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case appcategory.EdgeApp:
		return m.clearedapp
	case appcategory.EdgeAppAppCategory:
		return m.clearedapp_app_category
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AppCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppCategoryMutation) ResetEdge(name string) error {
	switch name {
	case appcategory.EdgeApp:
		m.ResetApp()
		return nil
	case appcategory.EdgeAppAppCategory:
		m.ResetAppAppCategory()
		return nil
	}
	return fmt.Errorf("unknown AppCategory edge %s", name)
}

// AppInfoMutation represents an operation that mutates the AppInfo nodes in the graph.
type AppInfoMutation struct {
	config
	op                      Op
	typ                     string
	id                      *model.InternalID
	source                  *string
	source_app_id           *string
	source_url              *string
	name                    *string
	_type                   *appinfo.Type
	short_description       *string
	description             *string
	icon_image_url          *string
	icon_image_id           *model.InternalID
	addicon_image_id        *model.InternalID
	background_image_url    *string
	background_image_id     *model.InternalID
	addbackground_image_id  *model.InternalID
	cover_image_url         *string
	cover_image_id          *model.InternalID
	addcover_image_id       *model.InternalID
	release_date            *string
	developer               *string
	publisher               *string
	tags                    *[]string
	appendtags              []string
	alternative_names       *[]string
	appendalternative_names []string
	raw_data                *string
	updated_at              *time.Time
	created_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*AppInfo, error)
	predicates              []predicate.AppInfo
}

var _ ent.Mutation = (*AppInfoMutation)(nil)

// appinfoOption allows management of the mutation configuration using functional options.
type appinfoOption func(*AppInfoMutation)

// newAppInfoMutation creates new mutation for the AppInfo entity.
func newAppInfoMutation(c config, op Op, opts ...appinfoOption) *AppInfoMutation {
	m := &AppInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeAppInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppInfoID sets the ID field of the mutation.
func withAppInfoID(id model.InternalID) appinfoOption {
	return func(m *AppInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *AppInfo
		)
		m.oldValue = func(ctx context.Context) (*AppInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppInfo sets the old AppInfo of the mutation.
func withAppInfo(node *AppInfo) appinfoOption {
	return func(m *AppInfoMutation) {
		m.oldValue = func(context.Context) (*AppInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppInfo entities.
func (m *AppInfoMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppInfoMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppInfoMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSource sets the "source" field.
func (m *AppInfoMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *AppInfoMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *AppInfoMutation) ResetSource() {
	m.source = nil
}

// SetSourceAppID sets the "source_app_id" field.
func (m *AppInfoMutation) SetSourceAppID(s string) {
	m.source_app_id = &s
}

// SourceAppID returns the value of the "source_app_id" field in the mutation.
func (m *AppInfoMutation) SourceAppID() (r string, exists bool) {
	v := m.source_app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceAppID returns the old "source_app_id" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldSourceAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceAppID: %w", err)
	}
	return oldValue.SourceAppID, nil
}

// ResetSourceAppID resets all changes to the "source_app_id" field.
func (m *AppInfoMutation) ResetSourceAppID() {
	m.source_app_id = nil
}

// SetSourceURL sets the "source_url" field.
func (m *AppInfoMutation) SetSourceURL(s string) {
	m.source_url = &s
}

// SourceURL returns the value of the "source_url" field in the mutation.
func (m *AppInfoMutation) SourceURL() (r string, exists bool) {
	v := m.source_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceURL returns the old "source_url" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldSourceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceURL: %w", err)
	}
	return oldValue.SourceURL, nil
}

// ClearSourceURL clears the value of the "source_url" field.
func (m *AppInfoMutation) ClearSourceURL() {
	m.source_url = nil
	m.clearedFields[appinfo.FieldSourceURL] = struct{}{}
}

// SourceURLCleared returns if the "source_url" field was cleared in this mutation.
func (m *AppInfoMutation) SourceURLCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldSourceURL]
	return ok
}

// ResetSourceURL resets all changes to the "source_url" field.
func (m *AppInfoMutation) ResetSourceURL() {
	m.source_url = nil
	delete(m.clearedFields, appinfo.FieldSourceURL)
}

// SetName sets the "name" field.
func (m *AppInfoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppInfoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppInfoMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *AppInfoMutation) SetType(a appinfo.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AppInfoMutation) GetType() (r appinfo.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldType(ctx context.Context) (v appinfo.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AppInfoMutation) ResetType() {
	m._type = nil
}

// SetShortDescription sets the "short_description" field.
func (m *AppInfoMutation) SetShortDescription(s string) {
	m.short_description = &s
}

// ShortDescription returns the value of the "short_description" field in the mutation.
func (m *AppInfoMutation) ShortDescription() (r string, exists bool) {
	v := m.short_description
	if v == nil {
		return
	}
	return *v, true
}

// OldShortDescription returns the old "short_description" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldShortDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShortDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShortDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShortDescription: %w", err)
	}
	return oldValue.ShortDescription, nil
}

// ClearShortDescription clears the value of the "short_description" field.
func (m *AppInfoMutation) ClearShortDescription() {
	m.short_description = nil
	m.clearedFields[appinfo.FieldShortDescription] = struct{}{}
}

// ShortDescriptionCleared returns if the "short_description" field was cleared in this mutation.
func (m *AppInfoMutation) ShortDescriptionCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldShortDescription]
	return ok
}

// ResetShortDescription resets all changes to the "short_description" field.
func (m *AppInfoMutation) ResetShortDescription() {
	m.short_description = nil
	delete(m.clearedFields, appinfo.FieldShortDescription)
}

// SetDescription sets the "description" field.
func (m *AppInfoMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppInfoMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AppInfoMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[appinfo.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AppInfoMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AppInfoMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, appinfo.FieldDescription)
}

// SetIconImageURL sets the "icon_image_url" field.
func (m *AppInfoMutation) SetIconImageURL(s string) {
	m.icon_image_url = &s
}

// IconImageURL returns the value of the "icon_image_url" field in the mutation.
func (m *AppInfoMutation) IconImageURL() (r string, exists bool) {
	v := m.icon_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconImageURL returns the old "icon_image_url" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldIconImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconImageURL: %w", err)
	}
	return oldValue.IconImageURL, nil
}

// ClearIconImageURL clears the value of the "icon_image_url" field.
func (m *AppInfoMutation) ClearIconImageURL() {
	m.icon_image_url = nil
	m.clearedFields[appinfo.FieldIconImageURL] = struct{}{}
}

// IconImageURLCleared returns if the "icon_image_url" field was cleared in this mutation.
func (m *AppInfoMutation) IconImageURLCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldIconImageURL]
	return ok
}

// ResetIconImageURL resets all changes to the "icon_image_url" field.
func (m *AppInfoMutation) ResetIconImageURL() {
	m.icon_image_url = nil
	delete(m.clearedFields, appinfo.FieldIconImageURL)
}

// SetIconImageID sets the "icon_image_id" field.
func (m *AppInfoMutation) SetIconImageID(mi model.InternalID) {
	m.icon_image_id = &mi
	m.addicon_image_id = nil
}

// IconImageID returns the value of the "icon_image_id" field in the mutation.
func (m *AppInfoMutation) IconImageID() (r model.InternalID, exists bool) {
	v := m.icon_image_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIconImageID returns the old "icon_image_id" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldIconImageID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconImageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconImageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconImageID: %w", err)
	}
	return oldValue.IconImageID, nil
}

// AddIconImageID adds mi to the "icon_image_id" field.
func (m *AppInfoMutation) AddIconImageID(mi model.InternalID) {
	if m.addicon_image_id != nil {
		*m.addicon_image_id += mi
	} else {
		m.addicon_image_id = &mi
	}
}

// AddedIconImageID returns the value that was added to the "icon_image_id" field in this mutation.
func (m *AppInfoMutation) AddedIconImageID() (r model.InternalID, exists bool) {
	v := m.addicon_image_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetIconImageID resets all changes to the "icon_image_id" field.
func (m *AppInfoMutation) ResetIconImageID() {
	m.icon_image_id = nil
	m.addicon_image_id = nil
}

// SetBackgroundImageURL sets the "background_image_url" field.
func (m *AppInfoMutation) SetBackgroundImageURL(s string) {
	m.background_image_url = &s
}

// BackgroundImageURL returns the value of the "background_image_url" field in the mutation.
func (m *AppInfoMutation) BackgroundImageURL() (r string, exists bool) {
	v := m.background_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundImageURL returns the old "background_image_url" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldBackgroundImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundImageURL: %w", err)
	}
	return oldValue.BackgroundImageURL, nil
}

// ClearBackgroundImageURL clears the value of the "background_image_url" field.
func (m *AppInfoMutation) ClearBackgroundImageURL() {
	m.background_image_url = nil
	m.clearedFields[appinfo.FieldBackgroundImageURL] = struct{}{}
}

// BackgroundImageURLCleared returns if the "background_image_url" field was cleared in this mutation.
func (m *AppInfoMutation) BackgroundImageURLCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldBackgroundImageURL]
	return ok
}

// ResetBackgroundImageURL resets all changes to the "background_image_url" field.
func (m *AppInfoMutation) ResetBackgroundImageURL() {
	m.background_image_url = nil
	delete(m.clearedFields, appinfo.FieldBackgroundImageURL)
}

// SetBackgroundImageID sets the "background_image_id" field.
func (m *AppInfoMutation) SetBackgroundImageID(mi model.InternalID) {
	m.background_image_id = &mi
	m.addbackground_image_id = nil
}

// BackgroundImageID returns the value of the "background_image_id" field in the mutation.
func (m *AppInfoMutation) BackgroundImageID() (r model.InternalID, exists bool) {
	v := m.background_image_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundImageID returns the old "background_image_id" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldBackgroundImageID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundImageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundImageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundImageID: %w", err)
	}
	return oldValue.BackgroundImageID, nil
}

// AddBackgroundImageID adds mi to the "background_image_id" field.
func (m *AppInfoMutation) AddBackgroundImageID(mi model.InternalID) {
	if m.addbackground_image_id != nil {
		*m.addbackground_image_id += mi
	} else {
		m.addbackground_image_id = &mi
	}
}

// AddedBackgroundImageID returns the value that was added to the "background_image_id" field in this mutation.
func (m *AppInfoMutation) AddedBackgroundImageID() (r model.InternalID, exists bool) {
	v := m.addbackground_image_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBackgroundImageID resets all changes to the "background_image_id" field.
func (m *AppInfoMutation) ResetBackgroundImageID() {
	m.background_image_id = nil
	m.addbackground_image_id = nil
}

// SetCoverImageURL sets the "cover_image_url" field.
func (m *AppInfoMutation) SetCoverImageURL(s string) {
	m.cover_image_url = &s
}

// CoverImageURL returns the value of the "cover_image_url" field in the mutation.
func (m *AppInfoMutation) CoverImageURL() (r string, exists bool) {
	v := m.cover_image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImageURL returns the old "cover_image_url" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldCoverImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImageURL: %w", err)
	}
	return oldValue.CoverImageURL, nil
}

// ClearCoverImageURL clears the value of the "cover_image_url" field.
func (m *AppInfoMutation) ClearCoverImageURL() {
	m.cover_image_url = nil
	m.clearedFields[appinfo.FieldCoverImageURL] = struct{}{}
}

// CoverImageURLCleared returns if the "cover_image_url" field was cleared in this mutation.
func (m *AppInfoMutation) CoverImageURLCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldCoverImageURL]
	return ok
}

// ResetCoverImageURL resets all changes to the "cover_image_url" field.
func (m *AppInfoMutation) ResetCoverImageURL() {
	m.cover_image_url = nil
	delete(m.clearedFields, appinfo.FieldCoverImageURL)
}

// SetCoverImageID sets the "cover_image_id" field.
func (m *AppInfoMutation) SetCoverImageID(mi model.InternalID) {
	m.cover_image_id = &mi
	m.addcover_image_id = nil
}

// CoverImageID returns the value of the "cover_image_id" field in the mutation.
func (m *AppInfoMutation) CoverImageID() (r model.InternalID, exists bool) {
	v := m.cover_image_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCoverImageID returns the old "cover_image_id" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldCoverImageID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCoverImageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCoverImageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCoverImageID: %w", err)
	}
	return oldValue.CoverImageID, nil
}

// AddCoverImageID adds mi to the "cover_image_id" field.
func (m *AppInfoMutation) AddCoverImageID(mi model.InternalID) {
	if m.addcover_image_id != nil {
		*m.addcover_image_id += mi
	} else {
		m.addcover_image_id = &mi
	}
}

// AddedCoverImageID returns the value that was added to the "cover_image_id" field in this mutation.
func (m *AppInfoMutation) AddedCoverImageID() (r model.InternalID, exists bool) {
	v := m.addcover_image_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCoverImageID resets all changes to the "cover_image_id" field.
func (m *AppInfoMutation) ResetCoverImageID() {
	m.cover_image_id = nil
	m.addcover_image_id = nil
}

// SetReleaseDate sets the "release_date" field.
func (m *AppInfoMutation) SetReleaseDate(s string) {
	m.release_date = &s
}

// ReleaseDate returns the value of the "release_date" field in the mutation.
func (m *AppInfoMutation) ReleaseDate() (r string, exists bool) {
	v := m.release_date
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "release_date" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldReleaseDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ClearReleaseDate clears the value of the "release_date" field.
func (m *AppInfoMutation) ClearReleaseDate() {
	m.release_date = nil
	m.clearedFields[appinfo.FieldReleaseDate] = struct{}{}
}

// ReleaseDateCleared returns if the "release_date" field was cleared in this mutation.
func (m *AppInfoMutation) ReleaseDateCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldReleaseDate]
	return ok
}

// ResetReleaseDate resets all changes to the "release_date" field.
func (m *AppInfoMutation) ResetReleaseDate() {
	m.release_date = nil
	delete(m.clearedFields, appinfo.FieldReleaseDate)
}

// SetDeveloper sets the "developer" field.
func (m *AppInfoMutation) SetDeveloper(s string) {
	m.developer = &s
}

// Developer returns the value of the "developer" field in the mutation.
func (m *AppInfoMutation) Developer() (r string, exists bool) {
	v := m.developer
	if v == nil {
		return
	}
	return *v, true
}

// OldDeveloper returns the old "developer" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldDeveloper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeveloper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeveloper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeveloper: %w", err)
	}
	return oldValue.Developer, nil
}

// ClearDeveloper clears the value of the "developer" field.
func (m *AppInfoMutation) ClearDeveloper() {
	m.developer = nil
	m.clearedFields[appinfo.FieldDeveloper] = struct{}{}
}

// DeveloperCleared returns if the "developer" field was cleared in this mutation.
func (m *AppInfoMutation) DeveloperCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldDeveloper]
	return ok
}

// ResetDeveloper resets all changes to the "developer" field.
func (m *AppInfoMutation) ResetDeveloper() {
	m.developer = nil
	delete(m.clearedFields, appinfo.FieldDeveloper)
}

// SetPublisher sets the "publisher" field.
func (m *AppInfoMutation) SetPublisher(s string) {
	m.publisher = &s
}

// Publisher returns the value of the "publisher" field in the mutation.
func (m *AppInfoMutation) Publisher() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisher returns the old "publisher" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldPublisher(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisher: %w", err)
	}
	return oldValue.Publisher, nil
}

// ClearPublisher clears the value of the "publisher" field.
func (m *AppInfoMutation) ClearPublisher() {
	m.publisher = nil
	m.clearedFields[appinfo.FieldPublisher] = struct{}{}
}

// PublisherCleared returns if the "publisher" field was cleared in this mutation.
func (m *AppInfoMutation) PublisherCleared() bool {
	_, ok := m.clearedFields[appinfo.FieldPublisher]
	return ok
}

// ResetPublisher resets all changes to the "publisher" field.
func (m *AppInfoMutation) ResetPublisher() {
	m.publisher = nil
	delete(m.clearedFields, appinfo.FieldPublisher)
}

// SetTags sets the "tags" field.
func (m *AppInfoMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *AppInfoMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *AppInfoMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *AppInfoMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *AppInfoMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetAlternativeNames sets the "alternative_names" field.
func (m *AppInfoMutation) SetAlternativeNames(s []string) {
	m.alternative_names = &s
	m.appendalternative_names = nil
}

// AlternativeNames returns the value of the "alternative_names" field in the mutation.
func (m *AppInfoMutation) AlternativeNames() (r []string, exists bool) {
	v := m.alternative_names
	if v == nil {
		return
	}
	return *v, true
}

// OldAlternativeNames returns the old "alternative_names" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldAlternativeNames(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlternativeNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlternativeNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlternativeNames: %w", err)
	}
	return oldValue.AlternativeNames, nil
}

// AppendAlternativeNames adds s to the "alternative_names" field.
func (m *AppInfoMutation) AppendAlternativeNames(s []string) {
	m.appendalternative_names = append(m.appendalternative_names, s...)
}

// AppendedAlternativeNames returns the list of values that were appended to the "alternative_names" field in this mutation.
func (m *AppInfoMutation) AppendedAlternativeNames() ([]string, bool) {
	if len(m.appendalternative_names) == 0 {
		return nil, false
	}
	return m.appendalternative_names, true
}

// ResetAlternativeNames resets all changes to the "alternative_names" field.
func (m *AppInfoMutation) ResetAlternativeNames() {
	m.alternative_names = nil
	m.appendalternative_names = nil
}

// SetRawData sets the "raw_data" field.
func (m *AppInfoMutation) SetRawData(s string) {
	m.raw_data = &s
}

// RawData returns the value of the "raw_data" field in the mutation.
func (m *AppInfoMutation) RawData() (r string, exists bool) {
	v := m.raw_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRawData returns the old "raw_data" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldRawData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawData: %w", err)
	}
	return oldValue.RawData, nil
}

// ResetRawData resets all changes to the "raw_data" field.
func (m *AppInfoMutation) ResetRawData() {
	m.raw_data = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppInfo entity.
// If the AppInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the AppInfoMutation builder.
func (m *AppInfoMutation) Where(ps ...predicate.AppInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppInfo).
func (m *AppInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppInfoMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.source != nil {
		fields = append(fields, appinfo.FieldSource)
	}
	if m.source_app_id != nil {
		fields = append(fields, appinfo.FieldSourceAppID)
	}
	if m.source_url != nil {
		fields = append(fields, appinfo.FieldSourceURL)
	}
	if m.name != nil {
		fields = append(fields, appinfo.FieldName)
	}
	if m._type != nil {
		fields = append(fields, appinfo.FieldType)
	}
	if m.short_description != nil {
		fields = append(fields, appinfo.FieldShortDescription)
	}
	if m.description != nil {
		fields = append(fields, appinfo.FieldDescription)
	}
	if m.icon_image_url != nil {
		fields = append(fields, appinfo.FieldIconImageURL)
	}
	if m.icon_image_id != nil {
		fields = append(fields, appinfo.FieldIconImageID)
	}
	if m.background_image_url != nil {
		fields = append(fields, appinfo.FieldBackgroundImageURL)
	}
	if m.background_image_id != nil {
		fields = append(fields, appinfo.FieldBackgroundImageID)
	}
	if m.cover_image_url != nil {
		fields = append(fields, appinfo.FieldCoverImageURL)
	}
	if m.cover_image_id != nil {
		fields = append(fields, appinfo.FieldCoverImageID)
	}
	if m.release_date != nil {
		fields = append(fields, appinfo.FieldReleaseDate)
	}
	if m.developer != nil {
		fields = append(fields, appinfo.FieldDeveloper)
	}
	if m.publisher != nil {
		fields = append(fields, appinfo.FieldPublisher)
	}
	if m.tags != nil {
		fields = append(fields, appinfo.FieldTags)
	}
	if m.alternative_names != nil {
		fields = append(fields, appinfo.FieldAlternativeNames)
	}
	if m.raw_data != nil {
		fields = append(fields, appinfo.FieldRawData)
	}
	if m.updated_at != nil {
		fields = append(fields, appinfo.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, appinfo.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appinfo.FieldSource:
		return m.Source()
	case appinfo.FieldSourceAppID:
		return m.SourceAppID()
	case appinfo.FieldSourceURL:
		return m.SourceURL()
	case appinfo.FieldName:
		return m.Name()
	case appinfo.FieldType:
		return m.GetType()
	case appinfo.FieldShortDescription:
		return m.ShortDescription()
	case appinfo.FieldDescription:
		return m.Description()
	case appinfo.FieldIconImageURL:
		return m.IconImageURL()
	case appinfo.FieldIconImageID:
		return m.IconImageID()
	case appinfo.FieldBackgroundImageURL:
		return m.BackgroundImageURL()
	case appinfo.FieldBackgroundImageID:
		return m.BackgroundImageID()
	case appinfo.FieldCoverImageURL:
		return m.CoverImageURL()
	case appinfo.FieldCoverImageID:
		return m.CoverImageID()
	case appinfo.FieldReleaseDate:
		return m.ReleaseDate()
	case appinfo.FieldDeveloper:
		return m.Developer()
	case appinfo.FieldPublisher:
		return m.Publisher()
	case appinfo.FieldTags:
		return m.Tags()
	case appinfo.FieldAlternativeNames:
		return m.AlternativeNames()
	case appinfo.FieldRawData:
		return m.RawData()
	case appinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case appinfo.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appinfo.FieldSource:
		return m.OldSource(ctx)
	case appinfo.FieldSourceAppID:
		return m.OldSourceAppID(ctx)
	case appinfo.FieldSourceURL:
		return m.OldSourceURL(ctx)
	case appinfo.FieldName:
		return m.OldName(ctx)
	case appinfo.FieldType:
		return m.OldType(ctx)
	case appinfo.FieldShortDescription:
		return m.OldShortDescription(ctx)
	case appinfo.FieldDescription:
		return m.OldDescription(ctx)
	case appinfo.FieldIconImageURL:
		return m.OldIconImageURL(ctx)
	case appinfo.FieldIconImageID:
		return m.OldIconImageID(ctx)
	case appinfo.FieldBackgroundImageURL:
		return m.OldBackgroundImageURL(ctx)
	case appinfo.FieldBackgroundImageID:
		return m.OldBackgroundImageID(ctx)
	case appinfo.FieldCoverImageURL:
		return m.OldCoverImageURL(ctx)
	case appinfo.FieldCoverImageID:
		return m.OldCoverImageID(ctx)
	case appinfo.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case appinfo.FieldDeveloper:
		return m.OldDeveloper(ctx)
	case appinfo.FieldPublisher:
		return m.OldPublisher(ctx)
	case appinfo.FieldTags:
		return m.OldTags(ctx)
	case appinfo.FieldAlternativeNames:
		return m.OldAlternativeNames(ctx)
	case appinfo.FieldRawData:
		return m.OldRawData(ctx)
	case appinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appinfo.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case appinfo.FieldSourceAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceAppID(v)
		return nil
	case appinfo.FieldSourceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceURL(v)
		return nil
	case appinfo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appinfo.FieldType:
		v, ok := value.(appinfo.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case appinfo.FieldShortDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShortDescription(v)
		return nil
	case appinfo.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case appinfo.FieldIconImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconImageURL(v)
		return nil
	case appinfo.FieldIconImageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconImageID(v)
		return nil
	case appinfo.FieldBackgroundImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundImageURL(v)
		return nil
	case appinfo.FieldBackgroundImageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundImageID(v)
		return nil
	case appinfo.FieldCoverImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImageURL(v)
		return nil
	case appinfo.FieldCoverImageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCoverImageID(v)
		return nil
	case appinfo.FieldReleaseDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case appinfo.FieldDeveloper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeveloper(v)
		return nil
	case appinfo.FieldPublisher:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisher(v)
		return nil
	case appinfo.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case appinfo.FieldAlternativeNames:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlternativeNames(v)
		return nil
	case appinfo.FieldRawData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawData(v)
		return nil
	case appinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppInfoMutation) AddedFields() []string {
	var fields []string
	if m.addicon_image_id != nil {
		fields = append(fields, appinfo.FieldIconImageID)
	}
	if m.addbackground_image_id != nil {
		fields = append(fields, appinfo.FieldBackgroundImageID)
	}
	if m.addcover_image_id != nil {
		fields = append(fields, appinfo.FieldCoverImageID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appinfo.FieldIconImageID:
		return m.AddedIconImageID()
	case appinfo.FieldBackgroundImageID:
		return m.AddedBackgroundImageID()
	case appinfo.FieldCoverImageID:
		return m.AddedCoverImageID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appinfo.FieldIconImageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIconImageID(v)
		return nil
	case appinfo.FieldBackgroundImageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBackgroundImageID(v)
		return nil
	case appinfo.FieldCoverImageID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCoverImageID(v)
		return nil
	}
	return fmt.Errorf("unknown AppInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appinfo.FieldSourceURL) {
		fields = append(fields, appinfo.FieldSourceURL)
	}
	if m.FieldCleared(appinfo.FieldShortDescription) {
		fields = append(fields, appinfo.FieldShortDescription)
	}
	if m.FieldCleared(appinfo.FieldDescription) {
		fields = append(fields, appinfo.FieldDescription)
	}
	if m.FieldCleared(appinfo.FieldIconImageURL) {
		fields = append(fields, appinfo.FieldIconImageURL)
	}
	if m.FieldCleared(appinfo.FieldBackgroundImageURL) {
		fields = append(fields, appinfo.FieldBackgroundImageURL)
	}
	if m.FieldCleared(appinfo.FieldCoverImageURL) {
		fields = append(fields, appinfo.FieldCoverImageURL)
	}
	if m.FieldCleared(appinfo.FieldReleaseDate) {
		fields = append(fields, appinfo.FieldReleaseDate)
	}
	if m.FieldCleared(appinfo.FieldDeveloper) {
		fields = append(fields, appinfo.FieldDeveloper)
	}
	if m.FieldCleared(appinfo.FieldPublisher) {
		fields = append(fields, appinfo.FieldPublisher)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppInfoMutation) ClearField(name string) error {
	switch name {
	case appinfo.FieldSourceURL:
		m.ClearSourceURL()
		return nil
	case appinfo.FieldShortDescription:
		m.ClearShortDescription()
		return nil
	case appinfo.FieldDescription:
		m.ClearDescription()
		return nil
	case appinfo.FieldIconImageURL:
		m.ClearIconImageURL()
		return nil
	case appinfo.FieldBackgroundImageURL:
		m.ClearBackgroundImageURL()
		return nil
	case appinfo.FieldCoverImageURL:
		m.ClearCoverImageURL()
		return nil
	case appinfo.FieldReleaseDate:
		m.ClearReleaseDate()
		return nil
	case appinfo.FieldDeveloper:
		m.ClearDeveloper()
		return nil
	case appinfo.FieldPublisher:
		m.ClearPublisher()
		return nil
	}
	return fmt.Errorf("unknown AppInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppInfoMutation) ResetField(name string) error {
	switch name {
	case appinfo.FieldSource:
		m.ResetSource()
		return nil
	case appinfo.FieldSourceAppID:
		m.ResetSourceAppID()
		return nil
	case appinfo.FieldSourceURL:
		m.ResetSourceURL()
		return nil
	case appinfo.FieldName:
		m.ResetName()
		return nil
	case appinfo.FieldType:
		m.ResetType()
		return nil
	case appinfo.FieldShortDescription:
		m.ResetShortDescription()
		return nil
	case appinfo.FieldDescription:
		m.ResetDescription()
		return nil
	case appinfo.FieldIconImageURL:
		m.ResetIconImageURL()
		return nil
	case appinfo.FieldIconImageID:
		m.ResetIconImageID()
		return nil
	case appinfo.FieldBackgroundImageURL:
		m.ResetBackgroundImageURL()
		return nil
	case appinfo.FieldBackgroundImageID:
		m.ResetBackgroundImageID()
		return nil
	case appinfo.FieldCoverImageURL:
		m.ResetCoverImageURL()
		return nil
	case appinfo.FieldCoverImageID:
		m.ResetCoverImageID()
		return nil
	case appinfo.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case appinfo.FieldDeveloper:
		m.ResetDeveloper()
		return nil
	case appinfo.FieldPublisher:
		m.ResetPublisher()
		return nil
	case appinfo.FieldTags:
		m.ResetTags()
		return nil
	case appinfo.FieldAlternativeNames:
		m.ResetAlternativeNames()
		return nil
	case appinfo.FieldRawData:
		m.ResetRawData()
		return nil
	case appinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppInfo edge %s", name)
}

// AppRunTimeMutation represents an operation that mutates the AppRunTime nodes in the graph.
type AppRunTimeMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	user_id       *model.InternalID
	adduser_id    *model.InternalID
	device_id     *model.InternalID
	adddevice_id  *model.InternalID
	start_time    *time.Time
	duration      *time.Duration
	addduration   *time.Duration
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	app           *model.InternalID
	clearedapp    bool
	done          bool
	oldValue      func(context.Context) (*AppRunTime, error)
	predicates    []predicate.AppRunTime
}

var _ ent.Mutation = (*AppRunTimeMutation)(nil)

// appruntimeOption allows management of the mutation configuration using functional options.
type appruntimeOption func(*AppRunTimeMutation)

// newAppRunTimeMutation creates new mutation for the AppRunTime entity.
func newAppRunTimeMutation(c config, op Op, opts ...appruntimeOption) *AppRunTimeMutation {
	m := &AppRunTimeMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRunTime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRunTimeID sets the ID field of the mutation.
func withAppRunTimeID(id model.InternalID) appruntimeOption {
	return func(m *AppRunTimeMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRunTime
		)
		m.oldValue = func(ctx context.Context) (*AppRunTime, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRunTime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRunTime sets the old AppRunTime of the mutation.
func withAppRunTime(node *AppRunTime) appruntimeOption {
	return func(m *AppRunTimeMutation) {
		m.oldValue = func(context.Context) (*AppRunTime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRunTimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRunTimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRunTime entities.
func (m *AppRunTimeMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRunTimeMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRunTimeMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRunTime.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AppRunTimeMutation) SetUserID(mi model.InternalID) {
	m.user_id = &mi
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AppRunTimeMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AppRunTime entity.
// If the AppRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRunTimeMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds mi to the "user_id" field.
func (m *AppRunTimeMutation) AddUserID(mi model.InternalID) {
	if m.adduser_id != nil {
		*m.adduser_id += mi
	} else {
		m.adduser_id = &mi
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AppRunTimeMutation) AddedUserID() (r model.InternalID, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AppRunTimeMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetAppID sets the "app_id" field.
func (m *AppRunTimeMutation) SetAppID(mi model.InternalID) {
	m.app = &mi
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRunTimeMutation) AppID() (r model.InternalID, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRunTime entity.
// If the AppRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRunTimeMutation) OldAppID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRunTimeMutation) ResetAppID() {
	m.app = nil
}

// SetDeviceID sets the "device_id" field.
func (m *AppRunTimeMutation) SetDeviceID(mi model.InternalID) {
	m.device_id = &mi
	m.adddevice_id = nil
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *AppRunTimeMutation) DeviceID() (r model.InternalID, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the AppRunTime entity.
// If the AppRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRunTimeMutation) OldDeviceID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// AddDeviceID adds mi to the "device_id" field.
func (m *AppRunTimeMutation) AddDeviceID(mi model.InternalID) {
	if m.adddevice_id != nil {
		*m.adddevice_id += mi
	} else {
		m.adddevice_id = &mi
	}
}

// AddedDeviceID returns the value that was added to the "device_id" field in this mutation.
func (m *AppRunTimeMutation) AddedDeviceID() (r model.InternalID, exists bool) {
	v := m.adddevice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *AppRunTimeMutation) ResetDeviceID() {
	m.device_id = nil
	m.adddevice_id = nil
}

// SetStartTime sets the "start_time" field.
func (m *AppRunTimeMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *AppRunTimeMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the AppRunTime entity.
// If the AppRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRunTimeMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *AppRunTimeMutation) ResetStartTime() {
	m.start_time = nil
}

// SetDuration sets the "duration" field.
func (m *AppRunTimeMutation) SetDuration(t time.Duration) {
	m.duration = &t
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *AppRunTimeMutation) Duration() (r time.Duration, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the AppRunTime entity.
// If the AppRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRunTimeMutation) OldDuration(ctx context.Context) (v time.Duration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds t to the "duration" field.
func (m *AppRunTimeMutation) AddDuration(t time.Duration) {
	if m.addduration != nil {
		*m.addduration += t
	} else {
		m.addduration = &t
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *AppRunTimeMutation) AddedDuration() (r time.Duration, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ResetDuration resets all changes to the "duration" field.
func (m *AppRunTimeMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRunTimeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRunTimeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRunTime entity.
// If the AppRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRunTimeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRunTimeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRunTimeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRunTimeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRunTime entity.
// If the AppRunTime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRunTimeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRunTimeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppRunTimeMutation) ClearApp() {
	m.clearedapp = true
	m.clearedFields[appruntime.FieldAppID] = struct{}{}
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppRunTimeMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppRunTimeMutation) AppIDs() (ids []model.InternalID) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppRunTimeMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// Where appends a list predicates to the AppRunTimeMutation builder.
func (m *AppRunTimeMutation) Where(ps ...predicate.AppRunTime) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppRunTimeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppRunTimeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppRunTime, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppRunTimeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppRunTimeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppRunTime).
func (m *AppRunTimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRunTimeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user_id != nil {
		fields = append(fields, appruntime.FieldUserID)
	}
	if m.app != nil {
		fields = append(fields, appruntime.FieldAppID)
	}
	if m.device_id != nil {
		fields = append(fields, appruntime.FieldDeviceID)
	}
	if m.start_time != nil {
		fields = append(fields, appruntime.FieldStartTime)
	}
	if m.duration != nil {
		fields = append(fields, appruntime.FieldDuration)
	}
	if m.updated_at != nil {
		fields = append(fields, appruntime.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, appruntime.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRunTimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appruntime.FieldUserID:
		return m.UserID()
	case appruntime.FieldAppID:
		return m.AppID()
	case appruntime.FieldDeviceID:
		return m.DeviceID()
	case appruntime.FieldStartTime:
		return m.StartTime()
	case appruntime.FieldDuration:
		return m.Duration()
	case appruntime.FieldUpdatedAt:
		return m.UpdatedAt()
	case appruntime.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRunTimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appruntime.FieldUserID:
		return m.OldUserID(ctx)
	case appruntime.FieldAppID:
		return m.OldAppID(ctx)
	case appruntime.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case appruntime.FieldStartTime:
		return m.OldStartTime(ctx)
	case appruntime.FieldDuration:
		return m.OldDuration(ctx)
	case appruntime.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appruntime.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AppRunTime field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRunTimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appruntime.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case appruntime.FieldAppID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appruntime.FieldDeviceID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case appruntime.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case appruntime.FieldDuration:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case appruntime.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appruntime.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AppRunTime field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRunTimeMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, appruntime.FieldUserID)
	}
	if m.adddevice_id != nil {
		fields = append(fields, appruntime.FieldDeviceID)
	}
	if m.addduration != nil {
		fields = append(fields, appruntime.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRunTimeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case appruntime.FieldUserID:
		return m.AddedUserID()
	case appruntime.FieldDeviceID:
		return m.AddedDeviceID()
	case appruntime.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRunTimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case appruntime.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case appruntime.FieldDeviceID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceID(v)
		return nil
	case appruntime.FieldDuration:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown AppRunTime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRunTimeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRunTimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRunTimeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AppRunTime nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRunTimeMutation) ResetField(name string) error {
	switch name {
	case appruntime.FieldUserID:
		m.ResetUserID()
		return nil
	case appruntime.FieldAppID:
		m.ResetAppID()
		return nil
	case appruntime.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case appruntime.FieldStartTime:
		m.ResetStartTime()
		return nil
	case appruntime.FieldDuration:
		m.ResetDuration()
		return nil
	case appruntime.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appruntime.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppRunTime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRunTimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.app != nil {
		edges = append(edges, appruntime.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRunTimeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appruntime.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRunTimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRunTimeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRunTimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapp {
		edges = append(edges, appruntime.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRunTimeMutation) EdgeCleared(name string) bool {
	switch name {
	case appruntime.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRunTimeMutation) ClearEdge(name string) error {
	switch name {
	case appruntime.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppRunTime unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRunTimeMutation) ResetEdge(name string) error {
	switch name {
	case appruntime.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown AppRunTime edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op                         Op
	typ                        string
	id                         *model.InternalID
	device_name                *string
	system_type                *device.SystemType
	system_version             *string
	client_name                *string
	client_source_code_address *string
	client_version             *string
	client_local_id            *string
	updated_at                 *time.Time
	created_at                 *time.Time
	clearedFields              map[string]struct{}
	session                    map[model.InternalID]struct{}
	removedsession             map[model.InternalID]struct{}
	clearedsession             bool
	app                        map[model.InternalID]struct{}
	removedapp                 map[model.InternalID]struct{}
	clearedapp                 bool
	done                       bool
	oldValue                   func(context.Context) (*Device, error)
	predicates                 []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id model.InternalID) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Device entities.
func (m *DeviceMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Device.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeviceName sets the "device_name" field.
func (m *DeviceMutation) SetDeviceName(s string) {
	m.device_name = &s
}

// DeviceName returns the value of the "device_name" field in the mutation.
func (m *DeviceMutation) DeviceName() (r string, exists bool) {
	v := m.device_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "device_name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldDeviceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ResetDeviceName resets all changes to the "device_name" field.
func (m *DeviceMutation) ResetDeviceName() {
	m.device_name = nil
}

// SetSystemType sets the "system_type" field.
func (m *DeviceMutation) SetSystemType(dt device.SystemType) {
	m.system_type = &dt
}

// SystemType returns the value of the "system_type" field in the mutation.
func (m *DeviceMutation) SystemType() (r device.SystemType, exists bool) {
	v := m.system_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemType returns the old "system_type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSystemType(ctx context.Context) (v device.SystemType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemType: %w", err)
	}
	return oldValue.SystemType, nil
}

// ResetSystemType resets all changes to the "system_type" field.
func (m *DeviceMutation) ResetSystemType() {
	m.system_type = nil
}

// SetSystemVersion sets the "system_version" field.
func (m *DeviceMutation) SetSystemVersion(s string) {
	m.system_version = &s
}

// SystemVersion returns the value of the "system_version" field in the mutation.
func (m *DeviceMutation) SystemVersion() (r string, exists bool) {
	v := m.system_version
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemVersion returns the old "system_version" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldSystemVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemVersion: %w", err)
	}
	return oldValue.SystemVersion, nil
}

// ResetSystemVersion resets all changes to the "system_version" field.
func (m *DeviceMutation) ResetSystemVersion() {
	m.system_version = nil
}

// SetClientName sets the "client_name" field.
func (m *DeviceMutation) SetClientName(s string) {
	m.client_name = &s
}

// ClientName returns the value of the "client_name" field in the mutation.
func (m *DeviceMutation) ClientName() (r string, exists bool) {
	v := m.client_name
	if v == nil {
		return
	}
	return *v, true
}

// OldClientName returns the old "client_name" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldClientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientName: %w", err)
	}
	return oldValue.ClientName, nil
}

// ResetClientName resets all changes to the "client_name" field.
func (m *DeviceMutation) ResetClientName() {
	m.client_name = nil
}

// SetClientSourceCodeAddress sets the "client_source_code_address" field.
func (m *DeviceMutation) SetClientSourceCodeAddress(s string) {
	m.client_source_code_address = &s
}

// ClientSourceCodeAddress returns the value of the "client_source_code_address" field in the mutation.
func (m *DeviceMutation) ClientSourceCodeAddress() (r string, exists bool) {
	v := m.client_source_code_address
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSourceCodeAddress returns the old "client_source_code_address" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldClientSourceCodeAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSourceCodeAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSourceCodeAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSourceCodeAddress: %w", err)
	}
	return oldValue.ClientSourceCodeAddress, nil
}

// ResetClientSourceCodeAddress resets all changes to the "client_source_code_address" field.
func (m *DeviceMutation) ResetClientSourceCodeAddress() {
	m.client_source_code_address = nil
}

// SetClientVersion sets the "client_version" field.
func (m *DeviceMutation) SetClientVersion(s string) {
	m.client_version = &s
}

// ClientVersion returns the value of the "client_version" field in the mutation.
func (m *DeviceMutation) ClientVersion() (r string, exists bool) {
	v := m.client_version
	if v == nil {
		return
	}
	return *v, true
}

// OldClientVersion returns the old "client_version" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldClientVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientVersion: %w", err)
	}
	return oldValue.ClientVersion, nil
}

// ResetClientVersion resets all changes to the "client_version" field.
func (m *DeviceMutation) ResetClientVersion() {
	m.client_version = nil
}

// SetClientLocalID sets the "client_local_id" field.
func (m *DeviceMutation) SetClientLocalID(s string) {
	m.client_local_id = &s
}

// ClientLocalID returns the value of the "client_local_id" field in the mutation.
func (m *DeviceMutation) ClientLocalID() (r string, exists bool) {
	v := m.client_local_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientLocalID returns the old "client_local_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldClientLocalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientLocalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientLocalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientLocalID: %w", err)
	}
	return oldValue.ClientLocalID, nil
}

// ClearClientLocalID clears the value of the "client_local_id" field.
func (m *DeviceMutation) ClearClientLocalID() {
	m.client_local_id = nil
	m.clearedFields[device.FieldClientLocalID] = struct{}{}
}

// ClientLocalIDCleared returns if the "client_local_id" field was cleared in this mutation.
func (m *DeviceMutation) ClientLocalIDCleared() bool {
	_, ok := m.clearedFields[device.FieldClientLocalID]
	return ok
}

// ResetClientLocalID resets all changes to the "client_local_id" field.
func (m *DeviceMutation) ResetClientLocalID() {
	m.client_local_id = nil
	delete(m.clearedFields, device.FieldClientLocalID)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeviceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeviceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeviceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeviceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeviceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeviceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddSessionIDs adds the "session" edge to the Session entity by ids.
func (m *DeviceMutation) AddSessionIDs(ids ...model.InternalID) {
	if m.session == nil {
		m.session = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.session[ids[i]] = struct{}{}
	}
}

// ClearSession clears the "session" edge to the Session entity.
func (m *DeviceMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the Session entity was cleared.
func (m *DeviceMutation) SessionCleared() bool {
	return m.clearedsession
}

// RemoveSessionIDs removes the "session" edge to the Session entity by IDs.
func (m *DeviceMutation) RemoveSessionIDs(ids ...model.InternalID) {
	if m.removedsession == nil {
		m.removedsession = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.session, ids[i])
		m.removedsession[ids[i]] = struct{}{}
	}
}

// RemovedSession returns the removed IDs of the "session" edge to the Session entity.
func (m *DeviceMutation) RemovedSessionIDs() (ids []model.InternalID) {
	for id := range m.removedsession {
		ids = append(ids, id)
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
func (m *DeviceMutation) SessionIDs() (ids []model.InternalID) {
	for id := range m.session {
		ids = append(ids, id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *DeviceMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
	m.removedsession = nil
}

// AddAppIDs adds the "app" edge to the App entity by ids.
func (m *DeviceMutation) AddAppIDs(ids ...model.InternalID) {
	if m.app == nil {
		m.app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.app[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "app" edge to the App entity.
func (m *DeviceMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *DeviceMutation) AppCleared() bool {
	return m.clearedapp
}

// RemoveAppIDs removes the "app" edge to the App entity by IDs.
func (m *DeviceMutation) RemoveAppIDs(ids ...model.InternalID) {
	if m.removedapp == nil {
		m.removedapp = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.app, ids[i])
		m.removedapp[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "app" edge to the App entity.
func (m *DeviceMutation) RemovedAppIDs() (ids []model.InternalID) {
	for id := range m.removedapp {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
func (m *DeviceMutation) AppIDs() (ids []model.InternalID) {
	for id := range m.app {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *DeviceMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
	m.removedapp = nil
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Device, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.device_name != nil {
		fields = append(fields, device.FieldDeviceName)
	}
	if m.system_type != nil {
		fields = append(fields, device.FieldSystemType)
	}
	if m.system_version != nil {
		fields = append(fields, device.FieldSystemVersion)
	}
	if m.client_name != nil {
		fields = append(fields, device.FieldClientName)
	}
	if m.client_source_code_address != nil {
		fields = append(fields, device.FieldClientSourceCodeAddress)
	}
	if m.client_version != nil {
		fields = append(fields, device.FieldClientVersion)
	}
	if m.client_local_id != nil {
		fields = append(fields, device.FieldClientLocalID)
	}
	if m.updated_at != nil {
		fields = append(fields, device.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, device.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldDeviceName:
		return m.DeviceName()
	case device.FieldSystemType:
		return m.SystemType()
	case device.FieldSystemVersion:
		return m.SystemVersion()
	case device.FieldClientName:
		return m.ClientName()
	case device.FieldClientSourceCodeAddress:
		return m.ClientSourceCodeAddress()
	case device.FieldClientVersion:
		return m.ClientVersion()
	case device.FieldClientLocalID:
		return m.ClientLocalID()
	case device.FieldUpdatedAt:
		return m.UpdatedAt()
	case device.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case device.FieldSystemType:
		return m.OldSystemType(ctx)
	case device.FieldSystemVersion:
		return m.OldSystemVersion(ctx)
	case device.FieldClientName:
		return m.OldClientName(ctx)
	case device.FieldClientSourceCodeAddress:
		return m.OldClientSourceCodeAddress(ctx)
	case device.FieldClientVersion:
		return m.OldClientVersion(ctx)
	case device.FieldClientLocalID:
		return m.OldClientLocalID(ctx)
	case device.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case device.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case device.FieldSystemType:
		v, ok := value.(device.SystemType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemType(v)
		return nil
	case device.FieldSystemVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemVersion(v)
		return nil
	case device.FieldClientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientName(v)
		return nil
	case device.FieldClientSourceCodeAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSourceCodeAddress(v)
		return nil
	case device.FieldClientVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientVersion(v)
		return nil
	case device.FieldClientLocalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientLocalID(v)
		return nil
	case device.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case device.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldClientLocalID) {
		fields = append(fields, device.FieldClientLocalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldClientLocalID:
		m.ClearClientLocalID()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case device.FieldSystemType:
		m.ResetSystemType()
		return nil
	case device.FieldSystemVersion:
		m.ResetSystemVersion()
		return nil
	case device.FieldClientName:
		m.ResetClientName()
		return nil
	case device.FieldClientSourceCodeAddress:
		m.ResetClientSourceCodeAddress()
		return nil
	case device.FieldClientVersion:
		m.ResetClientVersion()
		return nil
	case device.FieldClientLocalID:
		m.ResetClientLocalID()
		return nil
	case device.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case device.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.session != nil {
		edges = append(edges, device.EdgeSession)
	}
	if m.app != nil {
		edges = append(edges, device.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeSession:
		ids := make([]ent.Value, 0, len(m.session))
		for id := range m.session {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeApp:
		ids := make([]ent.Value, 0, len(m.app))
		for id := range m.app {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsession != nil {
		edges = append(edges, device.EdgeSession)
	}
	if m.removedapp != nil {
		edges = append(edges, device.EdgeApp)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeSession:
		ids := make([]ent.Value, 0, len(m.removedsession))
		for id := range m.removedsession {
			ids = append(ids, id)
		}
		return ids
	case device.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removedapp))
		for id := range m.removedapp {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsession {
		edges = append(edges, device.EdgeSession)
	}
	if m.clearedapp {
		edges = append(edges, device.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeSession:
		return m.clearedsession
	case device.EdgeApp:
		return m.clearedapp
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeSession:
		m.ResetSession()
		return nil
	case device.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// FeedMutation represents an operation that mutates the Feed nodes in the graph.
type FeedMutation struct {
	config
	op             Op
	typ            string
	id             *model.InternalID
	title          *string
	link           *string
	description    *string
	language       *string
	authors        *[]*modelfeed.Person
	appendauthors  []*modelfeed.Person
	image          **modelfeed.Image
	updated_at     *time.Time
	created_at     *time.Time
	clearedFields  map[string]struct{}
	item           map[model.InternalID]struct{}
	removeditem    map[model.InternalID]struct{}
	cleareditem    bool
	_config        *model.InternalID
	cleared_config bool
	done           bool
	oldValue       func(context.Context) (*Feed, error)
	predicates     []predicate.Feed
}

var _ ent.Mutation = (*FeedMutation)(nil)

// feedOption allows management of the mutation configuration using functional options.
type feedOption func(*FeedMutation)

// newFeedMutation creates new mutation for the Feed entity.
func newFeedMutation(c config, op Op, opts ...feedOption) *FeedMutation {
	m := &FeedMutation{
		config:        c,
		op:            op,
		typ:           TypeFeed,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedID sets the ID field of the mutation.
func withFeedID(id model.InternalID) feedOption {
	return func(m *FeedMutation) {
		var (
			err   error
			once  sync.Once
			value *Feed
		)
		m.oldValue = func(ctx context.Context) (*Feed, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feed.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeed sets the old Feed of the mutation.
func withFeed(node *Feed) feedOption {
	return func(m *FeedMutation) {
		m.oldValue = func(context.Context) (*Feed, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Feed entities.
func (m *FeedMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feed.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *FeedMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *FeedMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *FeedMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[feed.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *FeedMutation) TitleCleared() bool {
	_, ok := m.clearedFields[feed.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *FeedMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, feed.FieldTitle)
}

// SetLink sets the "link" field.
func (m *FeedMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *FeedMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *FeedMutation) ClearLink() {
	m.link = nil
	m.clearedFields[feed.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *FeedMutation) LinkCleared() bool {
	_, ok := m.clearedFields[feed.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *FeedMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, feed.FieldLink)
}

// SetDescription sets the "description" field.
func (m *FeedMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeedMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeedMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[feed.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeedMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[feed.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeedMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, feed.FieldDescription)
}

// SetLanguage sets the "language" field.
func (m *FeedMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *FeedMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ClearLanguage clears the value of the "language" field.
func (m *FeedMutation) ClearLanguage() {
	m.language = nil
	m.clearedFields[feed.FieldLanguage] = struct{}{}
}

// LanguageCleared returns if the "language" field was cleared in this mutation.
func (m *FeedMutation) LanguageCleared() bool {
	_, ok := m.clearedFields[feed.FieldLanguage]
	return ok
}

// ResetLanguage resets all changes to the "language" field.
func (m *FeedMutation) ResetLanguage() {
	m.language = nil
	delete(m.clearedFields, feed.FieldLanguage)
}

// SetAuthors sets the "authors" field.
func (m *FeedMutation) SetAuthors(value []*modelfeed.Person) {
	m.authors = &value
	m.appendauthors = nil
}

// Authors returns the value of the "authors" field in the mutation.
func (m *FeedMutation) Authors() (r []*modelfeed.Person, exists bool) {
	v := m.authors
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthors returns the old "authors" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldAuthors(ctx context.Context) (v []*modelfeed.Person, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthors: %w", err)
	}
	return oldValue.Authors, nil
}

// AppendAuthors adds value to the "authors" field.
func (m *FeedMutation) AppendAuthors(value []*modelfeed.Person) {
	m.appendauthors = append(m.appendauthors, value...)
}

// AppendedAuthors returns the list of values that were appended to the "authors" field in this mutation.
func (m *FeedMutation) AppendedAuthors() ([]*modelfeed.Person, bool) {
	if len(m.appendauthors) == 0 {
		return nil, false
	}
	return m.appendauthors, true
}

// ClearAuthors clears the value of the "authors" field.
func (m *FeedMutation) ClearAuthors() {
	m.authors = nil
	m.appendauthors = nil
	m.clearedFields[feed.FieldAuthors] = struct{}{}
}

// AuthorsCleared returns if the "authors" field was cleared in this mutation.
func (m *FeedMutation) AuthorsCleared() bool {
	_, ok := m.clearedFields[feed.FieldAuthors]
	return ok
}

// ResetAuthors resets all changes to the "authors" field.
func (m *FeedMutation) ResetAuthors() {
	m.authors = nil
	m.appendauthors = nil
	delete(m.clearedFields, feed.FieldAuthors)
}

// SetImage sets the "image" field.
func (m *FeedMutation) SetImage(value *modelfeed.Image) {
	m.image = &value
}

// Image returns the value of the "image" field in the mutation.
func (m *FeedMutation) Image() (r *modelfeed.Image, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldImage(ctx context.Context) (v *modelfeed.Image, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *FeedMutation) ClearImage() {
	m.image = nil
	m.clearedFields[feed.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *FeedMutation) ImageCleared() bool {
	_, ok := m.clearedFields[feed.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *FeedMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, feed.FieldImage)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Feed entity.
// If the Feed object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddItemIDs adds the "item" edge to the FeedItem entity by ids.
func (m *FeedMutation) AddItemIDs(ids ...model.InternalID) {
	if m.item == nil {
		m.item = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.item[ids[i]] = struct{}{}
	}
}

// ClearItem clears the "item" edge to the FeedItem entity.
func (m *FeedMutation) ClearItem() {
	m.cleareditem = true
}

// ItemCleared reports if the "item" edge to the FeedItem entity was cleared.
func (m *FeedMutation) ItemCleared() bool {
	return m.cleareditem
}

// RemoveItemIDs removes the "item" edge to the FeedItem entity by IDs.
func (m *FeedMutation) RemoveItemIDs(ids ...model.InternalID) {
	if m.removeditem == nil {
		m.removeditem = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.item, ids[i])
		m.removeditem[ids[i]] = struct{}{}
	}
}

// RemovedItem returns the removed IDs of the "item" edge to the FeedItem entity.
func (m *FeedMutation) RemovedItemIDs() (ids []model.InternalID) {
	for id := range m.removeditem {
		ids = append(ids, id)
	}
	return
}

// ItemIDs returns the "item" edge IDs in the mutation.
func (m *FeedMutation) ItemIDs() (ids []model.InternalID) {
	for id := range m.item {
		ids = append(ids, id)
	}
	return
}

// ResetItem resets all changes to the "item" edge.
func (m *FeedMutation) ResetItem() {
	m.item = nil
	m.cleareditem = false
	m.removeditem = nil
}

// SetConfigID sets the "config" edge to the FeedConfig entity by id.
func (m *FeedMutation) SetConfigID(id model.InternalID) {
	m._config = &id
}

// ClearConfig clears the "config" edge to the FeedConfig entity.
func (m *FeedMutation) ClearConfig() {
	m.cleared_config = true
}

// ConfigCleared reports if the "config" edge to the FeedConfig entity was cleared.
func (m *FeedMutation) ConfigCleared() bool {
	return m.cleared_config
}

// ConfigID returns the "config" edge ID in the mutation.
func (m *FeedMutation) ConfigID() (id model.InternalID, exists bool) {
	if m._config != nil {
		return *m._config, true
	}
	return
}

// ConfigIDs returns the "config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConfigID instead. It exists only for internal usage by the builders.
func (m *FeedMutation) ConfigIDs() (ids []model.InternalID) {
	if id := m._config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConfig resets all changes to the "config" edge.
func (m *FeedMutation) ResetConfig() {
	m._config = nil
	m.cleared_config = false
}

// Where appends a list predicates to the FeedMutation builder.
func (m *FeedMutation) Where(ps ...predicate.Feed) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feed, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feed).
func (m *FeedMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.title != nil {
		fields = append(fields, feed.FieldTitle)
	}
	if m.link != nil {
		fields = append(fields, feed.FieldLink)
	}
	if m.description != nil {
		fields = append(fields, feed.FieldDescription)
	}
	if m.language != nil {
		fields = append(fields, feed.FieldLanguage)
	}
	if m.authors != nil {
		fields = append(fields, feed.FieldAuthors)
	}
	if m.image != nil {
		fields = append(fields, feed.FieldImage)
	}
	if m.updated_at != nil {
		fields = append(fields, feed.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feed.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feed.FieldTitle:
		return m.Title()
	case feed.FieldLink:
		return m.Link()
	case feed.FieldDescription:
		return m.Description()
	case feed.FieldLanguage:
		return m.Language()
	case feed.FieldAuthors:
		return m.Authors()
	case feed.FieldImage:
		return m.Image()
	case feed.FieldUpdatedAt:
		return m.UpdatedAt()
	case feed.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feed.FieldTitle:
		return m.OldTitle(ctx)
	case feed.FieldLink:
		return m.OldLink(ctx)
	case feed.FieldDescription:
		return m.OldDescription(ctx)
	case feed.FieldLanguage:
		return m.OldLanguage(ctx)
	case feed.FieldAuthors:
		return m.OldAuthors(ctx)
	case feed.FieldImage:
		return m.OldImage(ctx)
	case feed.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feed.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Feed field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feed.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case feed.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case feed.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feed.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case feed.FieldAuthors:
		v, ok := value.([]*modelfeed.Person)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthors(v)
		return nil
	case feed.FieldImage:
		v, ok := value.(*modelfeed.Image)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case feed.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feed.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Feed field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Feed numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feed.FieldTitle) {
		fields = append(fields, feed.FieldTitle)
	}
	if m.FieldCleared(feed.FieldLink) {
		fields = append(fields, feed.FieldLink)
	}
	if m.FieldCleared(feed.FieldDescription) {
		fields = append(fields, feed.FieldDescription)
	}
	if m.FieldCleared(feed.FieldLanguage) {
		fields = append(fields, feed.FieldLanguage)
	}
	if m.FieldCleared(feed.FieldAuthors) {
		fields = append(fields, feed.FieldAuthors)
	}
	if m.FieldCleared(feed.FieldImage) {
		fields = append(fields, feed.FieldImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedMutation) ClearField(name string) error {
	switch name {
	case feed.FieldTitle:
		m.ClearTitle()
		return nil
	case feed.FieldLink:
		m.ClearLink()
		return nil
	case feed.FieldDescription:
		m.ClearDescription()
		return nil
	case feed.FieldLanguage:
		m.ClearLanguage()
		return nil
	case feed.FieldAuthors:
		m.ClearAuthors()
		return nil
	case feed.FieldImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown Feed nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedMutation) ResetField(name string) error {
	switch name {
	case feed.FieldTitle:
		m.ResetTitle()
		return nil
	case feed.FieldLink:
		m.ResetLink()
		return nil
	case feed.FieldDescription:
		m.ResetDescription()
		return nil
	case feed.FieldLanguage:
		m.ResetLanguage()
		return nil
	case feed.FieldAuthors:
		m.ResetAuthors()
		return nil
	case feed.FieldImage:
		m.ResetImage()
		return nil
	case feed.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feed.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Feed field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.item != nil {
		edges = append(edges, feed.EdgeItem)
	}
	if m._config != nil {
		edges = append(edges, feed.EdgeConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feed.EdgeItem:
		ids := make([]ent.Value, 0, len(m.item))
		for id := range m.item {
			ids = append(ids, id)
		}
		return ids
	case feed.EdgeConfig:
		if id := m._config; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditem != nil {
		edges = append(edges, feed.EdgeItem)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feed.EdgeItem:
		ids := make([]ent.Value, 0, len(m.removeditem))
		for id := range m.removeditem {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareditem {
		edges = append(edges, feed.EdgeItem)
	}
	if m.cleared_config {
		edges = append(edges, feed.EdgeConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedMutation) EdgeCleared(name string) bool {
	switch name {
	case feed.EdgeItem:
		return m.cleareditem
	case feed.EdgeConfig:
		return m.cleared_config
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedMutation) ClearEdge(name string) error {
	switch name {
	case feed.EdgeConfig:
		m.ClearConfig()
		return nil
	}
	return fmt.Errorf("unknown Feed unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedMutation) ResetEdge(name string) error {
	switch name {
	case feed.EdgeItem:
		m.ResetItem()
		return nil
	case feed.EdgeConfig:
		m.ResetConfig()
		return nil
	}
	return fmt.Errorf("unknown Feed edge %s", name)
}

// FeedActionSetMutation represents an operation that mutates the FeedActionSet nodes in the graph.
type FeedActionSetMutation struct {
	config
	op                 Op
	typ                string
	id                 *model.InternalID
	name               *string
	description        *string
	actions            *[]*modelsupervisor.FeatureRequest
	appendactions      []*modelsupervisor.FeatureRequest
	updated_at         *time.Time
	created_at         *time.Time
	clearedFields      map[string]struct{}
	owner              *model.InternalID
	clearedowner       bool
	feed_config        map[model.InternalID]struct{}
	removedfeed_config map[model.InternalID]struct{}
	clearedfeed_config bool
	done               bool
	oldValue           func(context.Context) (*FeedActionSet, error)
	predicates         []predicate.FeedActionSet
}

var _ ent.Mutation = (*FeedActionSetMutation)(nil)

// feedactionsetOption allows management of the mutation configuration using functional options.
type feedactionsetOption func(*FeedActionSetMutation)

// newFeedActionSetMutation creates new mutation for the FeedActionSet entity.
func newFeedActionSetMutation(c config, op Op, opts ...feedactionsetOption) *FeedActionSetMutation {
	m := &FeedActionSetMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedActionSet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedActionSetID sets the ID field of the mutation.
func withFeedActionSetID(id model.InternalID) feedactionsetOption {
	return func(m *FeedActionSetMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedActionSet
		)
		m.oldValue = func(ctx context.Context) (*FeedActionSet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedActionSet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedActionSet sets the old FeedActionSet of the mutation.
func withFeedActionSet(node *FeedActionSet) feedactionsetOption {
	return func(m *FeedActionSetMutation) {
		m.oldValue = func(context.Context) (*FeedActionSet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedActionSetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedActionSetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeedActionSet entities.
func (m *FeedActionSetMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedActionSetMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedActionSetMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeedActionSet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FeedActionSetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeedActionSetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeedActionSet entity.
// If the FeedActionSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedActionSetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeedActionSetMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *FeedActionSetMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeedActionSetMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeedActionSet entity.
// If the FeedActionSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedActionSetMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FeedActionSetMutation) ResetDescription() {
	m.description = nil
}

// SetActions sets the "actions" field.
func (m *FeedActionSetMutation) SetActions(mr []*modelsupervisor.FeatureRequest) {
	m.actions = &mr
	m.appendactions = nil
}

// Actions returns the value of the "actions" field in the mutation.
func (m *FeedActionSetMutation) Actions() (r []*modelsupervisor.FeatureRequest, exists bool) {
	v := m.actions
	if v == nil {
		return
	}
	return *v, true
}

// OldActions returns the old "actions" field's value of the FeedActionSet entity.
// If the FeedActionSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedActionSetMutation) OldActions(ctx context.Context) (v []*modelsupervisor.FeatureRequest, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActions: %w", err)
	}
	return oldValue.Actions, nil
}

// AppendActions adds mr to the "actions" field.
func (m *FeedActionSetMutation) AppendActions(mr []*modelsupervisor.FeatureRequest) {
	m.appendactions = append(m.appendactions, mr...)
}

// AppendedActions returns the list of values that were appended to the "actions" field in this mutation.
func (m *FeedActionSetMutation) AppendedActions() ([]*modelsupervisor.FeatureRequest, bool) {
	if len(m.appendactions) == 0 {
		return nil, false
	}
	return m.appendactions, true
}

// ResetActions resets all changes to the "actions" field.
func (m *FeedActionSetMutation) ResetActions() {
	m.actions = nil
	m.appendactions = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedActionSetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedActionSetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeedActionSet entity.
// If the FeedActionSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedActionSetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedActionSetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedActionSetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedActionSetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeedActionSet entity.
// If the FeedActionSet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedActionSetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedActionSetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *FeedActionSetMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FeedActionSetMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FeedActionSetMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *FeedActionSetMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FeedActionSetMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FeedActionSetMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddFeedConfigIDs adds the "feed_config" edge to the FeedConfig entity by ids.
func (m *FeedActionSetMutation) AddFeedConfigIDs(ids ...model.InternalID) {
	if m.feed_config == nil {
		m.feed_config = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_config[ids[i]] = struct{}{}
	}
}

// ClearFeedConfig clears the "feed_config" edge to the FeedConfig entity.
func (m *FeedActionSetMutation) ClearFeedConfig() {
	m.clearedfeed_config = true
}

// FeedConfigCleared reports if the "feed_config" edge to the FeedConfig entity was cleared.
func (m *FeedActionSetMutation) FeedConfigCleared() bool {
	return m.clearedfeed_config
}

// RemoveFeedConfigIDs removes the "feed_config" edge to the FeedConfig entity by IDs.
func (m *FeedActionSetMutation) RemoveFeedConfigIDs(ids ...model.InternalID) {
	if m.removedfeed_config == nil {
		m.removedfeed_config = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_config, ids[i])
		m.removedfeed_config[ids[i]] = struct{}{}
	}
}

// RemovedFeedConfig returns the removed IDs of the "feed_config" edge to the FeedConfig entity.
func (m *FeedActionSetMutation) RemovedFeedConfigIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_config {
		ids = append(ids, id)
	}
	return
}

// FeedConfigIDs returns the "feed_config" edge IDs in the mutation.
func (m *FeedActionSetMutation) FeedConfigIDs() (ids []model.InternalID) {
	for id := range m.feed_config {
		ids = append(ids, id)
	}
	return
}

// ResetFeedConfig resets all changes to the "feed_config" edge.
func (m *FeedActionSetMutation) ResetFeedConfig() {
	m.feed_config = nil
	m.clearedfeed_config = false
	m.removedfeed_config = nil
}

// Where appends a list predicates to the FeedActionSetMutation builder.
func (m *FeedActionSetMutation) Where(ps ...predicate.FeedActionSet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedActionSetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedActionSetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeedActionSet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedActionSetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedActionSetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeedActionSet).
func (m *FeedActionSetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedActionSetMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, feedactionset.FieldName)
	}
	if m.description != nil {
		fields = append(fields, feedactionset.FieldDescription)
	}
	if m.actions != nil {
		fields = append(fields, feedactionset.FieldActions)
	}
	if m.updated_at != nil {
		fields = append(fields, feedactionset.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feedactionset.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedActionSetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedactionset.FieldName:
		return m.Name()
	case feedactionset.FieldDescription:
		return m.Description()
	case feedactionset.FieldActions:
		return m.Actions()
	case feedactionset.FieldUpdatedAt:
		return m.UpdatedAt()
	case feedactionset.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedActionSetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedactionset.FieldName:
		return m.OldName(ctx)
	case feedactionset.FieldDescription:
		return m.OldDescription(ctx)
	case feedactionset.FieldActions:
		return m.OldActions(ctx)
	case feedactionset.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feedactionset.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeedActionSet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedActionSetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedactionset.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feedactionset.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feedactionset.FieldActions:
		v, ok := value.([]*modelsupervisor.FeatureRequest)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActions(v)
		return nil
	case feedactionset.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feedactionset.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeedActionSet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedActionSetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedActionSetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedActionSetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeedActionSet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedActionSetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedActionSetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedActionSetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeedActionSet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedActionSetMutation) ResetField(name string) error {
	switch name {
	case feedactionset.FieldName:
		m.ResetName()
		return nil
	case feedactionset.FieldDescription:
		m.ResetDescription()
		return nil
	case feedactionset.FieldActions:
		m.ResetActions()
		return nil
	case feedactionset.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feedactionset.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeedActionSet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedActionSetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, feedactionset.EdgeOwner)
	}
	if m.feed_config != nil {
		edges = append(edges, feedactionset.EdgeFeedConfig)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedActionSetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feedactionset.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case feedactionset.EdgeFeedConfig:
		ids := make([]ent.Value, 0, len(m.feed_config))
		for id := range m.feed_config {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedActionSetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfeed_config != nil {
		edges = append(edges, feedactionset.EdgeFeedConfig)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedActionSetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feedactionset.EdgeFeedConfig:
		ids := make([]ent.Value, 0, len(m.removedfeed_config))
		for id := range m.removedfeed_config {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedActionSetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, feedactionset.EdgeOwner)
	}
	if m.clearedfeed_config {
		edges = append(edges, feedactionset.EdgeFeedConfig)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedActionSetMutation) EdgeCleared(name string) bool {
	switch name {
	case feedactionset.EdgeOwner:
		return m.clearedowner
	case feedactionset.EdgeFeedConfig:
		return m.clearedfeed_config
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedActionSetMutation) ClearEdge(name string) error {
	switch name {
	case feedactionset.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown FeedActionSet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedActionSetMutation) ResetEdge(name string) error {
	switch name {
	case feedactionset.EdgeOwner:
		m.ResetOwner()
		return nil
	case feedactionset.EdgeFeedConfig:
		m.ResetFeedConfig()
		return nil
	}
	return fmt.Errorf("unknown FeedActionSet edge %s", name)
}

// FeedConfigMutation represents an operation that mutates the FeedConfig nodes in the graph.
type FeedConfigMutation struct {
	config
	op                        Op
	typ                       string
	id                        *model.InternalID
	name                      *string
	description               *string
	source                    **modelsupervisor.FeatureRequest
	status                    *feedconfig.Status
	category                  *string
	pull_interval             *time.Duration
	addpull_interval          *time.Duration
	hide_items                *bool
	latest_pull_at            *time.Time
	latest_pull_status        *feedconfig.LatestPullStatus
	latest_pull_message       *string
	next_pull_begin_at        *time.Time
	updated_at                *time.Time
	created_at                *time.Time
	clearedFields             map[string]struct{}
	owner                     *model.InternalID
	clearedowner              bool
	feed                      *model.InternalID
	clearedfeed               bool
	notify_source             map[model.InternalID]struct{}
	removednotify_source      map[model.InternalID]struct{}
	clearednotify_source      bool
	feed_action_set           map[model.InternalID]struct{}
	removedfeed_action_set    map[model.InternalID]struct{}
	clearedfeed_action_set    bool
	feed_config_action        map[int]struct{}
	removedfeed_config_action map[int]struct{}
	clearedfeed_config_action bool
	done                      bool
	oldValue                  func(context.Context) (*FeedConfig, error)
	predicates                []predicate.FeedConfig
}

var _ ent.Mutation = (*FeedConfigMutation)(nil)

// feedconfigOption allows management of the mutation configuration using functional options.
type feedconfigOption func(*FeedConfigMutation)

// newFeedConfigMutation creates new mutation for the FeedConfig entity.
func newFeedConfigMutation(c config, op Op, opts ...feedconfigOption) *FeedConfigMutation {
	m := &FeedConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedConfigID sets the ID field of the mutation.
func withFeedConfigID(id model.InternalID) feedconfigOption {
	return func(m *FeedConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedConfig
		)
		m.oldValue = func(ctx context.Context) (*FeedConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedConfig sets the old FeedConfig of the mutation.
func withFeedConfig(node *FeedConfig) feedconfigOption {
	return func(m *FeedConfigMutation) {
		m.oldValue = func(context.Context) (*FeedConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeedConfig entities.
func (m *FeedConfigMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedConfigMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedConfigMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeedConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserFeedConfig sets the "user_feed_config" field.
func (m *FeedConfigMutation) SetUserFeedConfig(mi model.InternalID) {
	m.owner = &mi
}

// UserFeedConfig returns the value of the "user_feed_config" field in the mutation.
func (m *FeedConfigMutation) UserFeedConfig() (r model.InternalID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserFeedConfig returns the old "user_feed_config" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldUserFeedConfig(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserFeedConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserFeedConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserFeedConfig: %w", err)
	}
	return oldValue.UserFeedConfig, nil
}

// ResetUserFeedConfig resets all changes to the "user_feed_config" field.
func (m *FeedConfigMutation) ResetUserFeedConfig() {
	m.owner = nil
}

// SetName sets the "name" field.
func (m *FeedConfigMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeedConfigMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeedConfigMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *FeedConfigMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeedConfigMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FeedConfigMutation) ResetDescription() {
	m.description = nil
}

// SetSource sets the "source" field.
func (m *FeedConfigMutation) SetSource(mr *modelsupervisor.FeatureRequest) {
	m.source = &mr
}

// Source returns the value of the "source" field in the mutation.
func (m *FeedConfigMutation) Source() (r *modelsupervisor.FeatureRequest, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldSource(ctx context.Context) (v *modelsupervisor.FeatureRequest, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *FeedConfigMutation) ResetSource() {
	m.source = nil
}

// SetStatus sets the "status" field.
func (m *FeedConfigMutation) SetStatus(f feedconfig.Status) {
	m.status = &f
}

// Status returns the value of the "status" field in the mutation.
func (m *FeedConfigMutation) Status() (r feedconfig.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldStatus(ctx context.Context) (v feedconfig.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FeedConfigMutation) ResetStatus() {
	m.status = nil
}

// SetCategory sets the "category" field.
func (m *FeedConfigMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *FeedConfigMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *FeedConfigMutation) ResetCategory() {
	m.category = nil
}

// SetPullInterval sets the "pull_interval" field.
func (m *FeedConfigMutation) SetPullInterval(t time.Duration) {
	m.pull_interval = &t
	m.addpull_interval = nil
}

// PullInterval returns the value of the "pull_interval" field in the mutation.
func (m *FeedConfigMutation) PullInterval() (r time.Duration, exists bool) {
	v := m.pull_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldPullInterval returns the old "pull_interval" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldPullInterval(ctx context.Context) (v time.Duration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPullInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPullInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPullInterval: %w", err)
	}
	return oldValue.PullInterval, nil
}

// AddPullInterval adds t to the "pull_interval" field.
func (m *FeedConfigMutation) AddPullInterval(t time.Duration) {
	if m.addpull_interval != nil {
		*m.addpull_interval += t
	} else {
		m.addpull_interval = &t
	}
}

// AddedPullInterval returns the value that was added to the "pull_interval" field in this mutation.
func (m *FeedConfigMutation) AddedPullInterval() (r time.Duration, exists bool) {
	v := m.addpull_interval
	if v == nil {
		return
	}
	return *v, true
}

// ResetPullInterval resets all changes to the "pull_interval" field.
func (m *FeedConfigMutation) ResetPullInterval() {
	m.pull_interval = nil
	m.addpull_interval = nil
}

// SetHideItems sets the "hide_items" field.
func (m *FeedConfigMutation) SetHideItems(b bool) {
	m.hide_items = &b
}

// HideItems returns the value of the "hide_items" field in the mutation.
func (m *FeedConfigMutation) HideItems() (r bool, exists bool) {
	v := m.hide_items
	if v == nil {
		return
	}
	return *v, true
}

// OldHideItems returns the old "hide_items" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldHideItems(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideItems: %w", err)
	}
	return oldValue.HideItems, nil
}

// ResetHideItems resets all changes to the "hide_items" field.
func (m *FeedConfigMutation) ResetHideItems() {
	m.hide_items = nil
}

// SetLatestPullAt sets the "latest_pull_at" field.
func (m *FeedConfigMutation) SetLatestPullAt(t time.Time) {
	m.latest_pull_at = &t
}

// LatestPullAt returns the value of the "latest_pull_at" field in the mutation.
func (m *FeedConfigMutation) LatestPullAt() (r time.Time, exists bool) {
	v := m.latest_pull_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestPullAt returns the old "latest_pull_at" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldLatestPullAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestPullAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestPullAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestPullAt: %w", err)
	}
	return oldValue.LatestPullAt, nil
}

// ResetLatestPullAt resets all changes to the "latest_pull_at" field.
func (m *FeedConfigMutation) ResetLatestPullAt() {
	m.latest_pull_at = nil
}

// SetLatestPullStatus sets the "latest_pull_status" field.
func (m *FeedConfigMutation) SetLatestPullStatus(fps feedconfig.LatestPullStatus) {
	m.latest_pull_status = &fps
}

// LatestPullStatus returns the value of the "latest_pull_status" field in the mutation.
func (m *FeedConfigMutation) LatestPullStatus() (r feedconfig.LatestPullStatus, exists bool) {
	v := m.latest_pull_status
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestPullStatus returns the old "latest_pull_status" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldLatestPullStatus(ctx context.Context) (v feedconfig.LatestPullStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestPullStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestPullStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestPullStatus: %w", err)
	}
	return oldValue.LatestPullStatus, nil
}

// ResetLatestPullStatus resets all changes to the "latest_pull_status" field.
func (m *FeedConfigMutation) ResetLatestPullStatus() {
	m.latest_pull_status = nil
}

// SetLatestPullMessage sets the "latest_pull_message" field.
func (m *FeedConfigMutation) SetLatestPullMessage(s string) {
	m.latest_pull_message = &s
}

// LatestPullMessage returns the value of the "latest_pull_message" field in the mutation.
func (m *FeedConfigMutation) LatestPullMessage() (r string, exists bool) {
	v := m.latest_pull_message
	if v == nil {
		return
	}
	return *v, true
}

// OldLatestPullMessage returns the old "latest_pull_message" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldLatestPullMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatestPullMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatestPullMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatestPullMessage: %w", err)
	}
	return oldValue.LatestPullMessage, nil
}

// ResetLatestPullMessage resets all changes to the "latest_pull_message" field.
func (m *FeedConfigMutation) ResetLatestPullMessage() {
	m.latest_pull_message = nil
}

// SetNextPullBeginAt sets the "next_pull_begin_at" field.
func (m *FeedConfigMutation) SetNextPullBeginAt(t time.Time) {
	m.next_pull_begin_at = &t
}

// NextPullBeginAt returns the value of the "next_pull_begin_at" field in the mutation.
func (m *FeedConfigMutation) NextPullBeginAt() (r time.Time, exists bool) {
	v := m.next_pull_begin_at
	if v == nil {
		return
	}
	return *v, true
}

// OldNextPullBeginAt returns the old "next_pull_begin_at" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldNextPullBeginAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNextPullBeginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNextPullBeginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextPullBeginAt: %w", err)
	}
	return oldValue.NextPullBeginAt, nil
}

// ResetNextPullBeginAt resets all changes to the "next_pull_begin_at" field.
func (m *FeedConfigMutation) ResetNextPullBeginAt() {
	m.next_pull_begin_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeedConfig entity.
// If the FeedConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *FeedConfigMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FeedConfigMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[feedconfig.FieldUserFeedConfig] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FeedConfigMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *FeedConfigMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FeedConfigMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FeedConfigMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetFeedID sets the "feed" edge to the Feed entity by id.
func (m *FeedConfigMutation) SetFeedID(id model.InternalID) {
	m.feed = &id
}

// ClearFeed clears the "feed" edge to the Feed entity.
func (m *FeedConfigMutation) ClearFeed() {
	m.clearedfeed = true
}

// FeedCleared reports if the "feed" edge to the Feed entity was cleared.
func (m *FeedConfigMutation) FeedCleared() bool {
	return m.clearedfeed
}

// FeedID returns the "feed" edge ID in the mutation.
func (m *FeedConfigMutation) FeedID() (id model.InternalID, exists bool) {
	if m.feed != nil {
		return *m.feed, true
	}
	return
}

// FeedIDs returns the "feed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedID instead. It exists only for internal usage by the builders.
func (m *FeedConfigMutation) FeedIDs() (ids []model.InternalID) {
	if id := m.feed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeed resets all changes to the "feed" edge.
func (m *FeedConfigMutation) ResetFeed() {
	m.feed = nil
	m.clearedfeed = false
}

// AddNotifySourceIDs adds the "notify_source" edge to the NotifySource entity by ids.
func (m *FeedConfigMutation) AddNotifySourceIDs(ids ...model.InternalID) {
	if m.notify_source == nil {
		m.notify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_source[ids[i]] = struct{}{}
	}
}

// ClearNotifySource clears the "notify_source" edge to the NotifySource entity.
func (m *FeedConfigMutation) ClearNotifySource() {
	m.clearednotify_source = true
}

// NotifySourceCleared reports if the "notify_source" edge to the NotifySource entity was cleared.
func (m *FeedConfigMutation) NotifySourceCleared() bool {
	return m.clearednotify_source
}

// RemoveNotifySourceIDs removes the "notify_source" edge to the NotifySource entity by IDs.
func (m *FeedConfigMutation) RemoveNotifySourceIDs(ids ...model.InternalID) {
	if m.removednotify_source == nil {
		m.removednotify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_source, ids[i])
		m.removednotify_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifySource returns the removed IDs of the "notify_source" edge to the NotifySource entity.
func (m *FeedConfigMutation) RemovedNotifySourceIDs() (ids []model.InternalID) {
	for id := range m.removednotify_source {
		ids = append(ids, id)
	}
	return
}

// NotifySourceIDs returns the "notify_source" edge IDs in the mutation.
func (m *FeedConfigMutation) NotifySourceIDs() (ids []model.InternalID) {
	for id := range m.notify_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifySource resets all changes to the "notify_source" edge.
func (m *FeedConfigMutation) ResetNotifySource() {
	m.notify_source = nil
	m.clearednotify_source = false
	m.removednotify_source = nil
}

// AddFeedActionSetIDs adds the "feed_action_set" edge to the FeedActionSet entity by ids.
func (m *FeedConfigMutation) AddFeedActionSetIDs(ids ...model.InternalID) {
	if m.feed_action_set == nil {
		m.feed_action_set = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_action_set[ids[i]] = struct{}{}
	}
}

// ClearFeedActionSet clears the "feed_action_set" edge to the FeedActionSet entity.
func (m *FeedConfigMutation) ClearFeedActionSet() {
	m.clearedfeed_action_set = true
}

// FeedActionSetCleared reports if the "feed_action_set" edge to the FeedActionSet entity was cleared.
func (m *FeedConfigMutation) FeedActionSetCleared() bool {
	return m.clearedfeed_action_set
}

// RemoveFeedActionSetIDs removes the "feed_action_set" edge to the FeedActionSet entity by IDs.
func (m *FeedConfigMutation) RemoveFeedActionSetIDs(ids ...model.InternalID) {
	if m.removedfeed_action_set == nil {
		m.removedfeed_action_set = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_action_set, ids[i])
		m.removedfeed_action_set[ids[i]] = struct{}{}
	}
}

// RemovedFeedActionSet returns the removed IDs of the "feed_action_set" edge to the FeedActionSet entity.
func (m *FeedConfigMutation) RemovedFeedActionSetIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_action_set {
		ids = append(ids, id)
	}
	return
}

// FeedActionSetIDs returns the "feed_action_set" edge IDs in the mutation.
func (m *FeedConfigMutation) FeedActionSetIDs() (ids []model.InternalID) {
	for id := range m.feed_action_set {
		ids = append(ids, id)
	}
	return
}

// ResetFeedActionSet resets all changes to the "feed_action_set" edge.
func (m *FeedConfigMutation) ResetFeedActionSet() {
	m.feed_action_set = nil
	m.clearedfeed_action_set = false
	m.removedfeed_action_set = nil
}

// AddFeedConfigActionIDs adds the "feed_config_action" edge to the FeedConfigAction entity by ids.
func (m *FeedConfigMutation) AddFeedConfigActionIDs(ids ...int) {
	if m.feed_config_action == nil {
		m.feed_config_action = make(map[int]struct{})
	}
	for i := range ids {
		m.feed_config_action[ids[i]] = struct{}{}
	}
}

// ClearFeedConfigAction clears the "feed_config_action" edge to the FeedConfigAction entity.
func (m *FeedConfigMutation) ClearFeedConfigAction() {
	m.clearedfeed_config_action = true
}

// FeedConfigActionCleared reports if the "feed_config_action" edge to the FeedConfigAction entity was cleared.
func (m *FeedConfigMutation) FeedConfigActionCleared() bool {
	return m.clearedfeed_config_action
}

// RemoveFeedConfigActionIDs removes the "feed_config_action" edge to the FeedConfigAction entity by IDs.
func (m *FeedConfigMutation) RemoveFeedConfigActionIDs(ids ...int) {
	if m.removedfeed_config_action == nil {
		m.removedfeed_config_action = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.feed_config_action, ids[i])
		m.removedfeed_config_action[ids[i]] = struct{}{}
	}
}

// RemovedFeedConfigAction returns the removed IDs of the "feed_config_action" edge to the FeedConfigAction entity.
func (m *FeedConfigMutation) RemovedFeedConfigActionIDs() (ids []int) {
	for id := range m.removedfeed_config_action {
		ids = append(ids, id)
	}
	return
}

// FeedConfigActionIDs returns the "feed_config_action" edge IDs in the mutation.
func (m *FeedConfigMutation) FeedConfigActionIDs() (ids []int) {
	for id := range m.feed_config_action {
		ids = append(ids, id)
	}
	return
}

// ResetFeedConfigAction resets all changes to the "feed_config_action" edge.
func (m *FeedConfigMutation) ResetFeedConfigAction() {
	m.feed_config_action = nil
	m.clearedfeed_config_action = false
	m.removedfeed_config_action = nil
}

// Where appends a list predicates to the FeedConfigMutation builder.
func (m *FeedConfigMutation) Where(ps ...predicate.FeedConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeedConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeedConfig).
func (m *FeedConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedConfigMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.owner != nil {
		fields = append(fields, feedconfig.FieldUserFeedConfig)
	}
	if m.name != nil {
		fields = append(fields, feedconfig.FieldName)
	}
	if m.description != nil {
		fields = append(fields, feedconfig.FieldDescription)
	}
	if m.source != nil {
		fields = append(fields, feedconfig.FieldSource)
	}
	if m.status != nil {
		fields = append(fields, feedconfig.FieldStatus)
	}
	if m.category != nil {
		fields = append(fields, feedconfig.FieldCategory)
	}
	if m.pull_interval != nil {
		fields = append(fields, feedconfig.FieldPullInterval)
	}
	if m.hide_items != nil {
		fields = append(fields, feedconfig.FieldHideItems)
	}
	if m.latest_pull_at != nil {
		fields = append(fields, feedconfig.FieldLatestPullAt)
	}
	if m.latest_pull_status != nil {
		fields = append(fields, feedconfig.FieldLatestPullStatus)
	}
	if m.latest_pull_message != nil {
		fields = append(fields, feedconfig.FieldLatestPullMessage)
	}
	if m.next_pull_begin_at != nil {
		fields = append(fields, feedconfig.FieldNextPullBeginAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feedconfig.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feedconfig.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedconfig.FieldUserFeedConfig:
		return m.UserFeedConfig()
	case feedconfig.FieldName:
		return m.Name()
	case feedconfig.FieldDescription:
		return m.Description()
	case feedconfig.FieldSource:
		return m.Source()
	case feedconfig.FieldStatus:
		return m.Status()
	case feedconfig.FieldCategory:
		return m.Category()
	case feedconfig.FieldPullInterval:
		return m.PullInterval()
	case feedconfig.FieldHideItems:
		return m.HideItems()
	case feedconfig.FieldLatestPullAt:
		return m.LatestPullAt()
	case feedconfig.FieldLatestPullStatus:
		return m.LatestPullStatus()
	case feedconfig.FieldLatestPullMessage:
		return m.LatestPullMessage()
	case feedconfig.FieldNextPullBeginAt:
		return m.NextPullBeginAt()
	case feedconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case feedconfig.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedconfig.FieldUserFeedConfig:
		return m.OldUserFeedConfig(ctx)
	case feedconfig.FieldName:
		return m.OldName(ctx)
	case feedconfig.FieldDescription:
		return m.OldDescription(ctx)
	case feedconfig.FieldSource:
		return m.OldSource(ctx)
	case feedconfig.FieldStatus:
		return m.OldStatus(ctx)
	case feedconfig.FieldCategory:
		return m.OldCategory(ctx)
	case feedconfig.FieldPullInterval:
		return m.OldPullInterval(ctx)
	case feedconfig.FieldHideItems:
		return m.OldHideItems(ctx)
	case feedconfig.FieldLatestPullAt:
		return m.OldLatestPullAt(ctx)
	case feedconfig.FieldLatestPullStatus:
		return m.OldLatestPullStatus(ctx)
	case feedconfig.FieldLatestPullMessage:
		return m.OldLatestPullMessage(ctx)
	case feedconfig.FieldNextPullBeginAt:
		return m.OldNextPullBeginAt(ctx)
	case feedconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feedconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeedConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedconfig.FieldUserFeedConfig:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserFeedConfig(v)
		return nil
	case feedconfig.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feedconfig.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feedconfig.FieldSource:
		v, ok := value.(*modelsupervisor.FeatureRequest)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case feedconfig.FieldStatus:
		v, ok := value.(feedconfig.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case feedconfig.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case feedconfig.FieldPullInterval:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPullInterval(v)
		return nil
	case feedconfig.FieldHideItems:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideItems(v)
		return nil
	case feedconfig.FieldLatestPullAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestPullAt(v)
		return nil
	case feedconfig.FieldLatestPullStatus:
		v, ok := value.(feedconfig.LatestPullStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestPullStatus(v)
		return nil
	case feedconfig.FieldLatestPullMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatestPullMessage(v)
		return nil
	case feedconfig.FieldNextPullBeginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextPullBeginAt(v)
		return nil
	case feedconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feedconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeedConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedConfigMutation) AddedFields() []string {
	var fields []string
	if m.addpull_interval != nil {
		fields = append(fields, feedconfig.FieldPullInterval)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feedconfig.FieldPullInterval:
		return m.AddedPullInterval()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feedconfig.FieldPullInterval:
		v, ok := value.(time.Duration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPullInterval(v)
		return nil
	}
	return fmt.Errorf("unknown FeedConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedConfigMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedConfigMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeedConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedConfigMutation) ResetField(name string) error {
	switch name {
	case feedconfig.FieldUserFeedConfig:
		m.ResetUserFeedConfig()
		return nil
	case feedconfig.FieldName:
		m.ResetName()
		return nil
	case feedconfig.FieldDescription:
		m.ResetDescription()
		return nil
	case feedconfig.FieldSource:
		m.ResetSource()
		return nil
	case feedconfig.FieldStatus:
		m.ResetStatus()
		return nil
	case feedconfig.FieldCategory:
		m.ResetCategory()
		return nil
	case feedconfig.FieldPullInterval:
		m.ResetPullInterval()
		return nil
	case feedconfig.FieldHideItems:
		m.ResetHideItems()
		return nil
	case feedconfig.FieldLatestPullAt:
		m.ResetLatestPullAt()
		return nil
	case feedconfig.FieldLatestPullStatus:
		m.ResetLatestPullStatus()
		return nil
	case feedconfig.FieldLatestPullMessage:
		m.ResetLatestPullMessage()
		return nil
	case feedconfig.FieldNextPullBeginAt:
		m.ResetNextPullBeginAt()
		return nil
	case feedconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feedconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeedConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, feedconfig.EdgeOwner)
	}
	if m.feed != nil {
		edges = append(edges, feedconfig.EdgeFeed)
	}
	if m.notify_source != nil {
		edges = append(edges, feedconfig.EdgeNotifySource)
	}
	if m.feed_action_set != nil {
		edges = append(edges, feedconfig.EdgeFeedActionSet)
	}
	if m.feed_config_action != nil {
		edges = append(edges, feedconfig.EdgeFeedConfigAction)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feedconfig.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case feedconfig.EdgeFeed:
		if id := m.feed; id != nil {
			return []ent.Value{*id}
		}
	case feedconfig.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.notify_source))
		for id := range m.notify_source {
			ids = append(ids, id)
		}
		return ids
	case feedconfig.EdgeFeedActionSet:
		ids := make([]ent.Value, 0, len(m.feed_action_set))
		for id := range m.feed_action_set {
			ids = append(ids, id)
		}
		return ids
	case feedconfig.EdgeFeedConfigAction:
		ids := make([]ent.Value, 0, len(m.feed_config_action))
		for id := range m.feed_config_action {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removednotify_source != nil {
		edges = append(edges, feedconfig.EdgeNotifySource)
	}
	if m.removedfeed_action_set != nil {
		edges = append(edges, feedconfig.EdgeFeedActionSet)
	}
	if m.removedfeed_config_action != nil {
		edges = append(edges, feedconfig.EdgeFeedConfigAction)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedConfigMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feedconfig.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.removednotify_source))
		for id := range m.removednotify_source {
			ids = append(ids, id)
		}
		return ids
	case feedconfig.EdgeFeedActionSet:
		ids := make([]ent.Value, 0, len(m.removedfeed_action_set))
		for id := range m.removedfeed_action_set {
			ids = append(ids, id)
		}
		return ids
	case feedconfig.EdgeFeedConfigAction:
		ids := make([]ent.Value, 0, len(m.removedfeed_config_action))
		for id := range m.removedfeed_config_action {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, feedconfig.EdgeOwner)
	}
	if m.clearedfeed {
		edges = append(edges, feedconfig.EdgeFeed)
	}
	if m.clearednotify_source {
		edges = append(edges, feedconfig.EdgeNotifySource)
	}
	if m.clearedfeed_action_set {
		edges = append(edges, feedconfig.EdgeFeedActionSet)
	}
	if m.clearedfeed_config_action {
		edges = append(edges, feedconfig.EdgeFeedConfigAction)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case feedconfig.EdgeOwner:
		return m.clearedowner
	case feedconfig.EdgeFeed:
		return m.clearedfeed
	case feedconfig.EdgeNotifySource:
		return m.clearednotify_source
	case feedconfig.EdgeFeedActionSet:
		return m.clearedfeed_action_set
	case feedconfig.EdgeFeedConfigAction:
		return m.clearedfeed_config_action
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedConfigMutation) ClearEdge(name string) error {
	switch name {
	case feedconfig.EdgeOwner:
		m.ClearOwner()
		return nil
	case feedconfig.EdgeFeed:
		m.ClearFeed()
		return nil
	}
	return fmt.Errorf("unknown FeedConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedConfigMutation) ResetEdge(name string) error {
	switch name {
	case feedconfig.EdgeOwner:
		m.ResetOwner()
		return nil
	case feedconfig.EdgeFeed:
		m.ResetFeed()
		return nil
	case feedconfig.EdgeNotifySource:
		m.ResetNotifySource()
		return nil
	case feedconfig.EdgeFeedActionSet:
		m.ResetFeedActionSet()
		return nil
	case feedconfig.EdgeFeedConfigAction:
		m.ResetFeedConfigAction()
		return nil
	}
	return fmt.Errorf("unknown FeedConfig edge %s", name)
}

// FeedConfigActionMutation represents an operation that mutates the FeedConfigAction nodes in the graph.
type FeedConfigActionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	index                  *int64
	addindex               *int64
	updated_at             *time.Time
	created_at             *time.Time
	clearedFields          map[string]struct{}
	feed_config            *model.InternalID
	clearedfeed_config     bool
	feed_action_set        *model.InternalID
	clearedfeed_action_set bool
	done                   bool
	oldValue               func(context.Context) (*FeedConfigAction, error)
	predicates             []predicate.FeedConfigAction
}

var _ ent.Mutation = (*FeedConfigActionMutation)(nil)

// feedconfigactionOption allows management of the mutation configuration using functional options.
type feedconfigactionOption func(*FeedConfigActionMutation)

// newFeedConfigActionMutation creates new mutation for the FeedConfigAction entity.
func newFeedConfigActionMutation(c config, op Op, opts ...feedconfigactionOption) *FeedConfigActionMutation {
	m := &FeedConfigActionMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedConfigAction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedConfigActionID sets the ID field of the mutation.
func withFeedConfigActionID(id int) feedconfigactionOption {
	return func(m *FeedConfigActionMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedConfigAction
		)
		m.oldValue = func(ctx context.Context) (*FeedConfigAction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedConfigAction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedConfigAction sets the old FeedConfigAction of the mutation.
func withFeedConfigAction(node *FeedConfigAction) feedconfigactionOption {
	return func(m *FeedConfigActionMutation) {
		m.oldValue = func(context.Context) (*FeedConfigAction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedConfigActionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedConfigActionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedConfigActionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedConfigActionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeedConfigAction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeedConfigID sets the "feed_config_id" field.
func (m *FeedConfigActionMutation) SetFeedConfigID(mi model.InternalID) {
	m.feed_config = &mi
}

// FeedConfigID returns the value of the "feed_config_id" field in the mutation.
func (m *FeedConfigActionMutation) FeedConfigID() (r model.InternalID, exists bool) {
	v := m.feed_config
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedConfigID returns the old "feed_config_id" field's value of the FeedConfigAction entity.
// If the FeedConfigAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigActionMutation) OldFeedConfigID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedConfigID: %w", err)
	}
	return oldValue.FeedConfigID, nil
}

// ResetFeedConfigID resets all changes to the "feed_config_id" field.
func (m *FeedConfigActionMutation) ResetFeedConfigID() {
	m.feed_config = nil
}

// SetFeedActionSetID sets the "feed_action_set_id" field.
func (m *FeedConfigActionMutation) SetFeedActionSetID(mi model.InternalID) {
	m.feed_action_set = &mi
}

// FeedActionSetID returns the value of the "feed_action_set_id" field in the mutation.
func (m *FeedConfigActionMutation) FeedActionSetID() (r model.InternalID, exists bool) {
	v := m.feed_action_set
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedActionSetID returns the old "feed_action_set_id" field's value of the FeedConfigAction entity.
// If the FeedConfigAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigActionMutation) OldFeedActionSetID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedActionSetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedActionSetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedActionSetID: %w", err)
	}
	return oldValue.FeedActionSetID, nil
}

// ResetFeedActionSetID resets all changes to the "feed_action_set_id" field.
func (m *FeedConfigActionMutation) ResetFeedActionSetID() {
	m.feed_action_set = nil
}

// SetIndex sets the "index" field.
func (m *FeedConfigActionMutation) SetIndex(i int64) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *FeedConfigActionMutation) Index() (r int64, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the FeedConfigAction entity.
// If the FeedConfigAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigActionMutation) OldIndex(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *FeedConfigActionMutation) AddIndex(i int64) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *FeedConfigActionMutation) AddedIndex() (r int64, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *FeedConfigActionMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedConfigActionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedConfigActionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeedConfigAction entity.
// If the FeedConfigAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigActionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedConfigActionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedConfigActionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedConfigActionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeedConfigAction entity.
// If the FeedConfigAction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedConfigActionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedConfigActionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearFeedConfig clears the "feed_config" edge to the FeedConfig entity.
func (m *FeedConfigActionMutation) ClearFeedConfig() {
	m.clearedfeed_config = true
	m.clearedFields[feedconfigaction.FieldFeedConfigID] = struct{}{}
}

// FeedConfigCleared reports if the "feed_config" edge to the FeedConfig entity was cleared.
func (m *FeedConfigActionMutation) FeedConfigCleared() bool {
	return m.clearedfeed_config
}

// FeedConfigIDs returns the "feed_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedConfigID instead. It exists only for internal usage by the builders.
func (m *FeedConfigActionMutation) FeedConfigIDs() (ids []model.InternalID) {
	if id := m.feed_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeedConfig resets all changes to the "feed_config" edge.
func (m *FeedConfigActionMutation) ResetFeedConfig() {
	m.feed_config = nil
	m.clearedfeed_config = false
}

// ClearFeedActionSet clears the "feed_action_set" edge to the FeedActionSet entity.
func (m *FeedConfigActionMutation) ClearFeedActionSet() {
	m.clearedfeed_action_set = true
	m.clearedFields[feedconfigaction.FieldFeedActionSetID] = struct{}{}
}

// FeedActionSetCleared reports if the "feed_action_set" edge to the FeedActionSet entity was cleared.
func (m *FeedConfigActionMutation) FeedActionSetCleared() bool {
	return m.clearedfeed_action_set
}

// FeedActionSetIDs returns the "feed_action_set" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedActionSetID instead. It exists only for internal usage by the builders.
func (m *FeedConfigActionMutation) FeedActionSetIDs() (ids []model.InternalID) {
	if id := m.feed_action_set; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeedActionSet resets all changes to the "feed_action_set" edge.
func (m *FeedConfigActionMutation) ResetFeedActionSet() {
	m.feed_action_set = nil
	m.clearedfeed_action_set = false
}

// Where appends a list predicates to the FeedConfigActionMutation builder.
func (m *FeedConfigActionMutation) Where(ps ...predicate.FeedConfigAction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedConfigActionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedConfigActionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeedConfigAction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedConfigActionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedConfigActionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeedConfigAction).
func (m *FeedConfigActionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedConfigActionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.feed_config != nil {
		fields = append(fields, feedconfigaction.FieldFeedConfigID)
	}
	if m.feed_action_set != nil {
		fields = append(fields, feedconfigaction.FieldFeedActionSetID)
	}
	if m.index != nil {
		fields = append(fields, feedconfigaction.FieldIndex)
	}
	if m.updated_at != nil {
		fields = append(fields, feedconfigaction.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feedconfigaction.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedConfigActionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedconfigaction.FieldFeedConfigID:
		return m.FeedConfigID()
	case feedconfigaction.FieldFeedActionSetID:
		return m.FeedActionSetID()
	case feedconfigaction.FieldIndex:
		return m.Index()
	case feedconfigaction.FieldUpdatedAt:
		return m.UpdatedAt()
	case feedconfigaction.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedConfigActionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedconfigaction.FieldFeedConfigID:
		return m.OldFeedConfigID(ctx)
	case feedconfigaction.FieldFeedActionSetID:
		return m.OldFeedActionSetID(ctx)
	case feedconfigaction.FieldIndex:
		return m.OldIndex(ctx)
	case feedconfigaction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feedconfigaction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeedConfigAction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedConfigActionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedconfigaction.FieldFeedConfigID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedConfigID(v)
		return nil
	case feedconfigaction.FieldFeedActionSetID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedActionSetID(v)
		return nil
	case feedconfigaction.FieldIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case feedconfigaction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feedconfigaction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeedConfigAction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedConfigActionMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, feedconfigaction.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedConfigActionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feedconfigaction.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedConfigActionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feedconfigaction.FieldIndex:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown FeedConfigAction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedConfigActionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedConfigActionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedConfigActionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeedConfigAction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedConfigActionMutation) ResetField(name string) error {
	switch name {
	case feedconfigaction.FieldFeedConfigID:
		m.ResetFeedConfigID()
		return nil
	case feedconfigaction.FieldFeedActionSetID:
		m.ResetFeedActionSetID()
		return nil
	case feedconfigaction.FieldIndex:
		m.ResetIndex()
		return nil
	case feedconfigaction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feedconfigaction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeedConfigAction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedConfigActionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.feed_config != nil {
		edges = append(edges, feedconfigaction.EdgeFeedConfig)
	}
	if m.feed_action_set != nil {
		edges = append(edges, feedconfigaction.EdgeFeedActionSet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedConfigActionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feedconfigaction.EdgeFeedConfig:
		if id := m.feed_config; id != nil {
			return []ent.Value{*id}
		}
	case feedconfigaction.EdgeFeedActionSet:
		if id := m.feed_action_set; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedConfigActionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedConfigActionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedConfigActionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfeed_config {
		edges = append(edges, feedconfigaction.EdgeFeedConfig)
	}
	if m.clearedfeed_action_set {
		edges = append(edges, feedconfigaction.EdgeFeedActionSet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedConfigActionMutation) EdgeCleared(name string) bool {
	switch name {
	case feedconfigaction.EdgeFeedConfig:
		return m.clearedfeed_config
	case feedconfigaction.EdgeFeedActionSet:
		return m.clearedfeed_action_set
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedConfigActionMutation) ClearEdge(name string) error {
	switch name {
	case feedconfigaction.EdgeFeedConfig:
		m.ClearFeedConfig()
		return nil
	case feedconfigaction.EdgeFeedActionSet:
		m.ClearFeedActionSet()
		return nil
	}
	return fmt.Errorf("unknown FeedConfigAction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedConfigActionMutation) ResetEdge(name string) error {
	switch name {
	case feedconfigaction.EdgeFeedConfig:
		m.ResetFeedConfig()
		return nil
	case feedconfigaction.EdgeFeedActionSet:
		m.ResetFeedActionSet()
		return nil
	}
	return fmt.Errorf("unknown FeedConfigAction edge %s", name)
}

// FeedItemMutation represents an operation that mutates the FeedItem nodes in the graph.
type FeedItemMutation struct {
	config
	op                          Op
	typ                         string
	id                          *model.InternalID
	title                       *string
	authors                     *[]*modelfeed.Person
	appendauthors               []*modelfeed.Person
	description                 *string
	content                     *string
	guid                        *string
	link                        *string
	image                       **modelfeed.Image
	published                   *string
	published_parsed            *time.Time
	updated                     *string
	updated_parsed              *time.Time
	enclosures                  *[]*modelfeed.Enclosure
	appendenclosures            []*modelfeed.Enclosure
	publish_platform            *string
	read_count                  *int64
	addread_count               *int64
	digest_description          *string
	digest_images               *[]*modelfeed.Image
	appenddigest_images         []*modelfeed.Image
	updated_at                  *time.Time
	created_at                  *time.Time
	clearedFields               map[string]struct{}
	feed                        *model.InternalID
	clearedfeed                 bool
	feed_item_collection        map[model.InternalID]struct{}
	removedfeed_item_collection map[model.InternalID]struct{}
	clearedfeed_item_collection bool
	done                        bool
	oldValue                    func(context.Context) (*FeedItem, error)
	predicates                  []predicate.FeedItem
}

var _ ent.Mutation = (*FeedItemMutation)(nil)

// feeditemOption allows management of the mutation configuration using functional options.
type feeditemOption func(*FeedItemMutation)

// newFeedItemMutation creates new mutation for the FeedItem entity.
func newFeedItemMutation(c config, op Op, opts ...feeditemOption) *FeedItemMutation {
	m := &FeedItemMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedItemID sets the ID field of the mutation.
func withFeedItemID(id model.InternalID) feeditemOption {
	return func(m *FeedItemMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedItem
		)
		m.oldValue = func(ctx context.Context) (*FeedItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedItem sets the old FeedItem of the mutation.
func withFeedItem(node *FeedItem) feeditemOption {
	return func(m *FeedItemMutation) {
		m.oldValue = func(context.Context) (*FeedItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeedItem entities.
func (m *FeedItemMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedItemMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedItemMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeedItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeedID sets the "feed_id" field.
func (m *FeedItemMutation) SetFeedID(mi model.InternalID) {
	m.feed = &mi
}

// FeedID returns the value of the "feed_id" field in the mutation.
func (m *FeedItemMutation) FeedID() (r model.InternalID, exists bool) {
	v := m.feed
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedID returns the old "feed_id" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldFeedID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedID: %w", err)
	}
	return oldValue.FeedID, nil
}

// ResetFeedID resets all changes to the "feed_id" field.
func (m *FeedItemMutation) ResetFeedID() {
	m.feed = nil
}

// SetTitle sets the "title" field.
func (m *FeedItemMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *FeedItemMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *FeedItemMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[feeditem.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *FeedItemMutation) TitleCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *FeedItemMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, feeditem.FieldTitle)
}

// SetAuthors sets the "authors" field.
func (m *FeedItemMutation) SetAuthors(value []*modelfeed.Person) {
	m.authors = &value
	m.appendauthors = nil
}

// Authors returns the value of the "authors" field in the mutation.
func (m *FeedItemMutation) Authors() (r []*modelfeed.Person, exists bool) {
	v := m.authors
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthors returns the old "authors" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldAuthors(ctx context.Context) (v []*modelfeed.Person, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthors: %w", err)
	}
	return oldValue.Authors, nil
}

// AppendAuthors adds value to the "authors" field.
func (m *FeedItemMutation) AppendAuthors(value []*modelfeed.Person) {
	m.appendauthors = append(m.appendauthors, value...)
}

// AppendedAuthors returns the list of values that were appended to the "authors" field in this mutation.
func (m *FeedItemMutation) AppendedAuthors() ([]*modelfeed.Person, bool) {
	if len(m.appendauthors) == 0 {
		return nil, false
	}
	return m.appendauthors, true
}

// ClearAuthors clears the value of the "authors" field.
func (m *FeedItemMutation) ClearAuthors() {
	m.authors = nil
	m.appendauthors = nil
	m.clearedFields[feeditem.FieldAuthors] = struct{}{}
}

// AuthorsCleared returns if the "authors" field was cleared in this mutation.
func (m *FeedItemMutation) AuthorsCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldAuthors]
	return ok
}

// ResetAuthors resets all changes to the "authors" field.
func (m *FeedItemMutation) ResetAuthors() {
	m.authors = nil
	m.appendauthors = nil
	delete(m.clearedFields, feeditem.FieldAuthors)
}

// SetDescription sets the "description" field.
func (m *FeedItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeedItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FeedItemMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[feeditem.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FeedItemMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FeedItemMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, feeditem.FieldDescription)
}

// SetContent sets the "content" field.
func (m *FeedItemMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *FeedItemMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *FeedItemMutation) ClearContent() {
	m.content = nil
	m.clearedFields[feeditem.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *FeedItemMutation) ContentCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *FeedItemMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, feeditem.FieldContent)
}

// SetGUID sets the "guid" field.
func (m *FeedItemMutation) SetGUID(s string) {
	m.guid = &s
}

// GUID returns the value of the "guid" field in the mutation.
func (m *FeedItemMutation) GUID() (r string, exists bool) {
	v := m.guid
	if v == nil {
		return
	}
	return *v, true
}

// OldGUID returns the old "guid" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldGUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGUID: %w", err)
	}
	return oldValue.GUID, nil
}

// ResetGUID resets all changes to the "guid" field.
func (m *FeedItemMutation) ResetGUID() {
	m.guid = nil
}

// SetLink sets the "link" field.
func (m *FeedItemMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *FeedItemMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *FeedItemMutation) ClearLink() {
	m.link = nil
	m.clearedFields[feeditem.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *FeedItemMutation) LinkCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *FeedItemMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, feeditem.FieldLink)
}

// SetImage sets the "image" field.
func (m *FeedItemMutation) SetImage(value *modelfeed.Image) {
	m.image = &value
}

// Image returns the value of the "image" field in the mutation.
func (m *FeedItemMutation) Image() (r *modelfeed.Image, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldImage(ctx context.Context) (v *modelfeed.Image, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "image" field.
func (m *FeedItemMutation) ClearImage() {
	m.image = nil
	m.clearedFields[feeditem.FieldImage] = struct{}{}
}

// ImageCleared returns if the "image" field was cleared in this mutation.
func (m *FeedItemMutation) ImageCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldImage]
	return ok
}

// ResetImage resets all changes to the "image" field.
func (m *FeedItemMutation) ResetImage() {
	m.image = nil
	delete(m.clearedFields, feeditem.FieldImage)
}

// SetPublished sets the "published" field.
func (m *FeedItemMutation) SetPublished(s string) {
	m.published = &s
}

// Published returns the value of the "published" field in the mutation.
func (m *FeedItemMutation) Published() (r string, exists bool) {
	v := m.published
	if v == nil {
		return
	}
	return *v, true
}

// OldPublished returns the old "published" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldPublished(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublished: %w", err)
	}
	return oldValue.Published, nil
}

// ClearPublished clears the value of the "published" field.
func (m *FeedItemMutation) ClearPublished() {
	m.published = nil
	m.clearedFields[feeditem.FieldPublished] = struct{}{}
}

// PublishedCleared returns if the "published" field was cleared in this mutation.
func (m *FeedItemMutation) PublishedCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldPublished]
	return ok
}

// ResetPublished resets all changes to the "published" field.
func (m *FeedItemMutation) ResetPublished() {
	m.published = nil
	delete(m.clearedFields, feeditem.FieldPublished)
}

// SetPublishedParsed sets the "published_parsed" field.
func (m *FeedItemMutation) SetPublishedParsed(t time.Time) {
	m.published_parsed = &t
}

// PublishedParsed returns the value of the "published_parsed" field in the mutation.
func (m *FeedItemMutation) PublishedParsed() (r time.Time, exists bool) {
	v := m.published_parsed
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishedParsed returns the old "published_parsed" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldPublishedParsed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishedParsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishedParsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishedParsed: %w", err)
	}
	return oldValue.PublishedParsed, nil
}

// ResetPublishedParsed resets all changes to the "published_parsed" field.
func (m *FeedItemMutation) ResetPublishedParsed() {
	m.published_parsed = nil
}

// SetUpdated sets the "updated" field.
func (m *FeedItemMutation) SetUpdated(s string) {
	m.updated = &s
}

// Updated returns the value of the "updated" field in the mutation.
func (m *FeedItemMutation) Updated() (r string, exists bool) {
	v := m.updated
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdated returns the old "updated" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldUpdated(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdated: %w", err)
	}
	return oldValue.Updated, nil
}

// ClearUpdated clears the value of the "updated" field.
func (m *FeedItemMutation) ClearUpdated() {
	m.updated = nil
	m.clearedFields[feeditem.FieldUpdated] = struct{}{}
}

// UpdatedCleared returns if the "updated" field was cleared in this mutation.
func (m *FeedItemMutation) UpdatedCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldUpdated]
	return ok
}

// ResetUpdated resets all changes to the "updated" field.
func (m *FeedItemMutation) ResetUpdated() {
	m.updated = nil
	delete(m.clearedFields, feeditem.FieldUpdated)
}

// SetUpdatedParsed sets the "updated_parsed" field.
func (m *FeedItemMutation) SetUpdatedParsed(t time.Time) {
	m.updated_parsed = &t
}

// UpdatedParsed returns the value of the "updated_parsed" field in the mutation.
func (m *FeedItemMutation) UpdatedParsed() (r time.Time, exists bool) {
	v := m.updated_parsed
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedParsed returns the old "updated_parsed" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldUpdatedParsed(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedParsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedParsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedParsed: %w", err)
	}
	return oldValue.UpdatedParsed, nil
}

// ClearUpdatedParsed clears the value of the "updated_parsed" field.
func (m *FeedItemMutation) ClearUpdatedParsed() {
	m.updated_parsed = nil
	m.clearedFields[feeditem.FieldUpdatedParsed] = struct{}{}
}

// UpdatedParsedCleared returns if the "updated_parsed" field was cleared in this mutation.
func (m *FeedItemMutation) UpdatedParsedCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldUpdatedParsed]
	return ok
}

// ResetUpdatedParsed resets all changes to the "updated_parsed" field.
func (m *FeedItemMutation) ResetUpdatedParsed() {
	m.updated_parsed = nil
	delete(m.clearedFields, feeditem.FieldUpdatedParsed)
}

// SetEnclosures sets the "enclosures" field.
func (m *FeedItemMutation) SetEnclosures(value []*modelfeed.Enclosure) {
	m.enclosures = &value
	m.appendenclosures = nil
}

// Enclosures returns the value of the "enclosures" field in the mutation.
func (m *FeedItemMutation) Enclosures() (r []*modelfeed.Enclosure, exists bool) {
	v := m.enclosures
	if v == nil {
		return
	}
	return *v, true
}

// OldEnclosures returns the old "enclosures" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldEnclosures(ctx context.Context) (v []*modelfeed.Enclosure, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnclosures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnclosures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnclosures: %w", err)
	}
	return oldValue.Enclosures, nil
}

// AppendEnclosures adds value to the "enclosures" field.
func (m *FeedItemMutation) AppendEnclosures(value []*modelfeed.Enclosure) {
	m.appendenclosures = append(m.appendenclosures, value...)
}

// AppendedEnclosures returns the list of values that were appended to the "enclosures" field in this mutation.
func (m *FeedItemMutation) AppendedEnclosures() ([]*modelfeed.Enclosure, bool) {
	if len(m.appendenclosures) == 0 {
		return nil, false
	}
	return m.appendenclosures, true
}

// ClearEnclosures clears the value of the "enclosures" field.
func (m *FeedItemMutation) ClearEnclosures() {
	m.enclosures = nil
	m.appendenclosures = nil
	m.clearedFields[feeditem.FieldEnclosures] = struct{}{}
}

// EnclosuresCleared returns if the "enclosures" field was cleared in this mutation.
func (m *FeedItemMutation) EnclosuresCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldEnclosures]
	return ok
}

// ResetEnclosures resets all changes to the "enclosures" field.
func (m *FeedItemMutation) ResetEnclosures() {
	m.enclosures = nil
	m.appendenclosures = nil
	delete(m.clearedFields, feeditem.FieldEnclosures)
}

// SetPublishPlatform sets the "publish_platform" field.
func (m *FeedItemMutation) SetPublishPlatform(s string) {
	m.publish_platform = &s
}

// PublishPlatform returns the value of the "publish_platform" field in the mutation.
func (m *FeedItemMutation) PublishPlatform() (r string, exists bool) {
	v := m.publish_platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPublishPlatform returns the old "publish_platform" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldPublishPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublishPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublishPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublishPlatform: %w", err)
	}
	return oldValue.PublishPlatform, nil
}

// ClearPublishPlatform clears the value of the "publish_platform" field.
func (m *FeedItemMutation) ClearPublishPlatform() {
	m.publish_platform = nil
	m.clearedFields[feeditem.FieldPublishPlatform] = struct{}{}
}

// PublishPlatformCleared returns if the "publish_platform" field was cleared in this mutation.
func (m *FeedItemMutation) PublishPlatformCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldPublishPlatform]
	return ok
}

// ResetPublishPlatform resets all changes to the "publish_platform" field.
func (m *FeedItemMutation) ResetPublishPlatform() {
	m.publish_platform = nil
	delete(m.clearedFields, feeditem.FieldPublishPlatform)
}

// SetReadCount sets the "read_count" field.
func (m *FeedItemMutation) SetReadCount(i int64) {
	m.read_count = &i
	m.addread_count = nil
}

// ReadCount returns the value of the "read_count" field in the mutation.
func (m *FeedItemMutation) ReadCount() (r int64, exists bool) {
	v := m.read_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReadCount returns the old "read_count" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldReadCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadCount: %w", err)
	}
	return oldValue.ReadCount, nil
}

// AddReadCount adds i to the "read_count" field.
func (m *FeedItemMutation) AddReadCount(i int64) {
	if m.addread_count != nil {
		*m.addread_count += i
	} else {
		m.addread_count = &i
	}
}

// AddedReadCount returns the value that was added to the "read_count" field in this mutation.
func (m *FeedItemMutation) AddedReadCount() (r int64, exists bool) {
	v := m.addread_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReadCount resets all changes to the "read_count" field.
func (m *FeedItemMutation) ResetReadCount() {
	m.read_count = nil
	m.addread_count = nil
}

// SetDigestDescription sets the "digest_description" field.
func (m *FeedItemMutation) SetDigestDescription(s string) {
	m.digest_description = &s
}

// DigestDescription returns the value of the "digest_description" field in the mutation.
func (m *FeedItemMutation) DigestDescription() (r string, exists bool) {
	v := m.digest_description
	if v == nil {
		return
	}
	return *v, true
}

// OldDigestDescription returns the old "digest_description" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldDigestDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigestDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigestDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigestDescription: %w", err)
	}
	return oldValue.DigestDescription, nil
}

// ClearDigestDescription clears the value of the "digest_description" field.
func (m *FeedItemMutation) ClearDigestDescription() {
	m.digest_description = nil
	m.clearedFields[feeditem.FieldDigestDescription] = struct{}{}
}

// DigestDescriptionCleared returns if the "digest_description" field was cleared in this mutation.
func (m *FeedItemMutation) DigestDescriptionCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldDigestDescription]
	return ok
}

// ResetDigestDescription resets all changes to the "digest_description" field.
func (m *FeedItemMutation) ResetDigestDescription() {
	m.digest_description = nil
	delete(m.clearedFields, feeditem.FieldDigestDescription)
}

// SetDigestImages sets the "digest_images" field.
func (m *FeedItemMutation) SetDigestImages(value []*modelfeed.Image) {
	m.digest_images = &value
	m.appenddigest_images = nil
}

// DigestImages returns the value of the "digest_images" field in the mutation.
func (m *FeedItemMutation) DigestImages() (r []*modelfeed.Image, exists bool) {
	v := m.digest_images
	if v == nil {
		return
	}
	return *v, true
}

// OldDigestImages returns the old "digest_images" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldDigestImages(ctx context.Context) (v []*modelfeed.Image, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDigestImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDigestImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDigestImages: %w", err)
	}
	return oldValue.DigestImages, nil
}

// AppendDigestImages adds value to the "digest_images" field.
func (m *FeedItemMutation) AppendDigestImages(value []*modelfeed.Image) {
	m.appenddigest_images = append(m.appenddigest_images, value...)
}

// AppendedDigestImages returns the list of values that were appended to the "digest_images" field in this mutation.
func (m *FeedItemMutation) AppendedDigestImages() ([]*modelfeed.Image, bool) {
	if len(m.appenddigest_images) == 0 {
		return nil, false
	}
	return m.appenddigest_images, true
}

// ClearDigestImages clears the value of the "digest_images" field.
func (m *FeedItemMutation) ClearDigestImages() {
	m.digest_images = nil
	m.appenddigest_images = nil
	m.clearedFields[feeditem.FieldDigestImages] = struct{}{}
}

// DigestImagesCleared returns if the "digest_images" field was cleared in this mutation.
func (m *FeedItemMutation) DigestImagesCleared() bool {
	_, ok := m.clearedFields[feeditem.FieldDigestImages]
	return ok
}

// ResetDigestImages resets all changes to the "digest_images" field.
func (m *FeedItemMutation) ResetDigestImages() {
	m.digest_images = nil
	m.appenddigest_images = nil
	delete(m.clearedFields, feeditem.FieldDigestImages)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedItemMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedItemMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedItemMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedItemMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeedItem entity.
// If the FeedItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedItemMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearFeed clears the "feed" edge to the Feed entity.
func (m *FeedItemMutation) ClearFeed() {
	m.clearedfeed = true
	m.clearedFields[feeditem.FieldFeedID] = struct{}{}
}

// FeedCleared reports if the "feed" edge to the Feed entity was cleared.
func (m *FeedItemMutation) FeedCleared() bool {
	return m.clearedfeed
}

// FeedIDs returns the "feed" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedID instead. It exists only for internal usage by the builders.
func (m *FeedItemMutation) FeedIDs() (ids []model.InternalID) {
	if id := m.feed; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeed resets all changes to the "feed" edge.
func (m *FeedItemMutation) ResetFeed() {
	m.feed = nil
	m.clearedfeed = false
}

// AddFeedItemCollectionIDs adds the "feed_item_collection" edge to the FeedItemCollection entity by ids.
func (m *FeedItemMutation) AddFeedItemCollectionIDs(ids ...model.InternalID) {
	if m.feed_item_collection == nil {
		m.feed_item_collection = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_item_collection[ids[i]] = struct{}{}
	}
}

// ClearFeedItemCollection clears the "feed_item_collection" edge to the FeedItemCollection entity.
func (m *FeedItemMutation) ClearFeedItemCollection() {
	m.clearedfeed_item_collection = true
}

// FeedItemCollectionCleared reports if the "feed_item_collection" edge to the FeedItemCollection entity was cleared.
func (m *FeedItemMutation) FeedItemCollectionCleared() bool {
	return m.clearedfeed_item_collection
}

// RemoveFeedItemCollectionIDs removes the "feed_item_collection" edge to the FeedItemCollection entity by IDs.
func (m *FeedItemMutation) RemoveFeedItemCollectionIDs(ids ...model.InternalID) {
	if m.removedfeed_item_collection == nil {
		m.removedfeed_item_collection = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_item_collection, ids[i])
		m.removedfeed_item_collection[ids[i]] = struct{}{}
	}
}

// RemovedFeedItemCollection returns the removed IDs of the "feed_item_collection" edge to the FeedItemCollection entity.
func (m *FeedItemMutation) RemovedFeedItemCollectionIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_item_collection {
		ids = append(ids, id)
	}
	return
}

// FeedItemCollectionIDs returns the "feed_item_collection" edge IDs in the mutation.
func (m *FeedItemMutation) FeedItemCollectionIDs() (ids []model.InternalID) {
	for id := range m.feed_item_collection {
		ids = append(ids, id)
	}
	return
}

// ResetFeedItemCollection resets all changes to the "feed_item_collection" edge.
func (m *FeedItemMutation) ResetFeedItemCollection() {
	m.feed_item_collection = nil
	m.clearedfeed_item_collection = false
	m.removedfeed_item_collection = nil
}

// Where appends a list predicates to the FeedItemMutation builder.
func (m *FeedItemMutation) Where(ps ...predicate.FeedItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeedItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeedItem).
func (m *FeedItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedItemMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.feed != nil {
		fields = append(fields, feeditem.FieldFeedID)
	}
	if m.title != nil {
		fields = append(fields, feeditem.FieldTitle)
	}
	if m.authors != nil {
		fields = append(fields, feeditem.FieldAuthors)
	}
	if m.description != nil {
		fields = append(fields, feeditem.FieldDescription)
	}
	if m.content != nil {
		fields = append(fields, feeditem.FieldContent)
	}
	if m.guid != nil {
		fields = append(fields, feeditem.FieldGUID)
	}
	if m.link != nil {
		fields = append(fields, feeditem.FieldLink)
	}
	if m.image != nil {
		fields = append(fields, feeditem.FieldImage)
	}
	if m.published != nil {
		fields = append(fields, feeditem.FieldPublished)
	}
	if m.published_parsed != nil {
		fields = append(fields, feeditem.FieldPublishedParsed)
	}
	if m.updated != nil {
		fields = append(fields, feeditem.FieldUpdated)
	}
	if m.updated_parsed != nil {
		fields = append(fields, feeditem.FieldUpdatedParsed)
	}
	if m.enclosures != nil {
		fields = append(fields, feeditem.FieldEnclosures)
	}
	if m.publish_platform != nil {
		fields = append(fields, feeditem.FieldPublishPlatform)
	}
	if m.read_count != nil {
		fields = append(fields, feeditem.FieldReadCount)
	}
	if m.digest_description != nil {
		fields = append(fields, feeditem.FieldDigestDescription)
	}
	if m.digest_images != nil {
		fields = append(fields, feeditem.FieldDigestImages)
	}
	if m.updated_at != nil {
		fields = append(fields, feeditem.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feeditem.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feeditem.FieldFeedID:
		return m.FeedID()
	case feeditem.FieldTitle:
		return m.Title()
	case feeditem.FieldAuthors:
		return m.Authors()
	case feeditem.FieldDescription:
		return m.Description()
	case feeditem.FieldContent:
		return m.Content()
	case feeditem.FieldGUID:
		return m.GUID()
	case feeditem.FieldLink:
		return m.Link()
	case feeditem.FieldImage:
		return m.Image()
	case feeditem.FieldPublished:
		return m.Published()
	case feeditem.FieldPublishedParsed:
		return m.PublishedParsed()
	case feeditem.FieldUpdated:
		return m.Updated()
	case feeditem.FieldUpdatedParsed:
		return m.UpdatedParsed()
	case feeditem.FieldEnclosures:
		return m.Enclosures()
	case feeditem.FieldPublishPlatform:
		return m.PublishPlatform()
	case feeditem.FieldReadCount:
		return m.ReadCount()
	case feeditem.FieldDigestDescription:
		return m.DigestDescription()
	case feeditem.FieldDigestImages:
		return m.DigestImages()
	case feeditem.FieldUpdatedAt:
		return m.UpdatedAt()
	case feeditem.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feeditem.FieldFeedID:
		return m.OldFeedID(ctx)
	case feeditem.FieldTitle:
		return m.OldTitle(ctx)
	case feeditem.FieldAuthors:
		return m.OldAuthors(ctx)
	case feeditem.FieldDescription:
		return m.OldDescription(ctx)
	case feeditem.FieldContent:
		return m.OldContent(ctx)
	case feeditem.FieldGUID:
		return m.OldGUID(ctx)
	case feeditem.FieldLink:
		return m.OldLink(ctx)
	case feeditem.FieldImage:
		return m.OldImage(ctx)
	case feeditem.FieldPublished:
		return m.OldPublished(ctx)
	case feeditem.FieldPublishedParsed:
		return m.OldPublishedParsed(ctx)
	case feeditem.FieldUpdated:
		return m.OldUpdated(ctx)
	case feeditem.FieldUpdatedParsed:
		return m.OldUpdatedParsed(ctx)
	case feeditem.FieldEnclosures:
		return m.OldEnclosures(ctx)
	case feeditem.FieldPublishPlatform:
		return m.OldPublishPlatform(ctx)
	case feeditem.FieldReadCount:
		return m.OldReadCount(ctx)
	case feeditem.FieldDigestDescription:
		return m.OldDigestDescription(ctx)
	case feeditem.FieldDigestImages:
		return m.OldDigestImages(ctx)
	case feeditem.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feeditem.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeedItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feeditem.FieldFeedID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedID(v)
		return nil
	case feeditem.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case feeditem.FieldAuthors:
		v, ok := value.([]*modelfeed.Person)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthors(v)
		return nil
	case feeditem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feeditem.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case feeditem.FieldGUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGUID(v)
		return nil
	case feeditem.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case feeditem.FieldImage:
		v, ok := value.(*modelfeed.Image)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case feeditem.FieldPublished:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublished(v)
		return nil
	case feeditem.FieldPublishedParsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedParsed(v)
		return nil
	case feeditem.FieldUpdated:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdated(v)
		return nil
	case feeditem.FieldUpdatedParsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedParsed(v)
		return nil
	case feeditem.FieldEnclosures:
		v, ok := value.([]*modelfeed.Enclosure)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnclosures(v)
		return nil
	case feeditem.FieldPublishPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishPlatform(v)
		return nil
	case feeditem.FieldReadCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadCount(v)
		return nil
	case feeditem.FieldDigestDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigestDescription(v)
		return nil
	case feeditem.FieldDigestImages:
		v, ok := value.([]*modelfeed.Image)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDigestImages(v)
		return nil
	case feeditem.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feeditem.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeedItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedItemMutation) AddedFields() []string {
	var fields []string
	if m.addread_count != nil {
		fields = append(fields, feeditem.FieldReadCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feeditem.FieldReadCount:
		return m.AddedReadCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feeditem.FieldReadCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReadCount(v)
		return nil
	}
	return fmt.Errorf("unknown FeedItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feeditem.FieldTitle) {
		fields = append(fields, feeditem.FieldTitle)
	}
	if m.FieldCleared(feeditem.FieldAuthors) {
		fields = append(fields, feeditem.FieldAuthors)
	}
	if m.FieldCleared(feeditem.FieldDescription) {
		fields = append(fields, feeditem.FieldDescription)
	}
	if m.FieldCleared(feeditem.FieldContent) {
		fields = append(fields, feeditem.FieldContent)
	}
	if m.FieldCleared(feeditem.FieldLink) {
		fields = append(fields, feeditem.FieldLink)
	}
	if m.FieldCleared(feeditem.FieldImage) {
		fields = append(fields, feeditem.FieldImage)
	}
	if m.FieldCleared(feeditem.FieldPublished) {
		fields = append(fields, feeditem.FieldPublished)
	}
	if m.FieldCleared(feeditem.FieldUpdated) {
		fields = append(fields, feeditem.FieldUpdated)
	}
	if m.FieldCleared(feeditem.FieldUpdatedParsed) {
		fields = append(fields, feeditem.FieldUpdatedParsed)
	}
	if m.FieldCleared(feeditem.FieldEnclosures) {
		fields = append(fields, feeditem.FieldEnclosures)
	}
	if m.FieldCleared(feeditem.FieldPublishPlatform) {
		fields = append(fields, feeditem.FieldPublishPlatform)
	}
	if m.FieldCleared(feeditem.FieldDigestDescription) {
		fields = append(fields, feeditem.FieldDigestDescription)
	}
	if m.FieldCleared(feeditem.FieldDigestImages) {
		fields = append(fields, feeditem.FieldDigestImages)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedItemMutation) ClearField(name string) error {
	switch name {
	case feeditem.FieldTitle:
		m.ClearTitle()
		return nil
	case feeditem.FieldAuthors:
		m.ClearAuthors()
		return nil
	case feeditem.FieldDescription:
		m.ClearDescription()
		return nil
	case feeditem.FieldContent:
		m.ClearContent()
		return nil
	case feeditem.FieldLink:
		m.ClearLink()
		return nil
	case feeditem.FieldImage:
		m.ClearImage()
		return nil
	case feeditem.FieldPublished:
		m.ClearPublished()
		return nil
	case feeditem.FieldUpdated:
		m.ClearUpdated()
		return nil
	case feeditem.FieldUpdatedParsed:
		m.ClearUpdatedParsed()
		return nil
	case feeditem.FieldEnclosures:
		m.ClearEnclosures()
		return nil
	case feeditem.FieldPublishPlatform:
		m.ClearPublishPlatform()
		return nil
	case feeditem.FieldDigestDescription:
		m.ClearDigestDescription()
		return nil
	case feeditem.FieldDigestImages:
		m.ClearDigestImages()
		return nil
	}
	return fmt.Errorf("unknown FeedItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedItemMutation) ResetField(name string) error {
	switch name {
	case feeditem.FieldFeedID:
		m.ResetFeedID()
		return nil
	case feeditem.FieldTitle:
		m.ResetTitle()
		return nil
	case feeditem.FieldAuthors:
		m.ResetAuthors()
		return nil
	case feeditem.FieldDescription:
		m.ResetDescription()
		return nil
	case feeditem.FieldContent:
		m.ResetContent()
		return nil
	case feeditem.FieldGUID:
		m.ResetGUID()
		return nil
	case feeditem.FieldLink:
		m.ResetLink()
		return nil
	case feeditem.FieldImage:
		m.ResetImage()
		return nil
	case feeditem.FieldPublished:
		m.ResetPublished()
		return nil
	case feeditem.FieldPublishedParsed:
		m.ResetPublishedParsed()
		return nil
	case feeditem.FieldUpdated:
		m.ResetUpdated()
		return nil
	case feeditem.FieldUpdatedParsed:
		m.ResetUpdatedParsed()
		return nil
	case feeditem.FieldEnclosures:
		m.ResetEnclosures()
		return nil
	case feeditem.FieldPublishPlatform:
		m.ResetPublishPlatform()
		return nil
	case feeditem.FieldReadCount:
		m.ResetReadCount()
		return nil
	case feeditem.FieldDigestDescription:
		m.ResetDigestDescription()
		return nil
	case feeditem.FieldDigestImages:
		m.ResetDigestImages()
		return nil
	case feeditem.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feeditem.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeedItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.feed != nil {
		edges = append(edges, feeditem.EdgeFeed)
	}
	if m.feed_item_collection != nil {
		edges = append(edges, feeditem.EdgeFeedItemCollection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feeditem.EdgeFeed:
		if id := m.feed; id != nil {
			return []ent.Value{*id}
		}
	case feeditem.EdgeFeedItemCollection:
		ids := make([]ent.Value, 0, len(m.feed_item_collection))
		for id := range m.feed_item_collection {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfeed_item_collection != nil {
		edges = append(edges, feeditem.EdgeFeedItemCollection)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feeditem.EdgeFeedItemCollection:
		ids := make([]ent.Value, 0, len(m.removedfeed_item_collection))
		for id := range m.removedfeed_item_collection {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfeed {
		edges = append(edges, feeditem.EdgeFeed)
	}
	if m.clearedfeed_item_collection {
		edges = append(edges, feeditem.EdgeFeedItemCollection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedItemMutation) EdgeCleared(name string) bool {
	switch name {
	case feeditem.EdgeFeed:
		return m.clearedfeed
	case feeditem.EdgeFeedItemCollection:
		return m.clearedfeed_item_collection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedItemMutation) ClearEdge(name string) error {
	switch name {
	case feeditem.EdgeFeed:
		m.ClearFeed()
		return nil
	}
	return fmt.Errorf("unknown FeedItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedItemMutation) ResetEdge(name string) error {
	switch name {
	case feeditem.EdgeFeed:
		m.ResetFeed()
		return nil
	case feeditem.EdgeFeedItemCollection:
		m.ResetFeedItemCollection()
		return nil
	}
	return fmt.Errorf("unknown FeedItem edge %s", name)
}

// FeedItemCollectionMutation represents an operation that mutates the FeedItemCollection nodes in the graph.
type FeedItemCollectionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *model.InternalID
	name                 *string
	description          *string
	category             *string
	updated_at           *time.Time
	created_at           *time.Time
	clearedFields        map[string]struct{}
	owner                *model.InternalID
	clearedowner         bool
	feed_item            map[model.InternalID]struct{}
	removedfeed_item     map[model.InternalID]struct{}
	clearedfeed_item     bool
	notify_source        map[model.InternalID]struct{}
	removednotify_source map[model.InternalID]struct{}
	clearednotify_source bool
	done                 bool
	oldValue             func(context.Context) (*FeedItemCollection, error)
	predicates           []predicate.FeedItemCollection
}

var _ ent.Mutation = (*FeedItemCollectionMutation)(nil)

// feeditemcollectionOption allows management of the mutation configuration using functional options.
type feeditemcollectionOption func(*FeedItemCollectionMutation)

// newFeedItemCollectionMutation creates new mutation for the FeedItemCollection entity.
func newFeedItemCollectionMutation(c config, op Op, opts ...feeditemcollectionOption) *FeedItemCollectionMutation {
	m := &FeedItemCollectionMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedItemCollection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedItemCollectionID sets the ID field of the mutation.
func withFeedItemCollectionID(id model.InternalID) feeditemcollectionOption {
	return func(m *FeedItemCollectionMutation) {
		var (
			err   error
			once  sync.Once
			value *FeedItemCollection
		)
		m.oldValue = func(ctx context.Context) (*FeedItemCollection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeedItemCollection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedItemCollection sets the old FeedItemCollection of the mutation.
func withFeedItemCollection(node *FeedItemCollection) feeditemcollectionOption {
	return func(m *FeedItemCollectionMutation) {
		m.oldValue = func(context.Context) (*FeedItemCollection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedItemCollectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedItemCollectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeedItemCollection entities.
func (m *FeedItemCollectionMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedItemCollectionMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedItemCollectionMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeedItemCollection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FeedItemCollectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeedItemCollectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeedItemCollection entity.
// If the FeedItemCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemCollectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeedItemCollectionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *FeedItemCollectionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeedItemCollectionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeedItemCollection entity.
// If the FeedItemCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemCollectionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FeedItemCollectionMutation) ResetDescription() {
	m.description = nil
}

// SetCategory sets the "category" field.
func (m *FeedItemCollectionMutation) SetCategory(s string) {
	m.category = &s
}

// Category returns the value of the "category" field in the mutation.
func (m *FeedItemCollectionMutation) Category() (r string, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the FeedItemCollection entity.
// If the FeedItemCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemCollectionMutation) OldCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *FeedItemCollectionMutation) ResetCategory() {
	m.category = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedItemCollectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedItemCollectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeedItemCollection entity.
// If the FeedItemCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemCollectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedItemCollectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedItemCollectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedItemCollectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeedItemCollection entity.
// If the FeedItemCollection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedItemCollectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedItemCollectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *FeedItemCollectionMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FeedItemCollectionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FeedItemCollectionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *FeedItemCollectionMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FeedItemCollectionMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FeedItemCollectionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddFeedItemIDs adds the "feed_item" edge to the FeedItem entity by ids.
func (m *FeedItemCollectionMutation) AddFeedItemIDs(ids ...model.InternalID) {
	if m.feed_item == nil {
		m.feed_item = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_item[ids[i]] = struct{}{}
	}
}

// ClearFeedItem clears the "feed_item" edge to the FeedItem entity.
func (m *FeedItemCollectionMutation) ClearFeedItem() {
	m.clearedfeed_item = true
}

// FeedItemCleared reports if the "feed_item" edge to the FeedItem entity was cleared.
func (m *FeedItemCollectionMutation) FeedItemCleared() bool {
	return m.clearedfeed_item
}

// RemoveFeedItemIDs removes the "feed_item" edge to the FeedItem entity by IDs.
func (m *FeedItemCollectionMutation) RemoveFeedItemIDs(ids ...model.InternalID) {
	if m.removedfeed_item == nil {
		m.removedfeed_item = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_item, ids[i])
		m.removedfeed_item[ids[i]] = struct{}{}
	}
}

// RemovedFeedItem returns the removed IDs of the "feed_item" edge to the FeedItem entity.
func (m *FeedItemCollectionMutation) RemovedFeedItemIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_item {
		ids = append(ids, id)
	}
	return
}

// FeedItemIDs returns the "feed_item" edge IDs in the mutation.
func (m *FeedItemCollectionMutation) FeedItemIDs() (ids []model.InternalID) {
	for id := range m.feed_item {
		ids = append(ids, id)
	}
	return
}

// ResetFeedItem resets all changes to the "feed_item" edge.
func (m *FeedItemCollectionMutation) ResetFeedItem() {
	m.feed_item = nil
	m.clearedfeed_item = false
	m.removedfeed_item = nil
}

// AddNotifySourceIDs adds the "notify_source" edge to the NotifySource entity by ids.
func (m *FeedItemCollectionMutation) AddNotifySourceIDs(ids ...model.InternalID) {
	if m.notify_source == nil {
		m.notify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_source[ids[i]] = struct{}{}
	}
}

// ClearNotifySource clears the "notify_source" edge to the NotifySource entity.
func (m *FeedItemCollectionMutation) ClearNotifySource() {
	m.clearednotify_source = true
}

// NotifySourceCleared reports if the "notify_source" edge to the NotifySource entity was cleared.
func (m *FeedItemCollectionMutation) NotifySourceCleared() bool {
	return m.clearednotify_source
}

// RemoveNotifySourceIDs removes the "notify_source" edge to the NotifySource entity by IDs.
func (m *FeedItemCollectionMutation) RemoveNotifySourceIDs(ids ...model.InternalID) {
	if m.removednotify_source == nil {
		m.removednotify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_source, ids[i])
		m.removednotify_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifySource returns the removed IDs of the "notify_source" edge to the NotifySource entity.
func (m *FeedItemCollectionMutation) RemovedNotifySourceIDs() (ids []model.InternalID) {
	for id := range m.removednotify_source {
		ids = append(ids, id)
	}
	return
}

// NotifySourceIDs returns the "notify_source" edge IDs in the mutation.
func (m *FeedItemCollectionMutation) NotifySourceIDs() (ids []model.InternalID) {
	for id := range m.notify_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifySource resets all changes to the "notify_source" edge.
func (m *FeedItemCollectionMutation) ResetNotifySource() {
	m.notify_source = nil
	m.clearednotify_source = false
	m.removednotify_source = nil
}

// Where appends a list predicates to the FeedItemCollectionMutation builder.
func (m *FeedItemCollectionMutation) Where(ps ...predicate.FeedItemCollection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedItemCollectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedItemCollectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeedItemCollection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedItemCollectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedItemCollectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeedItemCollection).
func (m *FeedItemCollectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedItemCollectionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, feeditemcollection.FieldName)
	}
	if m.description != nil {
		fields = append(fields, feeditemcollection.FieldDescription)
	}
	if m.category != nil {
		fields = append(fields, feeditemcollection.FieldCategory)
	}
	if m.updated_at != nil {
		fields = append(fields, feeditemcollection.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, feeditemcollection.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedItemCollectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feeditemcollection.FieldName:
		return m.Name()
	case feeditemcollection.FieldDescription:
		return m.Description()
	case feeditemcollection.FieldCategory:
		return m.Category()
	case feeditemcollection.FieldUpdatedAt:
		return m.UpdatedAt()
	case feeditemcollection.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedItemCollectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feeditemcollection.FieldName:
		return m.OldName(ctx)
	case feeditemcollection.FieldDescription:
		return m.OldDescription(ctx)
	case feeditemcollection.FieldCategory:
		return m.OldCategory(ctx)
	case feeditemcollection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feeditemcollection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FeedItemCollection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedItemCollectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feeditemcollection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feeditemcollection.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case feeditemcollection.FieldCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	case feeditemcollection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feeditemcollection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FeedItemCollection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedItemCollectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedItemCollectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedItemCollectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeedItemCollection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedItemCollectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedItemCollectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedItemCollectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeedItemCollection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedItemCollectionMutation) ResetField(name string) error {
	switch name {
	case feeditemcollection.FieldName:
		m.ResetName()
		return nil
	case feeditemcollection.FieldDescription:
		m.ResetDescription()
		return nil
	case feeditemcollection.FieldCategory:
		m.ResetCategory()
		return nil
	case feeditemcollection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feeditemcollection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown FeedItemCollection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedItemCollectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, feeditemcollection.EdgeOwner)
	}
	if m.feed_item != nil {
		edges = append(edges, feeditemcollection.EdgeFeedItem)
	}
	if m.notify_source != nil {
		edges = append(edges, feeditemcollection.EdgeNotifySource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedItemCollectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feeditemcollection.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case feeditemcollection.EdgeFeedItem:
		ids := make([]ent.Value, 0, len(m.feed_item))
		for id := range m.feed_item {
			ids = append(ids, id)
		}
		return ids
	case feeditemcollection.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.notify_source))
		for id := range m.notify_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedItemCollectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfeed_item != nil {
		edges = append(edges, feeditemcollection.EdgeFeedItem)
	}
	if m.removednotify_source != nil {
		edges = append(edges, feeditemcollection.EdgeNotifySource)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedItemCollectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case feeditemcollection.EdgeFeedItem:
		ids := make([]ent.Value, 0, len(m.removedfeed_item))
		for id := range m.removedfeed_item {
			ids = append(ids, id)
		}
		return ids
	case feeditemcollection.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.removednotify_source))
		for id := range m.removednotify_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedItemCollectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, feeditemcollection.EdgeOwner)
	}
	if m.clearedfeed_item {
		edges = append(edges, feeditemcollection.EdgeFeedItem)
	}
	if m.clearednotify_source {
		edges = append(edges, feeditemcollection.EdgeNotifySource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedItemCollectionMutation) EdgeCleared(name string) bool {
	switch name {
	case feeditemcollection.EdgeOwner:
		return m.clearedowner
	case feeditemcollection.EdgeFeedItem:
		return m.clearedfeed_item
	case feeditemcollection.EdgeNotifySource:
		return m.clearednotify_source
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedItemCollectionMutation) ClearEdge(name string) error {
	switch name {
	case feeditemcollection.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown FeedItemCollection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedItemCollectionMutation) ResetEdge(name string) error {
	switch name {
	case feeditemcollection.EdgeOwner:
		m.ResetOwner()
		return nil
	case feeditemcollection.EdgeFeedItem:
		m.ResetFeedItem()
		return nil
	case feeditemcollection.EdgeNotifySource:
		m.ResetNotifySource()
		return nil
	}
	return fmt.Errorf("unknown FeedItemCollection edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	name          *string
	size          *int64
	addsize       *int64
	_type         *file.Type
	sha256        *[]byte
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *model.InternalID
	clearedowner  bool
	image         *model.InternalID
	clearedimage  bool
	done          bool
	oldValue      func(context.Context) (*File, error)
	predicates    []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id model.InternalID) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetType sets the "type" field.
func (m *FileMutation) SetType(f file.Type) {
	m._type = &f
}

// GetType returns the value of the "type" field in the mutation.
func (m *FileMutation) GetType() (r file.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldType(ctx context.Context) (v file.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FileMutation) ResetType() {
	m._type = nil
}

// SetSha256 sets the "sha256" field.
func (m *FileMutation) SetSha256(b []byte) {
	m.sha256 = &b
}

// Sha256 returns the value of the "sha256" field in the mutation.
func (m *FileMutation) Sha256() (r []byte, exists bool) {
	v := m.sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldSha256 returns the old "sha256" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSha256(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha256: %w", err)
	}
	return oldValue.Sha256, nil
}

// ResetSha256 resets all changes to the "sha256" field.
func (m *FileMutation) ResetSha256() {
	m.sha256 = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *FileMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FileMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FileMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *FileMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FileMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FileMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetImageID sets the "image" edge to the Image entity by id.
func (m *FileMutation) SetImageID(id model.InternalID) {
	m.image = &id
}

// ClearImage clears the "image" edge to the Image entity.
func (m *FileMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *FileMutation) ImageCleared() bool {
	return m.clearedimage
}

// ImageID returns the "image" edge ID in the mutation.
func (m *FileMutation) ImageID() (id model.InternalID, exists bool) {
	if m.image != nil {
		return *m.image, true
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageID instead. It exists only for internal usage by the builders.
func (m *FileMutation) ImageIDs() (ids []model.InternalID) {
	if id := m.image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *FileMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m._type != nil {
		fields = append(fields, file.FieldType)
	}
	if m.sha256 != nil {
		fields = append(fields, file.FieldSha256)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldName:
		return m.Name()
	case file.FieldSize:
		return m.Size()
	case file.FieldType:
		return m.GetType()
	case file.FieldSha256:
		return m.Sha256()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldType:
		return m.OldType(ctx)
	case file.FieldSha256:
		return m.OldSha256(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldType:
		v, ok := value.(file.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case file.FieldSha256:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha256(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldType:
		m.ResetType()
		return nil
	case file.FieldSha256:
		m.ResetSha256()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, file.EdgeOwner)
	}
	if m.image != nil {
		edges = append(edges, file.EdgeImage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeImage:
		if id := m.image; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, file.EdgeOwner)
	}
	if m.clearedimage {
		edges = append(edges, file.EdgeImage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeOwner:
		return m.clearedowner
	case file.EdgeImage:
		return m.clearedimage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeOwner:
		m.ClearOwner()
		return nil
	case file.EdgeImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeOwner:
		m.ResetOwner()
		return nil
	case file.EdgeImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// ImageMutation represents an operation that mutates the Image nodes in the graph.
type ImageMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	name          *string
	description   *string
	status        *image.Status
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *model.InternalID
	clearedowner  bool
	file          *model.InternalID
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*Image, error)
	predicates    []predicate.Image
}

var _ ent.Mutation = (*ImageMutation)(nil)

// imageOption allows management of the mutation configuration using functional options.
type imageOption func(*ImageMutation)

// newImageMutation creates new mutation for the Image entity.
func newImageMutation(c config, op Op, opts ...imageOption) *ImageMutation {
	m := &ImageMutation{
		config:        c,
		op:            op,
		typ:           TypeImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImageID sets the ID field of the mutation.
func withImageID(id model.InternalID) imageOption {
	return func(m *ImageMutation) {
		var (
			err   error
			once  sync.Once
			value *Image
		)
		m.oldValue = func(ctx context.Context) (*Image, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Image.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImage sets the old Image of the mutation.
func withImage(node *Image) imageOption {
	return func(m *ImageMutation) {
		m.oldValue = func(context.Context) (*Image, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Image entities.
func (m *ImageMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImageMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImageMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Image.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ImageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ImageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ImageMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ImageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ImageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ImageMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *ImageMutation) SetStatus(i image.Status) {
	m.status = &i
}

// Status returns the value of the "status" field in the mutation.
func (m *ImageMutation) Status() (r image.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldStatus(ctx context.Context) (v image.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ImageMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ImageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ImageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ImageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ImageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ImageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Image entity.
// If the Image object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ImageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *ImageMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ImageMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ImageMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ImageMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ImageMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// SetFileID sets the "file" edge to the File entity by id.
func (m *ImageMutation) SetFileID(id model.InternalID) {
	m.file = &id
}

// ClearFile clears the "file" edge to the File entity.
func (m *ImageMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *ImageMutation) FileCleared() bool {
	return m.clearedfile
}

// FileID returns the "file" edge ID in the mutation.
func (m *ImageMutation) FileID() (id model.InternalID, exists bool) {
	if m.file != nil {
		return *m.file, true
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *ImageMutation) FileIDs() (ids []model.InternalID) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *ImageMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the ImageMutation builder.
func (m *ImageMutation) Where(ps ...predicate.Image) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Image, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Image).
func (m *ImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, image.FieldName)
	}
	if m.description != nil {
		fields = append(fields, image.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, image.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, image.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, image.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case image.FieldName:
		return m.Name()
	case image.FieldDescription:
		return m.Description()
	case image.FieldStatus:
		return m.Status()
	case image.FieldUpdatedAt:
		return m.UpdatedAt()
	case image.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case image.FieldName:
		return m.OldName(ctx)
	case image.FieldDescription:
		return m.OldDescription(ctx)
	case image.FieldStatus:
		return m.OldStatus(ctx)
	case image.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case image.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Image field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case image.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case image.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case image.FieldStatus:
		v, ok := value.(image.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case image.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case image.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Image numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Image nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImageMutation) ResetField(name string) error {
	switch name {
	case image.FieldName:
		m.ResetName()
		return nil
	case image.FieldDescription:
		m.ResetDescription()
		return nil
	case image.FieldStatus:
		m.ResetStatus()
		return nil
	case image.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case image.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Image field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, image.EdgeOwner)
	}
	if m.file != nil {
		edges = append(edges, image.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case image.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case image.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, image.EdgeOwner)
	}
	if m.clearedfile {
		edges = append(edges, image.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImageMutation) EdgeCleared(name string) bool {
	switch name {
	case image.EdgeOwner:
		return m.clearedowner
	case image.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImageMutation) ClearEdge(name string) error {
	switch name {
	case image.EdgeOwner:
		m.ClearOwner()
		return nil
	case image.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown Image unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImageMutation) ResetEdge(name string) error {
	switch name {
	case image.EdgeOwner:
		m.ResetOwner()
		return nil
	case image.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Image edge %s", name)
}

// NotifyFlowMutation represents an operation that mutates the NotifyFlow nodes in the graph.
type NotifyFlowMutation struct {
	config
	op                        Op
	typ                       string
	id                        *model.InternalID
	name                      *string
	description               *string
	status                    *notifyflow.Status
	updated_at                *time.Time
	created_at                *time.Time
	clearedFields             map[string]struct{}
	owner                     *model.InternalID
	clearedowner              bool
	notify_target             map[model.InternalID]struct{}
	removednotify_target      map[model.InternalID]struct{}
	clearednotify_target      bool
	notify_source             map[model.InternalID]struct{}
	removednotify_source      map[model.InternalID]struct{}
	clearednotify_source      bool
	notify_flow_target        map[int]struct{}
	removednotify_flow_target map[int]struct{}
	clearednotify_flow_target bool
	notify_flow_source        map[int]struct{}
	removednotify_flow_source map[int]struct{}
	clearednotify_flow_source bool
	done                      bool
	oldValue                  func(context.Context) (*NotifyFlow, error)
	predicates                []predicate.NotifyFlow
}

var _ ent.Mutation = (*NotifyFlowMutation)(nil)

// notifyflowOption allows management of the mutation configuration using functional options.
type notifyflowOption func(*NotifyFlowMutation)

// newNotifyFlowMutation creates new mutation for the NotifyFlow entity.
func newNotifyFlowMutation(c config, op Op, opts ...notifyflowOption) *NotifyFlowMutation {
	m := &NotifyFlowMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyFlowID sets the ID field of the mutation.
func withNotifyFlowID(id model.InternalID) notifyflowOption {
	return func(m *NotifyFlowMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyFlow
		)
		m.oldValue = func(ctx context.Context) (*NotifyFlow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyFlow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyFlow sets the old NotifyFlow of the mutation.
func withNotifyFlow(node *NotifyFlow) notifyflowOption {
	return func(m *NotifyFlowMutation) {
		m.oldValue = func(context.Context) (*NotifyFlow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyFlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyFlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotifyFlow entities.
func (m *NotifyFlowMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyFlowMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyFlowMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyFlow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NotifyFlowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotifyFlowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotifyFlowMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NotifyFlowMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotifyFlowMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *NotifyFlowMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *NotifyFlowMutation) SetStatus(n notifyflow.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NotifyFlowMutation) Status() (r notifyflow.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldStatus(ctx context.Context) (v notifyflow.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NotifyFlowMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyFlowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyFlowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyFlowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyFlowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyFlowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyFlow entity.
// If the NotifyFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyFlowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *NotifyFlowMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *NotifyFlowMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *NotifyFlowMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NotifyFlowMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NotifyFlowMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddNotifyTargetIDs adds the "notify_target" edge to the NotifyTarget entity by ids.
func (m *NotifyFlowMutation) AddNotifyTargetIDs(ids ...model.InternalID) {
	if m.notify_target == nil {
		m.notify_target = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_target[ids[i]] = struct{}{}
	}
}

// ClearNotifyTarget clears the "notify_target" edge to the NotifyTarget entity.
func (m *NotifyFlowMutation) ClearNotifyTarget() {
	m.clearednotify_target = true
}

// NotifyTargetCleared reports if the "notify_target" edge to the NotifyTarget entity was cleared.
func (m *NotifyFlowMutation) NotifyTargetCleared() bool {
	return m.clearednotify_target
}

// RemoveNotifyTargetIDs removes the "notify_target" edge to the NotifyTarget entity by IDs.
func (m *NotifyFlowMutation) RemoveNotifyTargetIDs(ids ...model.InternalID) {
	if m.removednotify_target == nil {
		m.removednotify_target = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_target, ids[i])
		m.removednotify_target[ids[i]] = struct{}{}
	}
}

// RemovedNotifyTarget returns the removed IDs of the "notify_target" edge to the NotifyTarget entity.
func (m *NotifyFlowMutation) RemovedNotifyTargetIDs() (ids []model.InternalID) {
	for id := range m.removednotify_target {
		ids = append(ids, id)
	}
	return
}

// NotifyTargetIDs returns the "notify_target" edge IDs in the mutation.
func (m *NotifyFlowMutation) NotifyTargetIDs() (ids []model.InternalID) {
	for id := range m.notify_target {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyTarget resets all changes to the "notify_target" edge.
func (m *NotifyFlowMutation) ResetNotifyTarget() {
	m.notify_target = nil
	m.clearednotify_target = false
	m.removednotify_target = nil
}

// AddNotifySourceIDs adds the "notify_source" edge to the NotifySource entity by ids.
func (m *NotifyFlowMutation) AddNotifySourceIDs(ids ...model.InternalID) {
	if m.notify_source == nil {
		m.notify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_source[ids[i]] = struct{}{}
	}
}

// ClearNotifySource clears the "notify_source" edge to the NotifySource entity.
func (m *NotifyFlowMutation) ClearNotifySource() {
	m.clearednotify_source = true
}

// NotifySourceCleared reports if the "notify_source" edge to the NotifySource entity was cleared.
func (m *NotifyFlowMutation) NotifySourceCleared() bool {
	return m.clearednotify_source
}

// RemoveNotifySourceIDs removes the "notify_source" edge to the NotifySource entity by IDs.
func (m *NotifyFlowMutation) RemoveNotifySourceIDs(ids ...model.InternalID) {
	if m.removednotify_source == nil {
		m.removednotify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_source, ids[i])
		m.removednotify_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifySource returns the removed IDs of the "notify_source" edge to the NotifySource entity.
func (m *NotifyFlowMutation) RemovedNotifySourceIDs() (ids []model.InternalID) {
	for id := range m.removednotify_source {
		ids = append(ids, id)
	}
	return
}

// NotifySourceIDs returns the "notify_source" edge IDs in the mutation.
func (m *NotifyFlowMutation) NotifySourceIDs() (ids []model.InternalID) {
	for id := range m.notify_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifySource resets all changes to the "notify_source" edge.
func (m *NotifyFlowMutation) ResetNotifySource() {
	m.notify_source = nil
	m.clearednotify_source = false
	m.removednotify_source = nil
}

// AddNotifyFlowTargetIDs adds the "notify_flow_target" edge to the NotifyFlowTarget entity by ids.
func (m *NotifyFlowMutation) AddNotifyFlowTargetIDs(ids ...int) {
	if m.notify_flow_target == nil {
		m.notify_flow_target = make(map[int]struct{})
	}
	for i := range ids {
		m.notify_flow_target[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlowTarget clears the "notify_flow_target" edge to the NotifyFlowTarget entity.
func (m *NotifyFlowMutation) ClearNotifyFlowTarget() {
	m.clearednotify_flow_target = true
}

// NotifyFlowTargetCleared reports if the "notify_flow_target" edge to the NotifyFlowTarget entity was cleared.
func (m *NotifyFlowMutation) NotifyFlowTargetCleared() bool {
	return m.clearednotify_flow_target
}

// RemoveNotifyFlowTargetIDs removes the "notify_flow_target" edge to the NotifyFlowTarget entity by IDs.
func (m *NotifyFlowMutation) RemoveNotifyFlowTargetIDs(ids ...int) {
	if m.removednotify_flow_target == nil {
		m.removednotify_flow_target = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notify_flow_target, ids[i])
		m.removednotify_flow_target[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlowTarget returns the removed IDs of the "notify_flow_target" edge to the NotifyFlowTarget entity.
func (m *NotifyFlowMutation) RemovedNotifyFlowTargetIDs() (ids []int) {
	for id := range m.removednotify_flow_target {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowTargetIDs returns the "notify_flow_target" edge IDs in the mutation.
func (m *NotifyFlowMutation) NotifyFlowTargetIDs() (ids []int) {
	for id := range m.notify_flow_target {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlowTarget resets all changes to the "notify_flow_target" edge.
func (m *NotifyFlowMutation) ResetNotifyFlowTarget() {
	m.notify_flow_target = nil
	m.clearednotify_flow_target = false
	m.removednotify_flow_target = nil
}

// AddNotifyFlowSourceIDs adds the "notify_flow_source" edge to the NotifyFlowSource entity by ids.
func (m *NotifyFlowMutation) AddNotifyFlowSourceIDs(ids ...int) {
	if m.notify_flow_source == nil {
		m.notify_flow_source = make(map[int]struct{})
	}
	for i := range ids {
		m.notify_flow_source[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlowSource clears the "notify_flow_source" edge to the NotifyFlowSource entity.
func (m *NotifyFlowMutation) ClearNotifyFlowSource() {
	m.clearednotify_flow_source = true
}

// NotifyFlowSourceCleared reports if the "notify_flow_source" edge to the NotifyFlowSource entity was cleared.
func (m *NotifyFlowMutation) NotifyFlowSourceCleared() bool {
	return m.clearednotify_flow_source
}

// RemoveNotifyFlowSourceIDs removes the "notify_flow_source" edge to the NotifyFlowSource entity by IDs.
func (m *NotifyFlowMutation) RemoveNotifyFlowSourceIDs(ids ...int) {
	if m.removednotify_flow_source == nil {
		m.removednotify_flow_source = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notify_flow_source, ids[i])
		m.removednotify_flow_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlowSource returns the removed IDs of the "notify_flow_source" edge to the NotifyFlowSource entity.
func (m *NotifyFlowMutation) RemovedNotifyFlowSourceIDs() (ids []int) {
	for id := range m.removednotify_flow_source {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowSourceIDs returns the "notify_flow_source" edge IDs in the mutation.
func (m *NotifyFlowMutation) NotifyFlowSourceIDs() (ids []int) {
	for id := range m.notify_flow_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlowSource resets all changes to the "notify_flow_source" edge.
func (m *NotifyFlowMutation) ResetNotifyFlowSource() {
	m.notify_flow_source = nil
	m.clearednotify_flow_source = false
	m.removednotify_flow_source = nil
}

// Where appends a list predicates to the NotifyFlowMutation builder.
func (m *NotifyFlowMutation) Where(ps ...predicate.NotifyFlow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyFlowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyFlowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyFlow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyFlowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyFlowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyFlow).
func (m *NotifyFlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyFlowMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, notifyflow.FieldName)
	}
	if m.description != nil {
		fields = append(fields, notifyflow.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, notifyflow.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, notifyflow.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifyflow.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyFlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifyflow.FieldName:
		return m.Name()
	case notifyflow.FieldDescription:
		return m.Description()
	case notifyflow.FieldStatus:
		return m.Status()
	case notifyflow.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifyflow.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyFlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifyflow.FieldName:
		return m.OldName(ctx)
	case notifyflow.FieldDescription:
		return m.OldDescription(ctx)
	case notifyflow.FieldStatus:
		return m.OldStatus(ctx)
	case notifyflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifyflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyFlow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifyflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notifyflow.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notifyflow.FieldStatus:
		v, ok := value.(notifyflow.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case notifyflow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifyflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyFlow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyFlowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyFlowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifyFlow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyFlowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyFlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyFlowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotifyFlow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyFlowMutation) ResetField(name string) error {
	switch name {
	case notifyflow.FieldName:
		m.ResetName()
		return nil
	case notifyflow.FieldDescription:
		m.ResetDescription()
		return nil
	case notifyflow.FieldStatus:
		m.ResetStatus()
		return nil
	case notifyflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifyflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyFlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, notifyflow.EdgeOwner)
	}
	if m.notify_target != nil {
		edges = append(edges, notifyflow.EdgeNotifyTarget)
	}
	if m.notify_source != nil {
		edges = append(edges, notifyflow.EdgeNotifySource)
	}
	if m.notify_flow_target != nil {
		edges = append(edges, notifyflow.EdgeNotifyFlowTarget)
	}
	if m.notify_flow_source != nil {
		edges = append(edges, notifyflow.EdgeNotifyFlowSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyFlowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifyflow.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case notifyflow.EdgeNotifyTarget:
		ids := make([]ent.Value, 0, len(m.notify_target))
		for id := range m.notify_target {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.notify_source))
		for id := range m.notify_source {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifyFlowTarget:
		ids := make([]ent.Value, 0, len(m.notify_flow_target))
		for id := range m.notify_flow_target {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifyFlowSource:
		ids := make([]ent.Value, 0, len(m.notify_flow_source))
		for id := range m.notify_flow_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyFlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removednotify_target != nil {
		edges = append(edges, notifyflow.EdgeNotifyTarget)
	}
	if m.removednotify_source != nil {
		edges = append(edges, notifyflow.EdgeNotifySource)
	}
	if m.removednotify_flow_target != nil {
		edges = append(edges, notifyflow.EdgeNotifyFlowTarget)
	}
	if m.removednotify_flow_source != nil {
		edges = append(edges, notifyflow.EdgeNotifyFlowSource)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyFlowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notifyflow.EdgeNotifyTarget:
		ids := make([]ent.Value, 0, len(m.removednotify_target))
		for id := range m.removednotify_target {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.removednotify_source))
		for id := range m.removednotify_source {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifyFlowTarget:
		ids := make([]ent.Value, 0, len(m.removednotify_flow_target))
		for id := range m.removednotify_flow_target {
			ids = append(ids, id)
		}
		return ids
	case notifyflow.EdgeNotifyFlowSource:
		ids := make([]ent.Value, 0, len(m.removednotify_flow_source))
		for id := range m.removednotify_flow_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyFlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, notifyflow.EdgeOwner)
	}
	if m.clearednotify_target {
		edges = append(edges, notifyflow.EdgeNotifyTarget)
	}
	if m.clearednotify_source {
		edges = append(edges, notifyflow.EdgeNotifySource)
	}
	if m.clearednotify_flow_target {
		edges = append(edges, notifyflow.EdgeNotifyFlowTarget)
	}
	if m.clearednotify_flow_source {
		edges = append(edges, notifyflow.EdgeNotifyFlowSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyFlowMutation) EdgeCleared(name string) bool {
	switch name {
	case notifyflow.EdgeOwner:
		return m.clearedowner
	case notifyflow.EdgeNotifyTarget:
		return m.clearednotify_target
	case notifyflow.EdgeNotifySource:
		return m.clearednotify_source
	case notifyflow.EdgeNotifyFlowTarget:
		return m.clearednotify_flow_target
	case notifyflow.EdgeNotifyFlowSource:
		return m.clearednotify_flow_source
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyFlowMutation) ClearEdge(name string) error {
	switch name {
	case notifyflow.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyFlowMutation) ResetEdge(name string) error {
	switch name {
	case notifyflow.EdgeOwner:
		m.ResetOwner()
		return nil
	case notifyflow.EdgeNotifyTarget:
		m.ResetNotifyTarget()
		return nil
	case notifyflow.EdgeNotifySource:
		m.ResetNotifySource()
		return nil
	case notifyflow.EdgeNotifyFlowTarget:
		m.ResetNotifyFlowTarget()
		return nil
	case notifyflow.EdgeNotifyFlowSource:
		m.ResetNotifyFlowSource()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlow edge %s", name)
}

// NotifyFlowSourceMutation represents an operation that mutates the NotifyFlowSource nodes in the graph.
type NotifyFlowSourceMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	filter_include_keywords       *[]string
	appendfilter_include_keywords []string
	filter_exclude_keywords       *[]string
	appendfilter_exclude_keywords []string
	updated_at                    *time.Time
	created_at                    *time.Time
	clearedFields                 map[string]struct{}
	notify_flow                   *model.InternalID
	clearednotify_flow            bool
	notify_source                 *model.InternalID
	clearednotify_source          bool
	done                          bool
	oldValue                      func(context.Context) (*NotifyFlowSource, error)
	predicates                    []predicate.NotifyFlowSource
}

var _ ent.Mutation = (*NotifyFlowSourceMutation)(nil)

// notifyflowsourceOption allows management of the mutation configuration using functional options.
type notifyflowsourceOption func(*NotifyFlowSourceMutation)

// newNotifyFlowSourceMutation creates new mutation for the NotifyFlowSource entity.
func newNotifyFlowSourceMutation(c config, op Op, opts ...notifyflowsourceOption) *NotifyFlowSourceMutation {
	m := &NotifyFlowSourceMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyFlowSource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyFlowSourceID sets the ID field of the mutation.
func withNotifyFlowSourceID(id int) notifyflowsourceOption {
	return func(m *NotifyFlowSourceMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyFlowSource
		)
		m.oldValue = func(ctx context.Context) (*NotifyFlowSource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyFlowSource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyFlowSource sets the old NotifyFlowSource of the mutation.
func withNotifyFlowSource(node *NotifyFlowSource) notifyflowsourceOption {
	return func(m *NotifyFlowSourceMutation) {
		m.oldValue = func(context.Context) (*NotifyFlowSource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyFlowSourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyFlowSourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyFlowSourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyFlowSourceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyFlowSource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNotifyFlowID sets the "notify_flow_id" field.
func (m *NotifyFlowSourceMutation) SetNotifyFlowID(mi model.InternalID) {
	m.notify_flow = &mi
}

// NotifyFlowID returns the value of the "notify_flow_id" field in the mutation.
func (m *NotifyFlowSourceMutation) NotifyFlowID() (r model.InternalID, exists bool) {
	v := m.notify_flow
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyFlowID returns the old "notify_flow_id" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldNotifyFlowID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyFlowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyFlowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyFlowID: %w", err)
	}
	return oldValue.NotifyFlowID, nil
}

// ResetNotifyFlowID resets all changes to the "notify_flow_id" field.
func (m *NotifyFlowSourceMutation) ResetNotifyFlowID() {
	m.notify_flow = nil
}

// SetNotifySourceID sets the "notify_source_id" field.
func (m *NotifyFlowSourceMutation) SetNotifySourceID(mi model.InternalID) {
	m.notify_source = &mi
}

// NotifySourceID returns the value of the "notify_source_id" field in the mutation.
func (m *NotifyFlowSourceMutation) NotifySourceID() (r model.InternalID, exists bool) {
	v := m.notify_source
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifySourceID returns the old "notify_source_id" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldNotifySourceID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifySourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifySourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifySourceID: %w", err)
	}
	return oldValue.NotifySourceID, nil
}

// ResetNotifySourceID resets all changes to the "notify_source_id" field.
func (m *NotifyFlowSourceMutation) ResetNotifySourceID() {
	m.notify_source = nil
}

// SetFilterIncludeKeywords sets the "filter_include_keywords" field.
func (m *NotifyFlowSourceMutation) SetFilterIncludeKeywords(s []string) {
	m.filter_include_keywords = &s
	m.appendfilter_include_keywords = nil
}

// FilterIncludeKeywords returns the value of the "filter_include_keywords" field in the mutation.
func (m *NotifyFlowSourceMutation) FilterIncludeKeywords() (r []string, exists bool) {
	v := m.filter_include_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterIncludeKeywords returns the old "filter_include_keywords" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldFilterIncludeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterIncludeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterIncludeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterIncludeKeywords: %w", err)
	}
	return oldValue.FilterIncludeKeywords, nil
}

// AppendFilterIncludeKeywords adds s to the "filter_include_keywords" field.
func (m *NotifyFlowSourceMutation) AppendFilterIncludeKeywords(s []string) {
	m.appendfilter_include_keywords = append(m.appendfilter_include_keywords, s...)
}

// AppendedFilterIncludeKeywords returns the list of values that were appended to the "filter_include_keywords" field in this mutation.
func (m *NotifyFlowSourceMutation) AppendedFilterIncludeKeywords() ([]string, bool) {
	if len(m.appendfilter_include_keywords) == 0 {
		return nil, false
	}
	return m.appendfilter_include_keywords, true
}

// ResetFilterIncludeKeywords resets all changes to the "filter_include_keywords" field.
func (m *NotifyFlowSourceMutation) ResetFilterIncludeKeywords() {
	m.filter_include_keywords = nil
	m.appendfilter_include_keywords = nil
}

// SetFilterExcludeKeywords sets the "filter_exclude_keywords" field.
func (m *NotifyFlowSourceMutation) SetFilterExcludeKeywords(s []string) {
	m.filter_exclude_keywords = &s
	m.appendfilter_exclude_keywords = nil
}

// FilterExcludeKeywords returns the value of the "filter_exclude_keywords" field in the mutation.
func (m *NotifyFlowSourceMutation) FilterExcludeKeywords() (r []string, exists bool) {
	v := m.filter_exclude_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterExcludeKeywords returns the old "filter_exclude_keywords" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldFilterExcludeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterExcludeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterExcludeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterExcludeKeywords: %w", err)
	}
	return oldValue.FilterExcludeKeywords, nil
}

// AppendFilterExcludeKeywords adds s to the "filter_exclude_keywords" field.
func (m *NotifyFlowSourceMutation) AppendFilterExcludeKeywords(s []string) {
	m.appendfilter_exclude_keywords = append(m.appendfilter_exclude_keywords, s...)
}

// AppendedFilterExcludeKeywords returns the list of values that were appended to the "filter_exclude_keywords" field in this mutation.
func (m *NotifyFlowSourceMutation) AppendedFilterExcludeKeywords() ([]string, bool) {
	if len(m.appendfilter_exclude_keywords) == 0 {
		return nil, false
	}
	return m.appendfilter_exclude_keywords, true
}

// ResetFilterExcludeKeywords resets all changes to the "filter_exclude_keywords" field.
func (m *NotifyFlowSourceMutation) ResetFilterExcludeKeywords() {
	m.filter_exclude_keywords = nil
	m.appendfilter_exclude_keywords = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyFlowSourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyFlowSourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyFlowSourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyFlowSourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyFlowSourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyFlowSource entity.
// If the NotifyFlowSource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowSourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyFlowSourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifyFlowSourceMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
	m.clearedFields[notifyflowsource.FieldNotifyFlowID] = struct{}{}
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *NotifyFlowSourceMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotifyFlowID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowSourceMutation) NotifyFlowIDs() (ids []model.InternalID) {
	if id := m.notify_flow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *NotifyFlowSourceMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
}

// ClearNotifySource clears the "notify_source" edge to the NotifySource entity.
func (m *NotifyFlowSourceMutation) ClearNotifySource() {
	m.clearednotify_source = true
	m.clearedFields[notifyflowsource.FieldNotifySourceID] = struct{}{}
}

// NotifySourceCleared reports if the "notify_source" edge to the NotifySource entity was cleared.
func (m *NotifyFlowSourceMutation) NotifySourceCleared() bool {
	return m.clearednotify_source
}

// NotifySourceIDs returns the "notify_source" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotifySourceID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowSourceMutation) NotifySourceIDs() (ids []model.InternalID) {
	if id := m.notify_source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotifySource resets all changes to the "notify_source" edge.
func (m *NotifyFlowSourceMutation) ResetNotifySource() {
	m.notify_source = nil
	m.clearednotify_source = false
}

// Where appends a list predicates to the NotifyFlowSourceMutation builder.
func (m *NotifyFlowSourceMutation) Where(ps ...predicate.NotifyFlowSource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyFlowSourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyFlowSourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyFlowSource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyFlowSourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyFlowSourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyFlowSource).
func (m *NotifyFlowSourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyFlowSourceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.notify_flow != nil {
		fields = append(fields, notifyflowsource.FieldNotifyFlowID)
	}
	if m.notify_source != nil {
		fields = append(fields, notifyflowsource.FieldNotifySourceID)
	}
	if m.filter_include_keywords != nil {
		fields = append(fields, notifyflowsource.FieldFilterIncludeKeywords)
	}
	if m.filter_exclude_keywords != nil {
		fields = append(fields, notifyflowsource.FieldFilterExcludeKeywords)
	}
	if m.updated_at != nil {
		fields = append(fields, notifyflowsource.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifyflowsource.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyFlowSourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifyflowsource.FieldNotifyFlowID:
		return m.NotifyFlowID()
	case notifyflowsource.FieldNotifySourceID:
		return m.NotifySourceID()
	case notifyflowsource.FieldFilterIncludeKeywords:
		return m.FilterIncludeKeywords()
	case notifyflowsource.FieldFilterExcludeKeywords:
		return m.FilterExcludeKeywords()
	case notifyflowsource.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifyflowsource.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyFlowSourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifyflowsource.FieldNotifyFlowID:
		return m.OldNotifyFlowID(ctx)
	case notifyflowsource.FieldNotifySourceID:
		return m.OldNotifySourceID(ctx)
	case notifyflowsource.FieldFilterIncludeKeywords:
		return m.OldFilterIncludeKeywords(ctx)
	case notifyflowsource.FieldFilterExcludeKeywords:
		return m.OldFilterExcludeKeywords(ctx)
	case notifyflowsource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifyflowsource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyFlowSource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowSourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifyflowsource.FieldNotifyFlowID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyFlowID(v)
		return nil
	case notifyflowsource.FieldNotifySourceID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifySourceID(v)
		return nil
	case notifyflowsource.FieldFilterIncludeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterIncludeKeywords(v)
		return nil
	case notifyflowsource.FieldFilterExcludeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterExcludeKeywords(v)
		return nil
	case notifyflowsource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifyflowsource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowSource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyFlowSourceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyFlowSourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowSourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifyFlowSource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyFlowSourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyFlowSourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyFlowSourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotifyFlowSource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyFlowSourceMutation) ResetField(name string) error {
	switch name {
	case notifyflowsource.FieldNotifyFlowID:
		m.ResetNotifyFlowID()
		return nil
	case notifyflowsource.FieldNotifySourceID:
		m.ResetNotifySourceID()
		return nil
	case notifyflowsource.FieldFilterIncludeKeywords:
		m.ResetFilterIncludeKeywords()
		return nil
	case notifyflowsource.FieldFilterExcludeKeywords:
		m.ResetFilterExcludeKeywords()
		return nil
	case notifyflowsource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifyflowsource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowSource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyFlowSourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.notify_flow != nil {
		edges = append(edges, notifyflowsource.EdgeNotifyFlow)
	}
	if m.notify_source != nil {
		edges = append(edges, notifyflowsource.EdgeNotifySource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyFlowSourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifyflowsource.EdgeNotifyFlow:
		if id := m.notify_flow; id != nil {
			return []ent.Value{*id}
		}
	case notifyflowsource.EdgeNotifySource:
		if id := m.notify_source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyFlowSourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyFlowSourceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyFlowSourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednotify_flow {
		edges = append(edges, notifyflowsource.EdgeNotifyFlow)
	}
	if m.clearednotify_source {
		edges = append(edges, notifyflowsource.EdgeNotifySource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyFlowSourceMutation) EdgeCleared(name string) bool {
	switch name {
	case notifyflowsource.EdgeNotifyFlow:
		return m.clearednotify_flow
	case notifyflowsource.EdgeNotifySource:
		return m.clearednotify_source
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyFlowSourceMutation) ClearEdge(name string) error {
	switch name {
	case notifyflowsource.EdgeNotifyFlow:
		m.ClearNotifyFlow()
		return nil
	case notifyflowsource.EdgeNotifySource:
		m.ClearNotifySource()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowSource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyFlowSourceMutation) ResetEdge(name string) error {
	switch name {
	case notifyflowsource.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case notifyflowsource.EdgeNotifySource:
		m.ResetNotifySource()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowSource edge %s", name)
}

// NotifyFlowTargetMutation represents an operation that mutates the NotifyFlowTarget nodes in the graph.
type NotifyFlowTargetMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	filter_include_keywords       *[]string
	appendfilter_include_keywords []string
	filter_exclude_keywords       *[]string
	appendfilter_exclude_keywords []string
	updated_at                    *time.Time
	created_at                    *time.Time
	clearedFields                 map[string]struct{}
	notify_flow                   *model.InternalID
	clearednotify_flow            bool
	notify_target                 *model.InternalID
	clearednotify_target          bool
	done                          bool
	oldValue                      func(context.Context) (*NotifyFlowTarget, error)
	predicates                    []predicate.NotifyFlowTarget
}

var _ ent.Mutation = (*NotifyFlowTargetMutation)(nil)

// notifyflowtargetOption allows management of the mutation configuration using functional options.
type notifyflowtargetOption func(*NotifyFlowTargetMutation)

// newNotifyFlowTargetMutation creates new mutation for the NotifyFlowTarget entity.
func newNotifyFlowTargetMutation(c config, op Op, opts ...notifyflowtargetOption) *NotifyFlowTargetMutation {
	m := &NotifyFlowTargetMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyFlowTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyFlowTargetID sets the ID field of the mutation.
func withNotifyFlowTargetID(id int) notifyflowtargetOption {
	return func(m *NotifyFlowTargetMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyFlowTarget
		)
		m.oldValue = func(ctx context.Context) (*NotifyFlowTarget, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyFlowTarget.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyFlowTarget sets the old NotifyFlowTarget of the mutation.
func withNotifyFlowTarget(node *NotifyFlowTarget) notifyflowtargetOption {
	return func(m *NotifyFlowTargetMutation) {
		m.oldValue = func(context.Context) (*NotifyFlowTarget, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyFlowTargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyFlowTargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyFlowTargetMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyFlowTargetMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyFlowTarget.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNotifyFlowID sets the "notify_flow_id" field.
func (m *NotifyFlowTargetMutation) SetNotifyFlowID(mi model.InternalID) {
	m.notify_flow = &mi
}

// NotifyFlowID returns the value of the "notify_flow_id" field in the mutation.
func (m *NotifyFlowTargetMutation) NotifyFlowID() (r model.InternalID, exists bool) {
	v := m.notify_flow
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyFlowID returns the old "notify_flow_id" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldNotifyFlowID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyFlowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyFlowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyFlowID: %w", err)
	}
	return oldValue.NotifyFlowID, nil
}

// ResetNotifyFlowID resets all changes to the "notify_flow_id" field.
func (m *NotifyFlowTargetMutation) ResetNotifyFlowID() {
	m.notify_flow = nil
}

// SetNotifyTargetID sets the "notify_target_id" field.
func (m *NotifyFlowTargetMutation) SetNotifyTargetID(mi model.InternalID) {
	m.notify_target = &mi
}

// NotifyTargetID returns the value of the "notify_target_id" field in the mutation.
func (m *NotifyFlowTargetMutation) NotifyTargetID() (r model.InternalID, exists bool) {
	v := m.notify_target
	if v == nil {
		return
	}
	return *v, true
}

// OldNotifyTargetID returns the old "notify_target_id" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldNotifyTargetID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotifyTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotifyTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotifyTargetID: %w", err)
	}
	return oldValue.NotifyTargetID, nil
}

// ResetNotifyTargetID resets all changes to the "notify_target_id" field.
func (m *NotifyFlowTargetMutation) ResetNotifyTargetID() {
	m.notify_target = nil
}

// SetFilterIncludeKeywords sets the "filter_include_keywords" field.
func (m *NotifyFlowTargetMutation) SetFilterIncludeKeywords(s []string) {
	m.filter_include_keywords = &s
	m.appendfilter_include_keywords = nil
}

// FilterIncludeKeywords returns the value of the "filter_include_keywords" field in the mutation.
func (m *NotifyFlowTargetMutation) FilterIncludeKeywords() (r []string, exists bool) {
	v := m.filter_include_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterIncludeKeywords returns the old "filter_include_keywords" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldFilterIncludeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterIncludeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterIncludeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterIncludeKeywords: %w", err)
	}
	return oldValue.FilterIncludeKeywords, nil
}

// AppendFilterIncludeKeywords adds s to the "filter_include_keywords" field.
func (m *NotifyFlowTargetMutation) AppendFilterIncludeKeywords(s []string) {
	m.appendfilter_include_keywords = append(m.appendfilter_include_keywords, s...)
}

// AppendedFilterIncludeKeywords returns the list of values that were appended to the "filter_include_keywords" field in this mutation.
func (m *NotifyFlowTargetMutation) AppendedFilterIncludeKeywords() ([]string, bool) {
	if len(m.appendfilter_include_keywords) == 0 {
		return nil, false
	}
	return m.appendfilter_include_keywords, true
}

// ResetFilterIncludeKeywords resets all changes to the "filter_include_keywords" field.
func (m *NotifyFlowTargetMutation) ResetFilterIncludeKeywords() {
	m.filter_include_keywords = nil
	m.appendfilter_include_keywords = nil
}

// SetFilterExcludeKeywords sets the "filter_exclude_keywords" field.
func (m *NotifyFlowTargetMutation) SetFilterExcludeKeywords(s []string) {
	m.filter_exclude_keywords = &s
	m.appendfilter_exclude_keywords = nil
}

// FilterExcludeKeywords returns the value of the "filter_exclude_keywords" field in the mutation.
func (m *NotifyFlowTargetMutation) FilterExcludeKeywords() (r []string, exists bool) {
	v := m.filter_exclude_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterExcludeKeywords returns the old "filter_exclude_keywords" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldFilterExcludeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterExcludeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterExcludeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterExcludeKeywords: %w", err)
	}
	return oldValue.FilterExcludeKeywords, nil
}

// AppendFilterExcludeKeywords adds s to the "filter_exclude_keywords" field.
func (m *NotifyFlowTargetMutation) AppendFilterExcludeKeywords(s []string) {
	m.appendfilter_exclude_keywords = append(m.appendfilter_exclude_keywords, s...)
}

// AppendedFilterExcludeKeywords returns the list of values that were appended to the "filter_exclude_keywords" field in this mutation.
func (m *NotifyFlowTargetMutation) AppendedFilterExcludeKeywords() ([]string, bool) {
	if len(m.appendfilter_exclude_keywords) == 0 {
		return nil, false
	}
	return m.appendfilter_exclude_keywords, true
}

// ResetFilterExcludeKeywords resets all changes to the "filter_exclude_keywords" field.
func (m *NotifyFlowTargetMutation) ResetFilterExcludeKeywords() {
	m.filter_exclude_keywords = nil
	m.appendfilter_exclude_keywords = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyFlowTargetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyFlowTargetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyFlowTargetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyFlowTargetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyFlowTargetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyFlowTarget entity.
// If the NotifyFlowTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyFlowTargetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyFlowTargetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifyFlowTargetMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
	m.clearedFields[notifyflowtarget.FieldNotifyFlowID] = struct{}{}
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *NotifyFlowTargetMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotifyFlowID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowTargetMutation) NotifyFlowIDs() (ids []model.InternalID) {
	if id := m.notify_flow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *NotifyFlowTargetMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
}

// ClearNotifyTarget clears the "notify_target" edge to the NotifyTarget entity.
func (m *NotifyFlowTargetMutation) ClearNotifyTarget() {
	m.clearednotify_target = true
	m.clearedFields[notifyflowtarget.FieldNotifyTargetID] = struct{}{}
}

// NotifyTargetCleared reports if the "notify_target" edge to the NotifyTarget entity was cleared.
func (m *NotifyFlowTargetMutation) NotifyTargetCleared() bool {
	return m.clearednotify_target
}

// NotifyTargetIDs returns the "notify_target" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NotifyTargetID instead. It exists only for internal usage by the builders.
func (m *NotifyFlowTargetMutation) NotifyTargetIDs() (ids []model.InternalID) {
	if id := m.notify_target; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNotifyTarget resets all changes to the "notify_target" edge.
func (m *NotifyFlowTargetMutation) ResetNotifyTarget() {
	m.notify_target = nil
	m.clearednotify_target = false
}

// Where appends a list predicates to the NotifyFlowTargetMutation builder.
func (m *NotifyFlowTargetMutation) Where(ps ...predicate.NotifyFlowTarget) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyFlowTargetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyFlowTargetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyFlowTarget, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyFlowTargetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyFlowTargetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyFlowTarget).
func (m *NotifyFlowTargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyFlowTargetMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.notify_flow != nil {
		fields = append(fields, notifyflowtarget.FieldNotifyFlowID)
	}
	if m.notify_target != nil {
		fields = append(fields, notifyflowtarget.FieldNotifyTargetID)
	}
	if m.filter_include_keywords != nil {
		fields = append(fields, notifyflowtarget.FieldFilterIncludeKeywords)
	}
	if m.filter_exclude_keywords != nil {
		fields = append(fields, notifyflowtarget.FieldFilterExcludeKeywords)
	}
	if m.updated_at != nil {
		fields = append(fields, notifyflowtarget.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifyflowtarget.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyFlowTargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifyflowtarget.FieldNotifyFlowID:
		return m.NotifyFlowID()
	case notifyflowtarget.FieldNotifyTargetID:
		return m.NotifyTargetID()
	case notifyflowtarget.FieldFilterIncludeKeywords:
		return m.FilterIncludeKeywords()
	case notifyflowtarget.FieldFilterExcludeKeywords:
		return m.FilterExcludeKeywords()
	case notifyflowtarget.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifyflowtarget.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyFlowTargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifyflowtarget.FieldNotifyFlowID:
		return m.OldNotifyFlowID(ctx)
	case notifyflowtarget.FieldNotifyTargetID:
		return m.OldNotifyTargetID(ctx)
	case notifyflowtarget.FieldFilterIncludeKeywords:
		return m.OldFilterIncludeKeywords(ctx)
	case notifyflowtarget.FieldFilterExcludeKeywords:
		return m.OldFilterExcludeKeywords(ctx)
	case notifyflowtarget.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifyflowtarget.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyFlowTarget field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowTargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifyflowtarget.FieldNotifyFlowID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyFlowID(v)
		return nil
	case notifyflowtarget.FieldNotifyTargetID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotifyTargetID(v)
		return nil
	case notifyflowtarget.FieldFilterIncludeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterIncludeKeywords(v)
		return nil
	case notifyflowtarget.FieldFilterExcludeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterExcludeKeywords(v)
		return nil
	case notifyflowtarget.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifyflowtarget.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowTarget field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyFlowTargetMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyFlowTargetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyFlowTargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifyFlowTarget numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyFlowTargetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyFlowTargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyFlowTargetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotifyFlowTarget nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyFlowTargetMutation) ResetField(name string) error {
	switch name {
	case notifyflowtarget.FieldNotifyFlowID:
		m.ResetNotifyFlowID()
		return nil
	case notifyflowtarget.FieldNotifyTargetID:
		m.ResetNotifyTargetID()
		return nil
	case notifyflowtarget.FieldFilterIncludeKeywords:
		m.ResetFilterIncludeKeywords()
		return nil
	case notifyflowtarget.FieldFilterExcludeKeywords:
		m.ResetFilterExcludeKeywords()
		return nil
	case notifyflowtarget.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifyflowtarget.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowTarget field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyFlowTargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.notify_flow != nil {
		edges = append(edges, notifyflowtarget.EdgeNotifyFlow)
	}
	if m.notify_target != nil {
		edges = append(edges, notifyflowtarget.EdgeNotifyTarget)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyFlowTargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifyflowtarget.EdgeNotifyFlow:
		if id := m.notify_flow; id != nil {
			return []ent.Value{*id}
		}
	case notifyflowtarget.EdgeNotifyTarget:
		if id := m.notify_target; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyFlowTargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyFlowTargetMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyFlowTargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednotify_flow {
		edges = append(edges, notifyflowtarget.EdgeNotifyFlow)
	}
	if m.clearednotify_target {
		edges = append(edges, notifyflowtarget.EdgeNotifyTarget)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyFlowTargetMutation) EdgeCleared(name string) bool {
	switch name {
	case notifyflowtarget.EdgeNotifyFlow:
		return m.clearednotify_flow
	case notifyflowtarget.EdgeNotifyTarget:
		return m.clearednotify_target
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyFlowTargetMutation) ClearEdge(name string) error {
	switch name {
	case notifyflowtarget.EdgeNotifyFlow:
		m.ClearNotifyFlow()
		return nil
	case notifyflowtarget.EdgeNotifyTarget:
		m.ClearNotifyTarget()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowTarget unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyFlowTargetMutation) ResetEdge(name string) error {
	switch name {
	case notifyflowtarget.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case notifyflowtarget.EdgeNotifyTarget:
		m.ResetNotifyTarget()
		return nil
	}
	return fmt.Errorf("unknown NotifyFlowTarget edge %s", name)
}

// NotifySourceMutation represents an operation that mutates the NotifySource nodes in the graph.
type NotifySourceMutation struct {
	config
	op                          Op
	typ                         string
	id                          *model.InternalID
	updated_at                  *time.Time
	created_at                  *time.Time
	clearedFields               map[string]struct{}
	owner                       *model.InternalID
	clearedowner                bool
	notify_flow                 map[model.InternalID]struct{}
	removednotify_flow          map[model.InternalID]struct{}
	clearednotify_flow          bool
	feed_config                 *model.InternalID
	clearedfeed_config          bool
	feed_item_collection        *model.InternalID
	clearedfeed_item_collection bool
	notify_flow_source          map[int]struct{}
	removednotify_flow_source   map[int]struct{}
	clearednotify_flow_source   bool
	done                        bool
	oldValue                    func(context.Context) (*NotifySource, error)
	predicates                  []predicate.NotifySource
}

var _ ent.Mutation = (*NotifySourceMutation)(nil)

// notifysourceOption allows management of the mutation configuration using functional options.
type notifysourceOption func(*NotifySourceMutation)

// newNotifySourceMutation creates new mutation for the NotifySource entity.
func newNotifySourceMutation(c config, op Op, opts ...notifysourceOption) *NotifySourceMutation {
	m := &NotifySourceMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifySource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifySourceID sets the ID field of the mutation.
func withNotifySourceID(id model.InternalID) notifysourceOption {
	return func(m *NotifySourceMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifySource
		)
		m.oldValue = func(ctx context.Context) (*NotifySource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifySource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifySource sets the old NotifySource of the mutation.
func withNotifySource(node *NotifySource) notifysourceOption {
	return func(m *NotifySourceMutation) {
		m.oldValue = func(context.Context) (*NotifySource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifySourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifySourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotifySource entities.
func (m *NotifySourceMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifySourceMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifySourceMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifySource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFeedConfigID sets the "feed_config_id" field.
func (m *NotifySourceMutation) SetFeedConfigID(mi model.InternalID) {
	m.feed_config = &mi
}

// FeedConfigID returns the value of the "feed_config_id" field in the mutation.
func (m *NotifySourceMutation) FeedConfigID() (r model.InternalID, exists bool) {
	v := m.feed_config
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedConfigID returns the old "feed_config_id" field's value of the NotifySource entity.
// If the NotifySource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifySourceMutation) OldFeedConfigID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedConfigID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedConfigID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedConfigID: %w", err)
	}
	return oldValue.FeedConfigID, nil
}

// ClearFeedConfigID clears the value of the "feed_config_id" field.
func (m *NotifySourceMutation) ClearFeedConfigID() {
	m.feed_config = nil
	m.clearedFields[notifysource.FieldFeedConfigID] = struct{}{}
}

// FeedConfigIDCleared returns if the "feed_config_id" field was cleared in this mutation.
func (m *NotifySourceMutation) FeedConfigIDCleared() bool {
	_, ok := m.clearedFields[notifysource.FieldFeedConfigID]
	return ok
}

// ResetFeedConfigID resets all changes to the "feed_config_id" field.
func (m *NotifySourceMutation) ResetFeedConfigID() {
	m.feed_config = nil
	delete(m.clearedFields, notifysource.FieldFeedConfigID)
}

// SetFeedItemCollectionID sets the "feed_item_collection_id" field.
func (m *NotifySourceMutation) SetFeedItemCollectionID(mi model.InternalID) {
	m.feed_item_collection = &mi
}

// FeedItemCollectionID returns the value of the "feed_item_collection_id" field in the mutation.
func (m *NotifySourceMutation) FeedItemCollectionID() (r model.InternalID, exists bool) {
	v := m.feed_item_collection
	if v == nil {
		return
	}
	return *v, true
}

// OldFeedItemCollectionID returns the old "feed_item_collection_id" field's value of the NotifySource entity.
// If the NotifySource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifySourceMutation) OldFeedItemCollectionID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeedItemCollectionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeedItemCollectionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeedItemCollectionID: %w", err)
	}
	return oldValue.FeedItemCollectionID, nil
}

// ClearFeedItemCollectionID clears the value of the "feed_item_collection_id" field.
func (m *NotifySourceMutation) ClearFeedItemCollectionID() {
	m.feed_item_collection = nil
	m.clearedFields[notifysource.FieldFeedItemCollectionID] = struct{}{}
}

// FeedItemCollectionIDCleared returns if the "feed_item_collection_id" field was cleared in this mutation.
func (m *NotifySourceMutation) FeedItemCollectionIDCleared() bool {
	_, ok := m.clearedFields[notifysource.FieldFeedItemCollectionID]
	return ok
}

// ResetFeedItemCollectionID resets all changes to the "feed_item_collection_id" field.
func (m *NotifySourceMutation) ResetFeedItemCollectionID() {
	m.feed_item_collection = nil
	delete(m.clearedFields, notifysource.FieldFeedItemCollectionID)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifySourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifySourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifySource entity.
// If the NotifySource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifySourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifySourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifySourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifySourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifySource entity.
// If the NotifySource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifySourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifySourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *NotifySourceMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *NotifySourceMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *NotifySourceMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NotifySourceMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NotifySourceMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NotifySourceMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddNotifyFlowIDs adds the "notify_flow" edge to the NotifyFlow entity by ids.
func (m *NotifySourceMutation) AddNotifyFlowIDs(ids ...model.InternalID) {
	if m.notify_flow == nil {
		m.notify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_flow[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifySourceMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *NotifySourceMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// RemoveNotifyFlowIDs removes the "notify_flow" edge to the NotifyFlow entity by IDs.
func (m *NotifySourceMutation) RemoveNotifyFlowIDs(ids ...model.InternalID) {
	if m.removednotify_flow == nil {
		m.removednotify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_flow, ids[i])
		m.removednotify_flow[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlow returns the removed IDs of the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifySourceMutation) RemovedNotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.removednotify_flow {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
func (m *NotifySourceMutation) NotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.notify_flow {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *NotifySourceMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
	m.removednotify_flow = nil
}

// ClearFeedConfig clears the "feed_config" edge to the FeedConfig entity.
func (m *NotifySourceMutation) ClearFeedConfig() {
	m.clearedfeed_config = true
	m.clearedFields[notifysource.FieldFeedConfigID] = struct{}{}
}

// FeedConfigCleared reports if the "feed_config" edge to the FeedConfig entity was cleared.
func (m *NotifySourceMutation) FeedConfigCleared() bool {
	return m.FeedConfigIDCleared() || m.clearedfeed_config
}

// FeedConfigIDs returns the "feed_config" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedConfigID instead. It exists only for internal usage by the builders.
func (m *NotifySourceMutation) FeedConfigIDs() (ids []model.InternalID) {
	if id := m.feed_config; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeedConfig resets all changes to the "feed_config" edge.
func (m *NotifySourceMutation) ResetFeedConfig() {
	m.feed_config = nil
	m.clearedfeed_config = false
}

// ClearFeedItemCollection clears the "feed_item_collection" edge to the FeedItemCollection entity.
func (m *NotifySourceMutation) ClearFeedItemCollection() {
	m.clearedfeed_item_collection = true
	m.clearedFields[notifysource.FieldFeedItemCollectionID] = struct{}{}
}

// FeedItemCollectionCleared reports if the "feed_item_collection" edge to the FeedItemCollection entity was cleared.
func (m *NotifySourceMutation) FeedItemCollectionCleared() bool {
	return m.FeedItemCollectionIDCleared() || m.clearedfeed_item_collection
}

// FeedItemCollectionIDs returns the "feed_item_collection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeedItemCollectionID instead. It exists only for internal usage by the builders.
func (m *NotifySourceMutation) FeedItemCollectionIDs() (ids []model.InternalID) {
	if id := m.feed_item_collection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeedItemCollection resets all changes to the "feed_item_collection" edge.
func (m *NotifySourceMutation) ResetFeedItemCollection() {
	m.feed_item_collection = nil
	m.clearedfeed_item_collection = false
}

// AddNotifyFlowSourceIDs adds the "notify_flow_source" edge to the NotifyFlowSource entity by ids.
func (m *NotifySourceMutation) AddNotifyFlowSourceIDs(ids ...int) {
	if m.notify_flow_source == nil {
		m.notify_flow_source = make(map[int]struct{})
	}
	for i := range ids {
		m.notify_flow_source[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlowSource clears the "notify_flow_source" edge to the NotifyFlowSource entity.
func (m *NotifySourceMutation) ClearNotifyFlowSource() {
	m.clearednotify_flow_source = true
}

// NotifyFlowSourceCleared reports if the "notify_flow_source" edge to the NotifyFlowSource entity was cleared.
func (m *NotifySourceMutation) NotifyFlowSourceCleared() bool {
	return m.clearednotify_flow_source
}

// RemoveNotifyFlowSourceIDs removes the "notify_flow_source" edge to the NotifyFlowSource entity by IDs.
func (m *NotifySourceMutation) RemoveNotifyFlowSourceIDs(ids ...int) {
	if m.removednotify_flow_source == nil {
		m.removednotify_flow_source = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notify_flow_source, ids[i])
		m.removednotify_flow_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlowSource returns the removed IDs of the "notify_flow_source" edge to the NotifyFlowSource entity.
func (m *NotifySourceMutation) RemovedNotifyFlowSourceIDs() (ids []int) {
	for id := range m.removednotify_flow_source {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowSourceIDs returns the "notify_flow_source" edge IDs in the mutation.
func (m *NotifySourceMutation) NotifyFlowSourceIDs() (ids []int) {
	for id := range m.notify_flow_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlowSource resets all changes to the "notify_flow_source" edge.
func (m *NotifySourceMutation) ResetNotifyFlowSource() {
	m.notify_flow_source = nil
	m.clearednotify_flow_source = false
	m.removednotify_flow_source = nil
}

// Where appends a list predicates to the NotifySourceMutation builder.
func (m *NotifySourceMutation) Where(ps ...predicate.NotifySource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifySourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifySourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifySource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifySourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifySourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifySource).
func (m *NotifySourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifySourceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.feed_config != nil {
		fields = append(fields, notifysource.FieldFeedConfigID)
	}
	if m.feed_item_collection != nil {
		fields = append(fields, notifysource.FieldFeedItemCollectionID)
	}
	if m.updated_at != nil {
		fields = append(fields, notifysource.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifysource.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifySourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifysource.FieldFeedConfigID:
		return m.FeedConfigID()
	case notifysource.FieldFeedItemCollectionID:
		return m.FeedItemCollectionID()
	case notifysource.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifysource.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifySourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifysource.FieldFeedConfigID:
		return m.OldFeedConfigID(ctx)
	case notifysource.FieldFeedItemCollectionID:
		return m.OldFeedItemCollectionID(ctx)
	case notifysource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifysource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifySource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifySourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifysource.FieldFeedConfigID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedConfigID(v)
		return nil
	case notifysource.FieldFeedItemCollectionID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeedItemCollectionID(v)
		return nil
	case notifysource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifysource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifySource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifySourceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifySourceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifySourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifySource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifySourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notifysource.FieldFeedConfigID) {
		fields = append(fields, notifysource.FieldFeedConfigID)
	}
	if m.FieldCleared(notifysource.FieldFeedItemCollectionID) {
		fields = append(fields, notifysource.FieldFeedItemCollectionID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifySourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifySourceMutation) ClearField(name string) error {
	switch name {
	case notifysource.FieldFeedConfigID:
		m.ClearFeedConfigID()
		return nil
	case notifysource.FieldFeedItemCollectionID:
		m.ClearFeedItemCollectionID()
		return nil
	}
	return fmt.Errorf("unknown NotifySource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifySourceMutation) ResetField(name string) error {
	switch name {
	case notifysource.FieldFeedConfigID:
		m.ResetFeedConfigID()
		return nil
	case notifysource.FieldFeedItemCollectionID:
		m.ResetFeedItemCollectionID()
		return nil
	case notifysource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifysource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifySource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifySourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.owner != nil {
		edges = append(edges, notifysource.EdgeOwner)
	}
	if m.notify_flow != nil {
		edges = append(edges, notifysource.EdgeNotifyFlow)
	}
	if m.feed_config != nil {
		edges = append(edges, notifysource.EdgeFeedConfig)
	}
	if m.feed_item_collection != nil {
		edges = append(edges, notifysource.EdgeFeedItemCollection)
	}
	if m.notify_flow_source != nil {
		edges = append(edges, notifysource.EdgeNotifyFlowSource)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifySourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifysource.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case notifysource.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.notify_flow))
		for id := range m.notify_flow {
			ids = append(ids, id)
		}
		return ids
	case notifysource.EdgeFeedConfig:
		if id := m.feed_config; id != nil {
			return []ent.Value{*id}
		}
	case notifysource.EdgeFeedItemCollection:
		if id := m.feed_item_collection; id != nil {
			return []ent.Value{*id}
		}
	case notifysource.EdgeNotifyFlowSource:
		ids := make([]ent.Value, 0, len(m.notify_flow_source))
		for id := range m.notify_flow_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifySourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removednotify_flow != nil {
		edges = append(edges, notifysource.EdgeNotifyFlow)
	}
	if m.removednotify_flow_source != nil {
		edges = append(edges, notifysource.EdgeNotifyFlowSource)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifySourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notifysource.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.removednotify_flow))
		for id := range m.removednotify_flow {
			ids = append(ids, id)
		}
		return ids
	case notifysource.EdgeNotifyFlowSource:
		ids := make([]ent.Value, 0, len(m.removednotify_flow_source))
		for id := range m.removednotify_flow_source {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifySourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedowner {
		edges = append(edges, notifysource.EdgeOwner)
	}
	if m.clearednotify_flow {
		edges = append(edges, notifysource.EdgeNotifyFlow)
	}
	if m.clearedfeed_config {
		edges = append(edges, notifysource.EdgeFeedConfig)
	}
	if m.clearedfeed_item_collection {
		edges = append(edges, notifysource.EdgeFeedItemCollection)
	}
	if m.clearednotify_flow_source {
		edges = append(edges, notifysource.EdgeNotifyFlowSource)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifySourceMutation) EdgeCleared(name string) bool {
	switch name {
	case notifysource.EdgeOwner:
		return m.clearedowner
	case notifysource.EdgeNotifyFlow:
		return m.clearednotify_flow
	case notifysource.EdgeFeedConfig:
		return m.clearedfeed_config
	case notifysource.EdgeFeedItemCollection:
		return m.clearedfeed_item_collection
	case notifysource.EdgeNotifyFlowSource:
		return m.clearednotify_flow_source
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifySourceMutation) ClearEdge(name string) error {
	switch name {
	case notifysource.EdgeOwner:
		m.ClearOwner()
		return nil
	case notifysource.EdgeFeedConfig:
		m.ClearFeedConfig()
		return nil
	case notifysource.EdgeFeedItemCollection:
		m.ClearFeedItemCollection()
		return nil
	}
	return fmt.Errorf("unknown NotifySource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifySourceMutation) ResetEdge(name string) error {
	switch name {
	case notifysource.EdgeOwner:
		m.ResetOwner()
		return nil
	case notifysource.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case notifysource.EdgeFeedConfig:
		m.ResetFeedConfig()
		return nil
	case notifysource.EdgeFeedItemCollection:
		m.ResetFeedItemCollection()
		return nil
	case notifysource.EdgeNotifyFlowSource:
		m.ResetNotifyFlowSource()
		return nil
	}
	return fmt.Errorf("unknown NotifySource edge %s", name)
}

// NotifyTargetMutation represents an operation that mutates the NotifyTarget nodes in the graph.
type NotifyTargetMutation struct {
	config
	op                        Op
	typ                       string
	id                        *model.InternalID
	name                      *string
	description               *string
	destination               **modelsupervisor.FeatureRequest
	status                    *notifytarget.Status
	updated_at                *time.Time
	created_at                *time.Time
	clearedFields             map[string]struct{}
	owner                     *model.InternalID
	clearedowner              bool
	notify_flow               map[model.InternalID]struct{}
	removednotify_flow        map[model.InternalID]struct{}
	clearednotify_flow        bool
	notify_flow_target        map[int]struct{}
	removednotify_flow_target map[int]struct{}
	clearednotify_flow_target bool
	done                      bool
	oldValue                  func(context.Context) (*NotifyTarget, error)
	predicates                []predicate.NotifyTarget
}

var _ ent.Mutation = (*NotifyTargetMutation)(nil)

// notifytargetOption allows management of the mutation configuration using functional options.
type notifytargetOption func(*NotifyTargetMutation)

// newNotifyTargetMutation creates new mutation for the NotifyTarget entity.
func newNotifyTargetMutation(c config, op Op, opts ...notifytargetOption) *NotifyTargetMutation {
	m := &NotifyTargetMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifyTarget,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifyTargetID sets the ID field of the mutation.
func withNotifyTargetID(id model.InternalID) notifytargetOption {
	return func(m *NotifyTargetMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifyTarget
		)
		m.oldValue = func(ctx context.Context) (*NotifyTarget, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifyTarget.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifyTarget sets the old NotifyTarget of the mutation.
func withNotifyTarget(node *NotifyTarget) notifytargetOption {
	return func(m *NotifyTargetMutation) {
		m.oldValue = func(context.Context) (*NotifyTarget, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifyTargetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifyTargetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotifyTarget entities.
func (m *NotifyTargetMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifyTargetMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifyTargetMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifyTarget.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NotifyTargetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotifyTargetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotifyTargetMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *NotifyTargetMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NotifyTargetMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *NotifyTargetMutation) ResetDescription() {
	m.description = nil
}

// SetDestination sets the "destination" field.
func (m *NotifyTargetMutation) SetDestination(mr *modelsupervisor.FeatureRequest) {
	m.destination = &mr
}

// Destination returns the value of the "destination" field in the mutation.
func (m *NotifyTargetMutation) Destination() (r *modelsupervisor.FeatureRequest, exists bool) {
	v := m.destination
	if v == nil {
		return
	}
	return *v, true
}

// OldDestination returns the old "destination" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldDestination(ctx context.Context) (v *modelsupervisor.FeatureRequest, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestination: %w", err)
	}
	return oldValue.Destination, nil
}

// ResetDestination resets all changes to the "destination" field.
func (m *NotifyTargetMutation) ResetDestination() {
	m.destination = nil
}

// SetStatus sets the "status" field.
func (m *NotifyTargetMutation) SetStatus(n notifytarget.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NotifyTargetMutation) Status() (r notifytarget.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldStatus(ctx context.Context) (v notifytarget.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NotifyTargetMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NotifyTargetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NotifyTargetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NotifyTargetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifyTargetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifyTargetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifyTarget entity.
// If the NotifyTarget object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifyTargetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifyTargetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *NotifyTargetMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *NotifyTargetMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *NotifyTargetMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NotifyTargetMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NotifyTargetMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NotifyTargetMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddNotifyFlowIDs adds the "notify_flow" edge to the NotifyFlow entity by ids.
func (m *NotifyTargetMutation) AddNotifyFlowIDs(ids ...model.InternalID) {
	if m.notify_flow == nil {
		m.notify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_flow[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifyTargetMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *NotifyTargetMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// RemoveNotifyFlowIDs removes the "notify_flow" edge to the NotifyFlow entity by IDs.
func (m *NotifyTargetMutation) RemoveNotifyFlowIDs(ids ...model.InternalID) {
	if m.removednotify_flow == nil {
		m.removednotify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_flow, ids[i])
		m.removednotify_flow[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlow returns the removed IDs of the "notify_flow" edge to the NotifyFlow entity.
func (m *NotifyTargetMutation) RemovedNotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.removednotify_flow {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
func (m *NotifyTargetMutation) NotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.notify_flow {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *NotifyTargetMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
	m.removednotify_flow = nil
}

// AddNotifyFlowTargetIDs adds the "notify_flow_target" edge to the NotifyFlowTarget entity by ids.
func (m *NotifyTargetMutation) AddNotifyFlowTargetIDs(ids ...int) {
	if m.notify_flow_target == nil {
		m.notify_flow_target = make(map[int]struct{})
	}
	for i := range ids {
		m.notify_flow_target[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlowTarget clears the "notify_flow_target" edge to the NotifyFlowTarget entity.
func (m *NotifyTargetMutation) ClearNotifyFlowTarget() {
	m.clearednotify_flow_target = true
}

// NotifyFlowTargetCleared reports if the "notify_flow_target" edge to the NotifyFlowTarget entity was cleared.
func (m *NotifyTargetMutation) NotifyFlowTargetCleared() bool {
	return m.clearednotify_flow_target
}

// RemoveNotifyFlowTargetIDs removes the "notify_flow_target" edge to the NotifyFlowTarget entity by IDs.
func (m *NotifyTargetMutation) RemoveNotifyFlowTargetIDs(ids ...int) {
	if m.removednotify_flow_target == nil {
		m.removednotify_flow_target = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.notify_flow_target, ids[i])
		m.removednotify_flow_target[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlowTarget returns the removed IDs of the "notify_flow_target" edge to the NotifyFlowTarget entity.
func (m *NotifyTargetMutation) RemovedNotifyFlowTargetIDs() (ids []int) {
	for id := range m.removednotify_flow_target {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowTargetIDs returns the "notify_flow_target" edge IDs in the mutation.
func (m *NotifyTargetMutation) NotifyFlowTargetIDs() (ids []int) {
	for id := range m.notify_flow_target {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlowTarget resets all changes to the "notify_flow_target" edge.
func (m *NotifyTargetMutation) ResetNotifyFlowTarget() {
	m.notify_flow_target = nil
	m.clearednotify_flow_target = false
	m.removednotify_flow_target = nil
}

// Where appends a list predicates to the NotifyTargetMutation builder.
func (m *NotifyTargetMutation) Where(ps ...predicate.NotifyTarget) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifyTargetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifyTargetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifyTarget, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifyTargetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifyTargetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifyTarget).
func (m *NotifyTargetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifyTargetMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, notifytarget.FieldName)
	}
	if m.description != nil {
		fields = append(fields, notifytarget.FieldDescription)
	}
	if m.destination != nil {
		fields = append(fields, notifytarget.FieldDestination)
	}
	if m.status != nil {
		fields = append(fields, notifytarget.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, notifytarget.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, notifytarget.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifyTargetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifytarget.FieldName:
		return m.Name()
	case notifytarget.FieldDescription:
		return m.Description()
	case notifytarget.FieldDestination:
		return m.Destination()
	case notifytarget.FieldStatus:
		return m.Status()
	case notifytarget.FieldUpdatedAt:
		return m.UpdatedAt()
	case notifytarget.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifyTargetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifytarget.FieldName:
		return m.OldName(ctx)
	case notifytarget.FieldDescription:
		return m.OldDescription(ctx)
	case notifytarget.FieldDestination:
		return m.OldDestination(ctx)
	case notifytarget.FieldStatus:
		return m.OldStatus(ctx)
	case notifytarget.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case notifytarget.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown NotifyTarget field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyTargetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifytarget.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notifytarget.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case notifytarget.FieldDestination:
		v, ok := value.(*modelsupervisor.FeatureRequest)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestination(v)
		return nil
	case notifytarget.FieldStatus:
		v, ok := value.(notifytarget.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case notifytarget.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case notifytarget.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown NotifyTarget field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifyTargetMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifyTargetMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifyTargetMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifyTarget numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifyTargetMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifyTargetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifyTargetMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotifyTarget nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifyTargetMutation) ResetField(name string) error {
	switch name {
	case notifytarget.FieldName:
		m.ResetName()
		return nil
	case notifytarget.FieldDescription:
		m.ResetDescription()
		return nil
	case notifytarget.FieldDestination:
		m.ResetDestination()
		return nil
	case notifytarget.FieldStatus:
		m.ResetStatus()
		return nil
	case notifytarget.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case notifytarget.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown NotifyTarget field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifyTargetMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, notifytarget.EdgeOwner)
	}
	if m.notify_flow != nil {
		edges = append(edges, notifytarget.EdgeNotifyFlow)
	}
	if m.notify_flow_target != nil {
		edges = append(edges, notifytarget.EdgeNotifyFlowTarget)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifyTargetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifytarget.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case notifytarget.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.notify_flow))
		for id := range m.notify_flow {
			ids = append(ids, id)
		}
		return ids
	case notifytarget.EdgeNotifyFlowTarget:
		ids := make([]ent.Value, 0, len(m.notify_flow_target))
		for id := range m.notify_flow_target {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifyTargetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removednotify_flow != nil {
		edges = append(edges, notifytarget.EdgeNotifyFlow)
	}
	if m.removednotify_flow_target != nil {
		edges = append(edges, notifytarget.EdgeNotifyFlowTarget)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifyTargetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case notifytarget.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.removednotify_flow))
		for id := range m.removednotify_flow {
			ids = append(ids, id)
		}
		return ids
	case notifytarget.EdgeNotifyFlowTarget:
		ids := make([]ent.Value, 0, len(m.removednotify_flow_target))
		for id := range m.removednotify_flow_target {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifyTargetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, notifytarget.EdgeOwner)
	}
	if m.clearednotify_flow {
		edges = append(edges, notifytarget.EdgeNotifyFlow)
	}
	if m.clearednotify_flow_target {
		edges = append(edges, notifytarget.EdgeNotifyFlowTarget)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifyTargetMutation) EdgeCleared(name string) bool {
	switch name {
	case notifytarget.EdgeOwner:
		return m.clearedowner
	case notifytarget.EdgeNotifyFlow:
		return m.clearednotify_flow
	case notifytarget.EdgeNotifyFlowTarget:
		return m.clearednotify_flow_target
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifyTargetMutation) ClearEdge(name string) error {
	switch name {
	case notifytarget.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown NotifyTarget unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifyTargetMutation) ResetEdge(name string) error {
	switch name {
	case notifytarget.EdgeOwner:
		m.ResetOwner()
		return nil
	case notifytarget.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case notifytarget.EdgeNotifyFlowTarget:
		m.ResetNotifyFlowTarget()
		return nil
	}
	return fmt.Errorf("unknown NotifyTarget edge %s", name)
}

// PorterContextMutation represents an operation that mutates the PorterContext nodes in the graph.
type PorterContextMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	global_name   *string
	region        *string
	context_json  *string
	name          *string
	description   *string
	status        *portercontext.Status
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *model.InternalID
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*PorterContext, error)
	predicates    []predicate.PorterContext
}

var _ ent.Mutation = (*PorterContextMutation)(nil)

// portercontextOption allows management of the mutation configuration using functional options.
type portercontextOption func(*PorterContextMutation)

// newPorterContextMutation creates new mutation for the PorterContext entity.
func newPorterContextMutation(c config, op Op, opts ...portercontextOption) *PorterContextMutation {
	m := &PorterContextMutation{
		config:        c,
		op:            op,
		typ:           TypePorterContext,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPorterContextID sets the ID field of the mutation.
func withPorterContextID(id model.InternalID) portercontextOption {
	return func(m *PorterContextMutation) {
		var (
			err   error
			once  sync.Once
			value *PorterContext
		)
		m.oldValue = func(ctx context.Context) (*PorterContext, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PorterContext.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPorterContext sets the old PorterContext of the mutation.
func withPorterContext(node *PorterContext) portercontextOption {
	return func(m *PorterContextMutation) {
		m.oldValue = func(context.Context) (*PorterContext, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PorterContextMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PorterContextMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PorterContext entities.
func (m *PorterContextMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PorterContextMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PorterContextMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PorterContext.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGlobalName sets the "global_name" field.
func (m *PorterContextMutation) SetGlobalName(s string) {
	m.global_name = &s
}

// GlobalName returns the value of the "global_name" field in the mutation.
func (m *PorterContextMutation) GlobalName() (r string, exists bool) {
	v := m.global_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGlobalName returns the old "global_name" field's value of the PorterContext entity.
// If the PorterContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterContextMutation) OldGlobalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGlobalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGlobalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGlobalName: %w", err)
	}
	return oldValue.GlobalName, nil
}

// ResetGlobalName resets all changes to the "global_name" field.
func (m *PorterContextMutation) ResetGlobalName() {
	m.global_name = nil
}

// SetRegion sets the "region" field.
func (m *PorterContextMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *PorterContextMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the PorterContext entity.
// If the PorterContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterContextMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "region" field.
func (m *PorterContextMutation) ResetRegion() {
	m.region = nil
}

// SetContextJSON sets the "context_json" field.
func (m *PorterContextMutation) SetContextJSON(s string) {
	m.context_json = &s
}

// ContextJSON returns the value of the "context_json" field in the mutation.
func (m *PorterContextMutation) ContextJSON() (r string, exists bool) {
	v := m.context_json
	if v == nil {
		return
	}
	return *v, true
}

// OldContextJSON returns the old "context_json" field's value of the PorterContext entity.
// If the PorterContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterContextMutation) OldContextJSON(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContextJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContextJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContextJSON: %w", err)
	}
	return oldValue.ContextJSON, nil
}

// ResetContextJSON resets all changes to the "context_json" field.
func (m *PorterContextMutation) ResetContextJSON() {
	m.context_json = nil
}

// SetName sets the "name" field.
func (m *PorterContextMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PorterContextMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PorterContext entity.
// If the PorterContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterContextMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PorterContextMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PorterContextMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PorterContextMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PorterContext entity.
// If the PorterContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterContextMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PorterContextMutation) ResetDescription() {
	m.description = nil
}

// SetStatus sets the "status" field.
func (m *PorterContextMutation) SetStatus(po portercontext.Status) {
	m.status = &po
}

// Status returns the value of the "status" field in the mutation.
func (m *PorterContextMutation) Status() (r portercontext.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PorterContext entity.
// If the PorterContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterContextMutation) OldStatus(ctx context.Context) (v portercontext.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PorterContextMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PorterContextMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PorterContextMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PorterContext entity.
// If the PorterContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterContextMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PorterContextMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PorterContextMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PorterContextMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PorterContext entity.
// If the PorterContext object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterContextMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PorterContextMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *PorterContextMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *PorterContextMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *PorterContextMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *PorterContextMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *PorterContextMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *PorterContextMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the PorterContextMutation builder.
func (m *PorterContextMutation) Where(ps ...predicate.PorterContext) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PorterContextMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PorterContextMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PorterContext, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PorterContextMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PorterContextMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PorterContext).
func (m *PorterContextMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PorterContextMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.global_name != nil {
		fields = append(fields, portercontext.FieldGlobalName)
	}
	if m.region != nil {
		fields = append(fields, portercontext.FieldRegion)
	}
	if m.context_json != nil {
		fields = append(fields, portercontext.FieldContextJSON)
	}
	if m.name != nil {
		fields = append(fields, portercontext.FieldName)
	}
	if m.description != nil {
		fields = append(fields, portercontext.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, portercontext.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, portercontext.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, portercontext.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PorterContextMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case portercontext.FieldGlobalName:
		return m.GlobalName()
	case portercontext.FieldRegion:
		return m.Region()
	case portercontext.FieldContextJSON:
		return m.ContextJSON()
	case portercontext.FieldName:
		return m.Name()
	case portercontext.FieldDescription:
		return m.Description()
	case portercontext.FieldStatus:
		return m.Status()
	case portercontext.FieldUpdatedAt:
		return m.UpdatedAt()
	case portercontext.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PorterContextMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case portercontext.FieldGlobalName:
		return m.OldGlobalName(ctx)
	case portercontext.FieldRegion:
		return m.OldRegion(ctx)
	case portercontext.FieldContextJSON:
		return m.OldContextJSON(ctx)
	case portercontext.FieldName:
		return m.OldName(ctx)
	case portercontext.FieldDescription:
		return m.OldDescription(ctx)
	case portercontext.FieldStatus:
		return m.OldStatus(ctx)
	case portercontext.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case portercontext.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PorterContext field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PorterContextMutation) SetField(name string, value ent.Value) error {
	switch name {
	case portercontext.FieldGlobalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGlobalName(v)
		return nil
	case portercontext.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case portercontext.FieldContextJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContextJSON(v)
		return nil
	case portercontext.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case portercontext.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case portercontext.FieldStatus:
		v, ok := value.(portercontext.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case portercontext.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case portercontext.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PorterContext field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PorterContextMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PorterContextMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PorterContextMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PorterContext numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PorterContextMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PorterContextMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PorterContextMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PorterContext nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PorterContextMutation) ResetField(name string) error {
	switch name {
	case portercontext.FieldGlobalName:
		m.ResetGlobalName()
		return nil
	case portercontext.FieldRegion:
		m.ResetRegion()
		return nil
	case portercontext.FieldContextJSON:
		m.ResetContextJSON()
		return nil
	case portercontext.FieldName:
		m.ResetName()
		return nil
	case portercontext.FieldDescription:
		m.ResetDescription()
		return nil
	case portercontext.FieldStatus:
		m.ResetStatus()
		return nil
	case portercontext.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case portercontext.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PorterContext field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PorterContextMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, portercontext.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PorterContextMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case portercontext.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PorterContextMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PorterContextMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PorterContextMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, portercontext.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PorterContextMutation) EdgeCleared(name string) bool {
	switch name {
	case portercontext.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PorterContextMutation) ClearEdge(name string) error {
	switch name {
	case portercontext.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown PorterContext unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PorterContextMutation) ResetEdge(name string) error {
	switch name {
	case portercontext.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown PorterContext edge %s", name)
}

// PorterInstanceMutation represents an operation that mutates the PorterInstance nodes in the graph.
type PorterInstanceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *model.InternalID
	name                *string
	version             *string
	description         *string
	source_code_address *string
	build_version       *string
	build_date          *string
	global_name         *string
	address             *string
	region              *string
	feature_summary     **modelsupervisor.PorterFeatureSummary
	context_json_schema *string
	status              *porterinstance.Status
	updated_at          *time.Time
	created_at          *time.Time
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*PorterInstance, error)
	predicates          []predicate.PorterInstance
}

var _ ent.Mutation = (*PorterInstanceMutation)(nil)

// porterinstanceOption allows management of the mutation configuration using functional options.
type porterinstanceOption func(*PorterInstanceMutation)

// newPorterInstanceMutation creates new mutation for the PorterInstance entity.
func newPorterInstanceMutation(c config, op Op, opts ...porterinstanceOption) *PorterInstanceMutation {
	m := &PorterInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypePorterInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPorterInstanceID sets the ID field of the mutation.
func withPorterInstanceID(id model.InternalID) porterinstanceOption {
	return func(m *PorterInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *PorterInstance
		)
		m.oldValue = func(ctx context.Context) (*PorterInstance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PorterInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPorterInstance sets the old PorterInstance of the mutation.
func withPorterInstance(node *PorterInstance) porterinstanceOption {
	return func(m *PorterInstanceMutation) {
		m.oldValue = func(context.Context) (*PorterInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PorterInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PorterInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PorterInstance entities.
func (m *PorterInstanceMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PorterInstanceMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PorterInstanceMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PorterInstance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PorterInstanceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PorterInstanceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PorterInstanceMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *PorterInstanceMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *PorterInstanceMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *PorterInstanceMutation) ResetVersion() {
	m.version = nil
}

// SetDescription sets the "description" field.
func (m *PorterInstanceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PorterInstanceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PorterInstanceMutation) ResetDescription() {
	m.description = nil
}

// SetSourceCodeAddress sets the "source_code_address" field.
func (m *PorterInstanceMutation) SetSourceCodeAddress(s string) {
	m.source_code_address = &s
}

// SourceCodeAddress returns the value of the "source_code_address" field in the mutation.
func (m *PorterInstanceMutation) SourceCodeAddress() (r string, exists bool) {
	v := m.source_code_address
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceCodeAddress returns the old "source_code_address" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldSourceCodeAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceCodeAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceCodeAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceCodeAddress: %w", err)
	}
	return oldValue.SourceCodeAddress, nil
}

// ResetSourceCodeAddress resets all changes to the "source_code_address" field.
func (m *PorterInstanceMutation) ResetSourceCodeAddress() {
	m.source_code_address = nil
}

// SetBuildVersion sets the "build_version" field.
func (m *PorterInstanceMutation) SetBuildVersion(s string) {
	m.build_version = &s
}

// BuildVersion returns the value of the "build_version" field in the mutation.
func (m *PorterInstanceMutation) BuildVersion() (r string, exists bool) {
	v := m.build_version
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildVersion returns the old "build_version" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldBuildVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildVersion: %w", err)
	}
	return oldValue.BuildVersion, nil
}

// ResetBuildVersion resets all changes to the "build_version" field.
func (m *PorterInstanceMutation) ResetBuildVersion() {
	m.build_version = nil
}

// SetBuildDate sets the "build_date" field.
func (m *PorterInstanceMutation) SetBuildDate(s string) {
	m.build_date = &s
}

// BuildDate returns the value of the "build_date" field in the mutation.
func (m *PorterInstanceMutation) BuildDate() (r string, exists bool) {
	v := m.build_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildDate returns the old "build_date" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldBuildDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildDate: %w", err)
	}
	return oldValue.BuildDate, nil
}

// ResetBuildDate resets all changes to the "build_date" field.
func (m *PorterInstanceMutation) ResetBuildDate() {
	m.build_date = nil
}

// SetGlobalName sets the "global_name" field.
func (m *PorterInstanceMutation) SetGlobalName(s string) {
	m.global_name = &s
}

// GlobalName returns the value of the "global_name" field in the mutation.
func (m *PorterInstanceMutation) GlobalName() (r string, exists bool) {
	v := m.global_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGlobalName returns the old "global_name" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldGlobalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGlobalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGlobalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGlobalName: %w", err)
	}
	return oldValue.GlobalName, nil
}

// ResetGlobalName resets all changes to the "global_name" field.
func (m *PorterInstanceMutation) ResetGlobalName() {
	m.global_name = nil
}

// SetAddress sets the "address" field.
func (m *PorterInstanceMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PorterInstanceMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *PorterInstanceMutation) ResetAddress() {
	m.address = nil
}

// SetRegion sets the "region" field.
func (m *PorterInstanceMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *PorterInstanceMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "region" field.
func (m *PorterInstanceMutation) ResetRegion() {
	m.region = nil
}

// SetFeatureSummary sets the "feature_summary" field.
func (m *PorterInstanceMutation) SetFeatureSummary(mfs *modelsupervisor.PorterFeatureSummary) {
	m.feature_summary = &mfs
}

// FeatureSummary returns the value of the "feature_summary" field in the mutation.
func (m *PorterInstanceMutation) FeatureSummary() (r *modelsupervisor.PorterFeatureSummary, exists bool) {
	v := m.feature_summary
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureSummary returns the old "feature_summary" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldFeatureSummary(ctx context.Context) (v *modelsupervisor.PorterFeatureSummary, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureSummary: %w", err)
	}
	return oldValue.FeatureSummary, nil
}

// ResetFeatureSummary resets all changes to the "feature_summary" field.
func (m *PorterInstanceMutation) ResetFeatureSummary() {
	m.feature_summary = nil
}

// SetContextJSONSchema sets the "context_json_schema" field.
func (m *PorterInstanceMutation) SetContextJSONSchema(s string) {
	m.context_json_schema = &s
}

// ContextJSONSchema returns the value of the "context_json_schema" field in the mutation.
func (m *PorterInstanceMutation) ContextJSONSchema() (r string, exists bool) {
	v := m.context_json_schema
	if v == nil {
		return
	}
	return *v, true
}

// OldContextJSONSchema returns the old "context_json_schema" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldContextJSONSchema(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContextJSONSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContextJSONSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContextJSONSchema: %w", err)
	}
	return oldValue.ContextJSONSchema, nil
}

// ResetContextJSONSchema resets all changes to the "context_json_schema" field.
func (m *PorterInstanceMutation) ResetContextJSONSchema() {
	m.context_json_schema = nil
}

// SetStatus sets the "status" field.
func (m *PorterInstanceMutation) SetStatus(po porterinstance.Status) {
	m.status = &po
}

// Status returns the value of the "status" field in the mutation.
func (m *PorterInstanceMutation) Status() (r porterinstance.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldStatus(ctx context.Context) (v porterinstance.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PorterInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PorterInstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PorterInstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PorterInstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PorterInstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PorterInstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PorterInstance entity.
// If the PorterInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PorterInstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PorterInstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the PorterInstanceMutation builder.
func (m *PorterInstanceMutation) Where(ps ...predicate.PorterInstance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PorterInstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PorterInstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PorterInstance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PorterInstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PorterInstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PorterInstance).
func (m *PorterInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PorterInstanceMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, porterinstance.FieldName)
	}
	if m.version != nil {
		fields = append(fields, porterinstance.FieldVersion)
	}
	if m.description != nil {
		fields = append(fields, porterinstance.FieldDescription)
	}
	if m.source_code_address != nil {
		fields = append(fields, porterinstance.FieldSourceCodeAddress)
	}
	if m.build_version != nil {
		fields = append(fields, porterinstance.FieldBuildVersion)
	}
	if m.build_date != nil {
		fields = append(fields, porterinstance.FieldBuildDate)
	}
	if m.global_name != nil {
		fields = append(fields, porterinstance.FieldGlobalName)
	}
	if m.address != nil {
		fields = append(fields, porterinstance.FieldAddress)
	}
	if m.region != nil {
		fields = append(fields, porterinstance.FieldRegion)
	}
	if m.feature_summary != nil {
		fields = append(fields, porterinstance.FieldFeatureSummary)
	}
	if m.context_json_schema != nil {
		fields = append(fields, porterinstance.FieldContextJSONSchema)
	}
	if m.status != nil {
		fields = append(fields, porterinstance.FieldStatus)
	}
	if m.updated_at != nil {
		fields = append(fields, porterinstance.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, porterinstance.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PorterInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case porterinstance.FieldName:
		return m.Name()
	case porterinstance.FieldVersion:
		return m.Version()
	case porterinstance.FieldDescription:
		return m.Description()
	case porterinstance.FieldSourceCodeAddress:
		return m.SourceCodeAddress()
	case porterinstance.FieldBuildVersion:
		return m.BuildVersion()
	case porterinstance.FieldBuildDate:
		return m.BuildDate()
	case porterinstance.FieldGlobalName:
		return m.GlobalName()
	case porterinstance.FieldAddress:
		return m.Address()
	case porterinstance.FieldRegion:
		return m.Region()
	case porterinstance.FieldFeatureSummary:
		return m.FeatureSummary()
	case porterinstance.FieldContextJSONSchema:
		return m.ContextJSONSchema()
	case porterinstance.FieldStatus:
		return m.Status()
	case porterinstance.FieldUpdatedAt:
		return m.UpdatedAt()
	case porterinstance.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PorterInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case porterinstance.FieldName:
		return m.OldName(ctx)
	case porterinstance.FieldVersion:
		return m.OldVersion(ctx)
	case porterinstance.FieldDescription:
		return m.OldDescription(ctx)
	case porterinstance.FieldSourceCodeAddress:
		return m.OldSourceCodeAddress(ctx)
	case porterinstance.FieldBuildVersion:
		return m.OldBuildVersion(ctx)
	case porterinstance.FieldBuildDate:
		return m.OldBuildDate(ctx)
	case porterinstance.FieldGlobalName:
		return m.OldGlobalName(ctx)
	case porterinstance.FieldAddress:
		return m.OldAddress(ctx)
	case porterinstance.FieldRegion:
		return m.OldRegion(ctx)
	case porterinstance.FieldFeatureSummary:
		return m.OldFeatureSummary(ctx)
	case porterinstance.FieldContextJSONSchema:
		return m.OldContextJSONSchema(ctx)
	case porterinstance.FieldStatus:
		return m.OldStatus(ctx)
	case porterinstance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case porterinstance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PorterInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PorterInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case porterinstance.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case porterinstance.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case porterinstance.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case porterinstance.FieldSourceCodeAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceCodeAddress(v)
		return nil
	case porterinstance.FieldBuildVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildVersion(v)
		return nil
	case porterinstance.FieldBuildDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildDate(v)
		return nil
	case porterinstance.FieldGlobalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGlobalName(v)
		return nil
	case porterinstance.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case porterinstance.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case porterinstance.FieldFeatureSummary:
		v, ok := value.(*modelsupervisor.PorterFeatureSummary)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureSummary(v)
		return nil
	case porterinstance.FieldContextJSONSchema:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContextJSONSchema(v)
		return nil
	case porterinstance.FieldStatus:
		v, ok := value.(porterinstance.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case porterinstance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case porterinstance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PorterInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PorterInstanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PorterInstanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PorterInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PorterInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PorterInstanceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PorterInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PorterInstanceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PorterInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PorterInstanceMutation) ResetField(name string) error {
	switch name {
	case porterinstance.FieldName:
		m.ResetName()
		return nil
	case porterinstance.FieldVersion:
		m.ResetVersion()
		return nil
	case porterinstance.FieldDescription:
		m.ResetDescription()
		return nil
	case porterinstance.FieldSourceCodeAddress:
		m.ResetSourceCodeAddress()
		return nil
	case porterinstance.FieldBuildVersion:
		m.ResetBuildVersion()
		return nil
	case porterinstance.FieldBuildDate:
		m.ResetBuildDate()
		return nil
	case porterinstance.FieldGlobalName:
		m.ResetGlobalName()
		return nil
	case porterinstance.FieldAddress:
		m.ResetAddress()
		return nil
	case porterinstance.FieldRegion:
		m.ResetRegion()
		return nil
	case porterinstance.FieldFeatureSummary:
		m.ResetFeatureSummary()
		return nil
	case porterinstance.FieldContextJSONSchema:
		m.ResetContextJSONSchema()
		return nil
	case porterinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case porterinstance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case porterinstance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PorterInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PorterInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PorterInstanceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PorterInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PorterInstanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PorterInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PorterInstanceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PorterInstanceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PorterInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PorterInstanceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PorterInstance edge %s", name)
}

// SentinelAppBinaryMutation represents an operation that mutates the SentinelAppBinary nodes in the graph.
type SentinelAppBinaryMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	sentinel_info_id                *model.InternalID
	addsentinel_info_id             *model.InternalID
	sentinel_library_reported_id    *int64
	addsentinel_library_reported_id *int64
	generated_id                    *string
	size_bytes                      *int64
	addsize_bytes                   *int64
	need_token                      *bool
	name                            *string
	version                         *string
	developer                       *string
	publisher                       *string
	updated_at                      *time.Time
	created_at                      *time.Time
	app_binary_report_sequence      *int64
	addapp_binary_report_sequence   *int64
	clearedFields                   map[string]struct{}
	done                            bool
	oldValue                        func(context.Context) (*SentinelAppBinary, error)
	predicates                      []predicate.SentinelAppBinary
}

var _ ent.Mutation = (*SentinelAppBinaryMutation)(nil)

// sentinelappbinaryOption allows management of the mutation configuration using functional options.
type sentinelappbinaryOption func(*SentinelAppBinaryMutation)

// newSentinelAppBinaryMutation creates new mutation for the SentinelAppBinary entity.
func newSentinelAppBinaryMutation(c config, op Op, opts ...sentinelappbinaryOption) *SentinelAppBinaryMutation {
	m := &SentinelAppBinaryMutation{
		config:        c,
		op:            op,
		typ:           TypeSentinelAppBinary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSentinelAppBinaryID sets the ID field of the mutation.
func withSentinelAppBinaryID(id int) sentinelappbinaryOption {
	return func(m *SentinelAppBinaryMutation) {
		var (
			err   error
			once  sync.Once
			value *SentinelAppBinary
		)
		m.oldValue = func(ctx context.Context) (*SentinelAppBinary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SentinelAppBinary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSentinelAppBinary sets the old SentinelAppBinary of the mutation.
func withSentinelAppBinary(node *SentinelAppBinary) sentinelappbinaryOption {
	return func(m *SentinelAppBinaryMutation) {
		m.oldValue = func(context.Context) (*SentinelAppBinary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SentinelAppBinaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SentinelAppBinaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SentinelAppBinaryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SentinelAppBinaryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SentinelAppBinary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSentinelInfoID sets the "sentinel_info_id" field.
func (m *SentinelAppBinaryMutation) SetSentinelInfoID(mi model.InternalID) {
	m.sentinel_info_id = &mi
	m.addsentinel_info_id = nil
}

// SentinelInfoID returns the value of the "sentinel_info_id" field in the mutation.
func (m *SentinelAppBinaryMutation) SentinelInfoID() (r model.InternalID, exists bool) {
	v := m.sentinel_info_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSentinelInfoID returns the old "sentinel_info_id" field's value of the SentinelAppBinary entity.
// If the SentinelAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryMutation) OldSentinelInfoID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentinelInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentinelInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentinelInfoID: %w", err)
	}
	return oldValue.SentinelInfoID, nil
}

// AddSentinelInfoID adds mi to the "sentinel_info_id" field.
func (m *SentinelAppBinaryMutation) AddSentinelInfoID(mi model.InternalID) {
	if m.addsentinel_info_id != nil {
		*m.addsentinel_info_id += mi
	} else {
		m.addsentinel_info_id = &mi
	}
}

// AddedSentinelInfoID returns the value that was added to the "sentinel_info_id" field in this mutation.
func (m *SentinelAppBinaryMutation) AddedSentinelInfoID() (r model.InternalID, exists bool) {
	v := m.addsentinel_info_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSentinelInfoID resets all changes to the "sentinel_info_id" field.
func (m *SentinelAppBinaryMutation) ResetSentinelInfoID() {
	m.sentinel_info_id = nil
	m.addsentinel_info_id = nil
}

// SetSentinelLibraryReportedID sets the "sentinel_library_reported_id" field.
func (m *SentinelAppBinaryMutation) SetSentinelLibraryReportedID(i int64) {
	m.sentinel_library_reported_id = &i
	m.addsentinel_library_reported_id = nil
}

// SentinelLibraryReportedID returns the value of the "sentinel_library_reported_id" field in the mutation.
func (m *SentinelAppBinaryMutation) SentinelLibraryReportedID() (r int64, exists bool) {
	v := m.sentinel_library_reported_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSentinelLibraryReportedID returns the old "sentinel_library_reported_id" field's value of the SentinelAppBinary entity.
// If the SentinelAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryMutation) OldSentinelLibraryReportedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentinelLibraryReportedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentinelLibraryReportedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentinelLibraryReportedID: %w", err)
	}
	return oldValue.SentinelLibraryReportedID, nil
}

// AddSentinelLibraryReportedID adds i to the "sentinel_library_reported_id" field.
func (m *SentinelAppBinaryMutation) AddSentinelLibraryReportedID(i int64) {
	if m.addsentinel_library_reported_id != nil {
		*m.addsentinel_library_reported_id += i
	} else {
		m.addsentinel_library_reported_id = &i
	}
}

// AddedSentinelLibraryReportedID returns the value that was added to the "sentinel_library_reported_id" field in this mutation.
func (m *SentinelAppBinaryMutation) AddedSentinelLibraryReportedID() (r int64, exists bool) {
	v := m.addsentinel_library_reported_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSentinelLibraryReportedID resets all changes to the "sentinel_library_reported_id" field.
func (m *SentinelAppBinaryMutation) ResetSentinelLibraryReportedID() {
	m.sentinel_library_reported_id = nil
	m.addsentinel_library_reported_id = nil
}

// SetGeneratedID sets the "generated_id" field.
func (m *SentinelAppBinaryMutation) SetGeneratedID(s string) {
	m.generated_id = &s
}

// GeneratedID returns the value of the "generated_id" field in the mutation.
func (m *SentinelAppBinaryMutation) GeneratedID() (r string, exists bool) {
	v := m.generated_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGeneratedID returns the old "generated_id" field's value of the SentinelAppBinary entity.
// If the SentinelAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryMutation) OldGeneratedID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeneratedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeneratedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeneratedID: %w", err)
	}
	return oldValue.GeneratedID, nil
}

// ResetGeneratedID resets all changes to the "generated_id" field.
func (m *SentinelAppBinaryMutation) ResetGeneratedID() {
	m.generated_id = nil
}

// SetSizeBytes sets the "size_bytes" field.
func (m *SentinelAppBinaryMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *SentinelAppBinaryMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the SentinelAppBinary entity.
// If the SentinelAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *SentinelAppBinaryMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *SentinelAppBinaryMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *SentinelAppBinaryMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
}

// SetNeedToken sets the "need_token" field.
func (m *SentinelAppBinaryMutation) SetNeedToken(b bool) {
	m.need_token = &b
}

// NeedToken returns the value of the "need_token" field in the mutation.
func (m *SentinelAppBinaryMutation) NeedToken() (r bool, exists bool) {
	v := m.need_token
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedToken returns the old "need_token" field's value of the SentinelAppBinary entity.
// If the SentinelAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryMutation) OldNeedToken(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedToken: %w", err)
	}
	return oldValue.NeedToken, nil
}

// ResetNeedToken resets all changes to the "need_token" field.
func (m *SentinelAppBinaryMutation) ResetNeedToken() {
	m.need_token = nil
}

// SetName sets the "name" field.
func (m *SentinelAppBinaryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SentinelAppBinaryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SentinelAppBinary entity.
// If the SentinelAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *SentinelAppBinaryMutation) ClearName() {
	m.name = nil
	m.clearedFields[sentinelappbinary.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *SentinelAppBinaryMutation) NameCleared() bool {
	_, ok := m.clearedFields[sentinelappbinary.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *SentinelAppBinaryMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, sentinelappbinary.FieldName)
}

// SetVersion sets the "version" field.
func (m *SentinelAppBinaryMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *SentinelAppBinaryMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the SentinelAppBinary entity.
// If the SentinelAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *SentinelAppBinaryMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[sentinelappbinary.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *SentinelAppBinaryMutation) VersionCleared() bool {
	_, ok := m.clearedFields[sentinelappbinary.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *SentinelAppBinaryMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, sentinelappbinary.FieldVersion)
}

// SetDeveloper sets the "developer" field.
func (m *SentinelAppBinaryMutation) SetDeveloper(s string) {
	m.developer = &s
}

// Developer returns the value of the "developer" field in the mutation.
func (m *SentinelAppBinaryMutation) Developer() (r string, exists bool) {
	v := m.developer
	if v == nil {
		return
	}
	return *v, true
}

// OldDeveloper returns the old "developer" field's value of the SentinelAppBinary entity.
// If the SentinelAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryMutation) OldDeveloper(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeveloper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeveloper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeveloper: %w", err)
	}
	return oldValue.Developer, nil
}

// ClearDeveloper clears the value of the "developer" field.
func (m *SentinelAppBinaryMutation) ClearDeveloper() {
	m.developer = nil
	m.clearedFields[sentinelappbinary.FieldDeveloper] = struct{}{}
}

// DeveloperCleared returns if the "developer" field was cleared in this mutation.
func (m *SentinelAppBinaryMutation) DeveloperCleared() bool {
	_, ok := m.clearedFields[sentinelappbinary.FieldDeveloper]
	return ok
}

// ResetDeveloper resets all changes to the "developer" field.
func (m *SentinelAppBinaryMutation) ResetDeveloper() {
	m.developer = nil
	delete(m.clearedFields, sentinelappbinary.FieldDeveloper)
}

// SetPublisher sets the "publisher" field.
func (m *SentinelAppBinaryMutation) SetPublisher(s string) {
	m.publisher = &s
}

// Publisher returns the value of the "publisher" field in the mutation.
func (m *SentinelAppBinaryMutation) Publisher() (r string, exists bool) {
	v := m.publisher
	if v == nil {
		return
	}
	return *v, true
}

// OldPublisher returns the old "publisher" field's value of the SentinelAppBinary entity.
// If the SentinelAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryMutation) OldPublisher(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublisher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublisher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublisher: %w", err)
	}
	return oldValue.Publisher, nil
}

// ClearPublisher clears the value of the "publisher" field.
func (m *SentinelAppBinaryMutation) ClearPublisher() {
	m.publisher = nil
	m.clearedFields[sentinelappbinary.FieldPublisher] = struct{}{}
}

// PublisherCleared returns if the "publisher" field was cleared in this mutation.
func (m *SentinelAppBinaryMutation) PublisherCleared() bool {
	_, ok := m.clearedFields[sentinelappbinary.FieldPublisher]
	return ok
}

// ResetPublisher resets all changes to the "publisher" field.
func (m *SentinelAppBinaryMutation) ResetPublisher() {
	m.publisher = nil
	delete(m.clearedFields, sentinelappbinary.FieldPublisher)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SentinelAppBinaryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SentinelAppBinaryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SentinelAppBinary entity.
// If the SentinelAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SentinelAppBinaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SentinelAppBinaryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SentinelAppBinaryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SentinelAppBinary entity.
// If the SentinelAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SentinelAppBinaryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAppBinaryReportSequence sets the "app_binary_report_sequence" field.
func (m *SentinelAppBinaryMutation) SetAppBinaryReportSequence(i int64) {
	m.app_binary_report_sequence = &i
	m.addapp_binary_report_sequence = nil
}

// AppBinaryReportSequence returns the value of the "app_binary_report_sequence" field in the mutation.
func (m *SentinelAppBinaryMutation) AppBinaryReportSequence() (r int64, exists bool) {
	v := m.app_binary_report_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldAppBinaryReportSequence returns the old "app_binary_report_sequence" field's value of the SentinelAppBinary entity.
// If the SentinelAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryMutation) OldAppBinaryReportSequence(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppBinaryReportSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppBinaryReportSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppBinaryReportSequence: %w", err)
	}
	return oldValue.AppBinaryReportSequence, nil
}

// AddAppBinaryReportSequence adds i to the "app_binary_report_sequence" field.
func (m *SentinelAppBinaryMutation) AddAppBinaryReportSequence(i int64) {
	if m.addapp_binary_report_sequence != nil {
		*m.addapp_binary_report_sequence += i
	} else {
		m.addapp_binary_report_sequence = &i
	}
}

// AddedAppBinaryReportSequence returns the value that was added to the "app_binary_report_sequence" field in this mutation.
func (m *SentinelAppBinaryMutation) AddedAppBinaryReportSequence() (r int64, exists bool) {
	v := m.addapp_binary_report_sequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppBinaryReportSequence resets all changes to the "app_binary_report_sequence" field.
func (m *SentinelAppBinaryMutation) ResetAppBinaryReportSequence() {
	m.app_binary_report_sequence = nil
	m.addapp_binary_report_sequence = nil
}

// Where appends a list predicates to the SentinelAppBinaryMutation builder.
func (m *SentinelAppBinaryMutation) Where(ps ...predicate.SentinelAppBinary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SentinelAppBinaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SentinelAppBinaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SentinelAppBinary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SentinelAppBinaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SentinelAppBinaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SentinelAppBinary).
func (m *SentinelAppBinaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SentinelAppBinaryMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.sentinel_info_id != nil {
		fields = append(fields, sentinelappbinary.FieldSentinelInfoID)
	}
	if m.sentinel_library_reported_id != nil {
		fields = append(fields, sentinelappbinary.FieldSentinelLibraryReportedID)
	}
	if m.generated_id != nil {
		fields = append(fields, sentinelappbinary.FieldGeneratedID)
	}
	if m.size_bytes != nil {
		fields = append(fields, sentinelappbinary.FieldSizeBytes)
	}
	if m.need_token != nil {
		fields = append(fields, sentinelappbinary.FieldNeedToken)
	}
	if m.name != nil {
		fields = append(fields, sentinelappbinary.FieldName)
	}
	if m.version != nil {
		fields = append(fields, sentinelappbinary.FieldVersion)
	}
	if m.developer != nil {
		fields = append(fields, sentinelappbinary.FieldDeveloper)
	}
	if m.publisher != nil {
		fields = append(fields, sentinelappbinary.FieldPublisher)
	}
	if m.updated_at != nil {
		fields = append(fields, sentinelappbinary.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, sentinelappbinary.FieldCreatedAt)
	}
	if m.app_binary_report_sequence != nil {
		fields = append(fields, sentinelappbinary.FieldAppBinaryReportSequence)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SentinelAppBinaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sentinelappbinary.FieldSentinelInfoID:
		return m.SentinelInfoID()
	case sentinelappbinary.FieldSentinelLibraryReportedID:
		return m.SentinelLibraryReportedID()
	case sentinelappbinary.FieldGeneratedID:
		return m.GeneratedID()
	case sentinelappbinary.FieldSizeBytes:
		return m.SizeBytes()
	case sentinelappbinary.FieldNeedToken:
		return m.NeedToken()
	case sentinelappbinary.FieldName:
		return m.Name()
	case sentinelappbinary.FieldVersion:
		return m.Version()
	case sentinelappbinary.FieldDeveloper:
		return m.Developer()
	case sentinelappbinary.FieldPublisher:
		return m.Publisher()
	case sentinelappbinary.FieldUpdatedAt:
		return m.UpdatedAt()
	case sentinelappbinary.FieldCreatedAt:
		return m.CreatedAt()
	case sentinelappbinary.FieldAppBinaryReportSequence:
		return m.AppBinaryReportSequence()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SentinelAppBinaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sentinelappbinary.FieldSentinelInfoID:
		return m.OldSentinelInfoID(ctx)
	case sentinelappbinary.FieldSentinelLibraryReportedID:
		return m.OldSentinelLibraryReportedID(ctx)
	case sentinelappbinary.FieldGeneratedID:
		return m.OldGeneratedID(ctx)
	case sentinelappbinary.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case sentinelappbinary.FieldNeedToken:
		return m.OldNeedToken(ctx)
	case sentinelappbinary.FieldName:
		return m.OldName(ctx)
	case sentinelappbinary.FieldVersion:
		return m.OldVersion(ctx)
	case sentinelappbinary.FieldDeveloper:
		return m.OldDeveloper(ctx)
	case sentinelappbinary.FieldPublisher:
		return m.OldPublisher(ctx)
	case sentinelappbinary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sentinelappbinary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sentinelappbinary.FieldAppBinaryReportSequence:
		return m.OldAppBinaryReportSequence(ctx)
	}
	return nil, fmt.Errorf("unknown SentinelAppBinary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SentinelAppBinaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sentinelappbinary.FieldSentinelInfoID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentinelInfoID(v)
		return nil
	case sentinelappbinary.FieldSentinelLibraryReportedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentinelLibraryReportedID(v)
		return nil
	case sentinelappbinary.FieldGeneratedID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeneratedID(v)
		return nil
	case sentinelappbinary.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case sentinelappbinary.FieldNeedToken:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedToken(v)
		return nil
	case sentinelappbinary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sentinelappbinary.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case sentinelappbinary.FieldDeveloper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeveloper(v)
		return nil
	case sentinelappbinary.FieldPublisher:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublisher(v)
		return nil
	case sentinelappbinary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sentinelappbinary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sentinelappbinary.FieldAppBinaryReportSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppBinaryReportSequence(v)
		return nil
	}
	return fmt.Errorf("unknown SentinelAppBinary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SentinelAppBinaryMutation) AddedFields() []string {
	var fields []string
	if m.addsentinel_info_id != nil {
		fields = append(fields, sentinelappbinary.FieldSentinelInfoID)
	}
	if m.addsentinel_library_reported_id != nil {
		fields = append(fields, sentinelappbinary.FieldSentinelLibraryReportedID)
	}
	if m.addsize_bytes != nil {
		fields = append(fields, sentinelappbinary.FieldSizeBytes)
	}
	if m.addapp_binary_report_sequence != nil {
		fields = append(fields, sentinelappbinary.FieldAppBinaryReportSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SentinelAppBinaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sentinelappbinary.FieldSentinelInfoID:
		return m.AddedSentinelInfoID()
	case sentinelappbinary.FieldSentinelLibraryReportedID:
		return m.AddedSentinelLibraryReportedID()
	case sentinelappbinary.FieldSizeBytes:
		return m.AddedSizeBytes()
	case sentinelappbinary.FieldAppBinaryReportSequence:
		return m.AddedAppBinaryReportSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SentinelAppBinaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sentinelappbinary.FieldSentinelInfoID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSentinelInfoID(v)
		return nil
	case sentinelappbinary.FieldSentinelLibraryReportedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSentinelLibraryReportedID(v)
		return nil
	case sentinelappbinary.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	case sentinelappbinary.FieldAppBinaryReportSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppBinaryReportSequence(v)
		return nil
	}
	return fmt.Errorf("unknown SentinelAppBinary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SentinelAppBinaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sentinelappbinary.FieldName) {
		fields = append(fields, sentinelappbinary.FieldName)
	}
	if m.FieldCleared(sentinelappbinary.FieldVersion) {
		fields = append(fields, sentinelappbinary.FieldVersion)
	}
	if m.FieldCleared(sentinelappbinary.FieldDeveloper) {
		fields = append(fields, sentinelappbinary.FieldDeveloper)
	}
	if m.FieldCleared(sentinelappbinary.FieldPublisher) {
		fields = append(fields, sentinelappbinary.FieldPublisher)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SentinelAppBinaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SentinelAppBinaryMutation) ClearField(name string) error {
	switch name {
	case sentinelappbinary.FieldName:
		m.ClearName()
		return nil
	case sentinelappbinary.FieldVersion:
		m.ClearVersion()
		return nil
	case sentinelappbinary.FieldDeveloper:
		m.ClearDeveloper()
		return nil
	case sentinelappbinary.FieldPublisher:
		m.ClearPublisher()
		return nil
	}
	return fmt.Errorf("unknown SentinelAppBinary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SentinelAppBinaryMutation) ResetField(name string) error {
	switch name {
	case sentinelappbinary.FieldSentinelInfoID:
		m.ResetSentinelInfoID()
		return nil
	case sentinelappbinary.FieldSentinelLibraryReportedID:
		m.ResetSentinelLibraryReportedID()
		return nil
	case sentinelappbinary.FieldGeneratedID:
		m.ResetGeneratedID()
		return nil
	case sentinelappbinary.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case sentinelappbinary.FieldNeedToken:
		m.ResetNeedToken()
		return nil
	case sentinelappbinary.FieldName:
		m.ResetName()
		return nil
	case sentinelappbinary.FieldVersion:
		m.ResetVersion()
		return nil
	case sentinelappbinary.FieldDeveloper:
		m.ResetDeveloper()
		return nil
	case sentinelappbinary.FieldPublisher:
		m.ResetPublisher()
		return nil
	case sentinelappbinary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sentinelappbinary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sentinelappbinary.FieldAppBinaryReportSequence:
		m.ResetAppBinaryReportSequence()
		return nil
	}
	return fmt.Errorf("unknown SentinelAppBinary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SentinelAppBinaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SentinelAppBinaryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SentinelAppBinaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SentinelAppBinaryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SentinelAppBinaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SentinelAppBinaryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SentinelAppBinaryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SentinelAppBinary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SentinelAppBinaryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SentinelAppBinary edge %s", name)
}

// SentinelAppBinaryFileMutation represents an operation that mutates the SentinelAppBinaryFile nodes in the graph.
type SentinelAppBinaryFileMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	sentinel_info_id                 *model.InternalID
	addsentinel_info_id              *model.InternalID
	sentinel_library_reported_id     *int64
	addsentinel_library_reported_id  *int64
	sentinel_app_binary_generated_id *string
	name                             *string
	size_bytes                       *int64
	addsize_bytes                    *int64
	sha256                           *[]byte
	server_file_path                 *string
	chunks_info                      *string
	updated_at                       *time.Time
	created_at                       *time.Time
	app_binary_report_sequence       *int64
	addapp_binary_report_sequence    *int64
	clearedFields                    map[string]struct{}
	done                             bool
	oldValue                         func(context.Context) (*SentinelAppBinaryFile, error)
	predicates                       []predicate.SentinelAppBinaryFile
}

var _ ent.Mutation = (*SentinelAppBinaryFileMutation)(nil)

// sentinelappbinaryfileOption allows management of the mutation configuration using functional options.
type sentinelappbinaryfileOption func(*SentinelAppBinaryFileMutation)

// newSentinelAppBinaryFileMutation creates new mutation for the SentinelAppBinaryFile entity.
func newSentinelAppBinaryFileMutation(c config, op Op, opts ...sentinelappbinaryfileOption) *SentinelAppBinaryFileMutation {
	m := &SentinelAppBinaryFileMutation{
		config:        c,
		op:            op,
		typ:           TypeSentinelAppBinaryFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSentinelAppBinaryFileID sets the ID field of the mutation.
func withSentinelAppBinaryFileID(id int) sentinelappbinaryfileOption {
	return func(m *SentinelAppBinaryFileMutation) {
		var (
			err   error
			once  sync.Once
			value *SentinelAppBinaryFile
		)
		m.oldValue = func(ctx context.Context) (*SentinelAppBinaryFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SentinelAppBinaryFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSentinelAppBinaryFile sets the old SentinelAppBinaryFile of the mutation.
func withSentinelAppBinaryFile(node *SentinelAppBinaryFile) sentinelappbinaryfileOption {
	return func(m *SentinelAppBinaryFileMutation) {
		m.oldValue = func(context.Context) (*SentinelAppBinaryFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SentinelAppBinaryFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SentinelAppBinaryFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SentinelAppBinaryFileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SentinelAppBinaryFileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SentinelAppBinaryFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSentinelInfoID sets the "sentinel_info_id" field.
func (m *SentinelAppBinaryFileMutation) SetSentinelInfoID(mi model.InternalID) {
	m.sentinel_info_id = &mi
	m.addsentinel_info_id = nil
}

// SentinelInfoID returns the value of the "sentinel_info_id" field in the mutation.
func (m *SentinelAppBinaryFileMutation) SentinelInfoID() (r model.InternalID, exists bool) {
	v := m.sentinel_info_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSentinelInfoID returns the old "sentinel_info_id" field's value of the SentinelAppBinaryFile entity.
// If the SentinelAppBinaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryFileMutation) OldSentinelInfoID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentinelInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentinelInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentinelInfoID: %w", err)
	}
	return oldValue.SentinelInfoID, nil
}

// AddSentinelInfoID adds mi to the "sentinel_info_id" field.
func (m *SentinelAppBinaryFileMutation) AddSentinelInfoID(mi model.InternalID) {
	if m.addsentinel_info_id != nil {
		*m.addsentinel_info_id += mi
	} else {
		m.addsentinel_info_id = &mi
	}
}

// AddedSentinelInfoID returns the value that was added to the "sentinel_info_id" field in this mutation.
func (m *SentinelAppBinaryFileMutation) AddedSentinelInfoID() (r model.InternalID, exists bool) {
	v := m.addsentinel_info_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSentinelInfoID resets all changes to the "sentinel_info_id" field.
func (m *SentinelAppBinaryFileMutation) ResetSentinelInfoID() {
	m.sentinel_info_id = nil
	m.addsentinel_info_id = nil
}

// SetSentinelLibraryReportedID sets the "sentinel_library_reported_id" field.
func (m *SentinelAppBinaryFileMutation) SetSentinelLibraryReportedID(i int64) {
	m.sentinel_library_reported_id = &i
	m.addsentinel_library_reported_id = nil
}

// SentinelLibraryReportedID returns the value of the "sentinel_library_reported_id" field in the mutation.
func (m *SentinelAppBinaryFileMutation) SentinelLibraryReportedID() (r int64, exists bool) {
	v := m.sentinel_library_reported_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSentinelLibraryReportedID returns the old "sentinel_library_reported_id" field's value of the SentinelAppBinaryFile entity.
// If the SentinelAppBinaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryFileMutation) OldSentinelLibraryReportedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentinelLibraryReportedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentinelLibraryReportedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentinelLibraryReportedID: %w", err)
	}
	return oldValue.SentinelLibraryReportedID, nil
}

// AddSentinelLibraryReportedID adds i to the "sentinel_library_reported_id" field.
func (m *SentinelAppBinaryFileMutation) AddSentinelLibraryReportedID(i int64) {
	if m.addsentinel_library_reported_id != nil {
		*m.addsentinel_library_reported_id += i
	} else {
		m.addsentinel_library_reported_id = &i
	}
}

// AddedSentinelLibraryReportedID returns the value that was added to the "sentinel_library_reported_id" field in this mutation.
func (m *SentinelAppBinaryFileMutation) AddedSentinelLibraryReportedID() (r int64, exists bool) {
	v := m.addsentinel_library_reported_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSentinelLibraryReportedID resets all changes to the "sentinel_library_reported_id" field.
func (m *SentinelAppBinaryFileMutation) ResetSentinelLibraryReportedID() {
	m.sentinel_library_reported_id = nil
	m.addsentinel_library_reported_id = nil
}

// SetSentinelAppBinaryGeneratedID sets the "sentinel_app_binary_generated_id" field.
func (m *SentinelAppBinaryFileMutation) SetSentinelAppBinaryGeneratedID(s string) {
	m.sentinel_app_binary_generated_id = &s
}

// SentinelAppBinaryGeneratedID returns the value of the "sentinel_app_binary_generated_id" field in the mutation.
func (m *SentinelAppBinaryFileMutation) SentinelAppBinaryGeneratedID() (r string, exists bool) {
	v := m.sentinel_app_binary_generated_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSentinelAppBinaryGeneratedID returns the old "sentinel_app_binary_generated_id" field's value of the SentinelAppBinaryFile entity.
// If the SentinelAppBinaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryFileMutation) OldSentinelAppBinaryGeneratedID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentinelAppBinaryGeneratedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentinelAppBinaryGeneratedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentinelAppBinaryGeneratedID: %w", err)
	}
	return oldValue.SentinelAppBinaryGeneratedID, nil
}

// ResetSentinelAppBinaryGeneratedID resets all changes to the "sentinel_app_binary_generated_id" field.
func (m *SentinelAppBinaryFileMutation) ResetSentinelAppBinaryGeneratedID() {
	m.sentinel_app_binary_generated_id = nil
}

// SetName sets the "name" field.
func (m *SentinelAppBinaryFileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SentinelAppBinaryFileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SentinelAppBinaryFile entity.
// If the SentinelAppBinaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryFileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SentinelAppBinaryFileMutation) ResetName() {
	m.name = nil
}

// SetSizeBytes sets the "size_bytes" field.
func (m *SentinelAppBinaryFileMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *SentinelAppBinaryFileMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the SentinelAppBinaryFile entity.
// If the SentinelAppBinaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryFileMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *SentinelAppBinaryFileMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *SentinelAppBinaryFileMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *SentinelAppBinaryFileMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
}

// SetSha256 sets the "sha256" field.
func (m *SentinelAppBinaryFileMutation) SetSha256(b []byte) {
	m.sha256 = &b
}

// Sha256 returns the value of the "sha256" field in the mutation.
func (m *SentinelAppBinaryFileMutation) Sha256() (r []byte, exists bool) {
	v := m.sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldSha256 returns the old "sha256" field's value of the SentinelAppBinaryFile entity.
// If the SentinelAppBinaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryFileMutation) OldSha256(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha256: %w", err)
	}
	return oldValue.Sha256, nil
}

// ResetSha256 resets all changes to the "sha256" field.
func (m *SentinelAppBinaryFileMutation) ResetSha256() {
	m.sha256 = nil
}

// SetServerFilePath sets the "server_file_path" field.
func (m *SentinelAppBinaryFileMutation) SetServerFilePath(s string) {
	m.server_file_path = &s
}

// ServerFilePath returns the value of the "server_file_path" field in the mutation.
func (m *SentinelAppBinaryFileMutation) ServerFilePath() (r string, exists bool) {
	v := m.server_file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldServerFilePath returns the old "server_file_path" field's value of the SentinelAppBinaryFile entity.
// If the SentinelAppBinaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryFileMutation) OldServerFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServerFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServerFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServerFilePath: %w", err)
	}
	return oldValue.ServerFilePath, nil
}

// ResetServerFilePath resets all changes to the "server_file_path" field.
func (m *SentinelAppBinaryFileMutation) ResetServerFilePath() {
	m.server_file_path = nil
}

// SetChunksInfo sets the "chunks_info" field.
func (m *SentinelAppBinaryFileMutation) SetChunksInfo(s string) {
	m.chunks_info = &s
}

// ChunksInfo returns the value of the "chunks_info" field in the mutation.
func (m *SentinelAppBinaryFileMutation) ChunksInfo() (r string, exists bool) {
	v := m.chunks_info
	if v == nil {
		return
	}
	return *v, true
}

// OldChunksInfo returns the old "chunks_info" field's value of the SentinelAppBinaryFile entity.
// If the SentinelAppBinaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryFileMutation) OldChunksInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChunksInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChunksInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChunksInfo: %w", err)
	}
	return oldValue.ChunksInfo, nil
}

// ClearChunksInfo clears the value of the "chunks_info" field.
func (m *SentinelAppBinaryFileMutation) ClearChunksInfo() {
	m.chunks_info = nil
	m.clearedFields[sentinelappbinaryfile.FieldChunksInfo] = struct{}{}
}

// ChunksInfoCleared returns if the "chunks_info" field was cleared in this mutation.
func (m *SentinelAppBinaryFileMutation) ChunksInfoCleared() bool {
	_, ok := m.clearedFields[sentinelappbinaryfile.FieldChunksInfo]
	return ok
}

// ResetChunksInfo resets all changes to the "chunks_info" field.
func (m *SentinelAppBinaryFileMutation) ResetChunksInfo() {
	m.chunks_info = nil
	delete(m.clearedFields, sentinelappbinaryfile.FieldChunksInfo)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SentinelAppBinaryFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SentinelAppBinaryFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SentinelAppBinaryFile entity.
// If the SentinelAppBinaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SentinelAppBinaryFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SentinelAppBinaryFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SentinelAppBinaryFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SentinelAppBinaryFile entity.
// If the SentinelAppBinaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SentinelAppBinaryFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAppBinaryReportSequence sets the "app_binary_report_sequence" field.
func (m *SentinelAppBinaryFileMutation) SetAppBinaryReportSequence(i int64) {
	m.app_binary_report_sequence = &i
	m.addapp_binary_report_sequence = nil
}

// AppBinaryReportSequence returns the value of the "app_binary_report_sequence" field in the mutation.
func (m *SentinelAppBinaryFileMutation) AppBinaryReportSequence() (r int64, exists bool) {
	v := m.app_binary_report_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldAppBinaryReportSequence returns the old "app_binary_report_sequence" field's value of the SentinelAppBinaryFile entity.
// If the SentinelAppBinaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelAppBinaryFileMutation) OldAppBinaryReportSequence(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppBinaryReportSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppBinaryReportSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppBinaryReportSequence: %w", err)
	}
	return oldValue.AppBinaryReportSequence, nil
}

// AddAppBinaryReportSequence adds i to the "app_binary_report_sequence" field.
func (m *SentinelAppBinaryFileMutation) AddAppBinaryReportSequence(i int64) {
	if m.addapp_binary_report_sequence != nil {
		*m.addapp_binary_report_sequence += i
	} else {
		m.addapp_binary_report_sequence = &i
	}
}

// AddedAppBinaryReportSequence returns the value that was added to the "app_binary_report_sequence" field in this mutation.
func (m *SentinelAppBinaryFileMutation) AddedAppBinaryReportSequence() (r int64, exists bool) {
	v := m.addapp_binary_report_sequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppBinaryReportSequence resets all changes to the "app_binary_report_sequence" field.
func (m *SentinelAppBinaryFileMutation) ResetAppBinaryReportSequence() {
	m.app_binary_report_sequence = nil
	m.addapp_binary_report_sequence = nil
}

// Where appends a list predicates to the SentinelAppBinaryFileMutation builder.
func (m *SentinelAppBinaryFileMutation) Where(ps ...predicate.SentinelAppBinaryFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SentinelAppBinaryFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SentinelAppBinaryFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SentinelAppBinaryFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SentinelAppBinaryFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SentinelAppBinaryFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SentinelAppBinaryFile).
func (m *SentinelAppBinaryFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SentinelAppBinaryFileMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.sentinel_info_id != nil {
		fields = append(fields, sentinelappbinaryfile.FieldSentinelInfoID)
	}
	if m.sentinel_library_reported_id != nil {
		fields = append(fields, sentinelappbinaryfile.FieldSentinelLibraryReportedID)
	}
	if m.sentinel_app_binary_generated_id != nil {
		fields = append(fields, sentinelappbinaryfile.FieldSentinelAppBinaryGeneratedID)
	}
	if m.name != nil {
		fields = append(fields, sentinelappbinaryfile.FieldName)
	}
	if m.size_bytes != nil {
		fields = append(fields, sentinelappbinaryfile.FieldSizeBytes)
	}
	if m.sha256 != nil {
		fields = append(fields, sentinelappbinaryfile.FieldSha256)
	}
	if m.server_file_path != nil {
		fields = append(fields, sentinelappbinaryfile.FieldServerFilePath)
	}
	if m.chunks_info != nil {
		fields = append(fields, sentinelappbinaryfile.FieldChunksInfo)
	}
	if m.updated_at != nil {
		fields = append(fields, sentinelappbinaryfile.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, sentinelappbinaryfile.FieldCreatedAt)
	}
	if m.app_binary_report_sequence != nil {
		fields = append(fields, sentinelappbinaryfile.FieldAppBinaryReportSequence)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SentinelAppBinaryFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sentinelappbinaryfile.FieldSentinelInfoID:
		return m.SentinelInfoID()
	case sentinelappbinaryfile.FieldSentinelLibraryReportedID:
		return m.SentinelLibraryReportedID()
	case sentinelappbinaryfile.FieldSentinelAppBinaryGeneratedID:
		return m.SentinelAppBinaryGeneratedID()
	case sentinelappbinaryfile.FieldName:
		return m.Name()
	case sentinelappbinaryfile.FieldSizeBytes:
		return m.SizeBytes()
	case sentinelappbinaryfile.FieldSha256:
		return m.Sha256()
	case sentinelappbinaryfile.FieldServerFilePath:
		return m.ServerFilePath()
	case sentinelappbinaryfile.FieldChunksInfo:
		return m.ChunksInfo()
	case sentinelappbinaryfile.FieldUpdatedAt:
		return m.UpdatedAt()
	case sentinelappbinaryfile.FieldCreatedAt:
		return m.CreatedAt()
	case sentinelappbinaryfile.FieldAppBinaryReportSequence:
		return m.AppBinaryReportSequence()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SentinelAppBinaryFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sentinelappbinaryfile.FieldSentinelInfoID:
		return m.OldSentinelInfoID(ctx)
	case sentinelappbinaryfile.FieldSentinelLibraryReportedID:
		return m.OldSentinelLibraryReportedID(ctx)
	case sentinelappbinaryfile.FieldSentinelAppBinaryGeneratedID:
		return m.OldSentinelAppBinaryGeneratedID(ctx)
	case sentinelappbinaryfile.FieldName:
		return m.OldName(ctx)
	case sentinelappbinaryfile.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case sentinelappbinaryfile.FieldSha256:
		return m.OldSha256(ctx)
	case sentinelappbinaryfile.FieldServerFilePath:
		return m.OldServerFilePath(ctx)
	case sentinelappbinaryfile.FieldChunksInfo:
		return m.OldChunksInfo(ctx)
	case sentinelappbinaryfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sentinelappbinaryfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sentinelappbinaryfile.FieldAppBinaryReportSequence:
		return m.OldAppBinaryReportSequence(ctx)
	}
	return nil, fmt.Errorf("unknown SentinelAppBinaryFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SentinelAppBinaryFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sentinelappbinaryfile.FieldSentinelInfoID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentinelInfoID(v)
		return nil
	case sentinelappbinaryfile.FieldSentinelLibraryReportedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentinelLibraryReportedID(v)
		return nil
	case sentinelappbinaryfile.FieldSentinelAppBinaryGeneratedID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentinelAppBinaryGeneratedID(v)
		return nil
	case sentinelappbinaryfile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sentinelappbinaryfile.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case sentinelappbinaryfile.FieldSha256:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha256(v)
		return nil
	case sentinelappbinaryfile.FieldServerFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServerFilePath(v)
		return nil
	case sentinelappbinaryfile.FieldChunksInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChunksInfo(v)
		return nil
	case sentinelappbinaryfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sentinelappbinaryfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sentinelappbinaryfile.FieldAppBinaryReportSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppBinaryReportSequence(v)
		return nil
	}
	return fmt.Errorf("unknown SentinelAppBinaryFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SentinelAppBinaryFileMutation) AddedFields() []string {
	var fields []string
	if m.addsentinel_info_id != nil {
		fields = append(fields, sentinelappbinaryfile.FieldSentinelInfoID)
	}
	if m.addsentinel_library_reported_id != nil {
		fields = append(fields, sentinelappbinaryfile.FieldSentinelLibraryReportedID)
	}
	if m.addsize_bytes != nil {
		fields = append(fields, sentinelappbinaryfile.FieldSizeBytes)
	}
	if m.addapp_binary_report_sequence != nil {
		fields = append(fields, sentinelappbinaryfile.FieldAppBinaryReportSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SentinelAppBinaryFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sentinelappbinaryfile.FieldSentinelInfoID:
		return m.AddedSentinelInfoID()
	case sentinelappbinaryfile.FieldSentinelLibraryReportedID:
		return m.AddedSentinelLibraryReportedID()
	case sentinelappbinaryfile.FieldSizeBytes:
		return m.AddedSizeBytes()
	case sentinelappbinaryfile.FieldAppBinaryReportSequence:
		return m.AddedAppBinaryReportSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SentinelAppBinaryFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sentinelappbinaryfile.FieldSentinelInfoID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSentinelInfoID(v)
		return nil
	case sentinelappbinaryfile.FieldSentinelLibraryReportedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSentinelLibraryReportedID(v)
		return nil
	case sentinelappbinaryfile.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	case sentinelappbinaryfile.FieldAppBinaryReportSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppBinaryReportSequence(v)
		return nil
	}
	return fmt.Errorf("unknown SentinelAppBinaryFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SentinelAppBinaryFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sentinelappbinaryfile.FieldChunksInfo) {
		fields = append(fields, sentinelappbinaryfile.FieldChunksInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SentinelAppBinaryFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SentinelAppBinaryFileMutation) ClearField(name string) error {
	switch name {
	case sentinelappbinaryfile.FieldChunksInfo:
		m.ClearChunksInfo()
		return nil
	}
	return fmt.Errorf("unknown SentinelAppBinaryFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SentinelAppBinaryFileMutation) ResetField(name string) error {
	switch name {
	case sentinelappbinaryfile.FieldSentinelInfoID:
		m.ResetSentinelInfoID()
		return nil
	case sentinelappbinaryfile.FieldSentinelLibraryReportedID:
		m.ResetSentinelLibraryReportedID()
		return nil
	case sentinelappbinaryfile.FieldSentinelAppBinaryGeneratedID:
		m.ResetSentinelAppBinaryGeneratedID()
		return nil
	case sentinelappbinaryfile.FieldName:
		m.ResetName()
		return nil
	case sentinelappbinaryfile.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case sentinelappbinaryfile.FieldSha256:
		m.ResetSha256()
		return nil
	case sentinelappbinaryfile.FieldServerFilePath:
		m.ResetServerFilePath()
		return nil
	case sentinelappbinaryfile.FieldChunksInfo:
		m.ResetChunksInfo()
		return nil
	case sentinelappbinaryfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sentinelappbinaryfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sentinelappbinaryfile.FieldAppBinaryReportSequence:
		m.ResetAppBinaryReportSequence()
		return nil
	}
	return fmt.Errorf("unknown SentinelAppBinaryFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SentinelAppBinaryFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SentinelAppBinaryFileMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SentinelAppBinaryFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SentinelAppBinaryFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SentinelAppBinaryFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SentinelAppBinaryFileMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SentinelAppBinaryFileMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SentinelAppBinaryFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SentinelAppBinaryFileMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SentinelAppBinaryFile edge %s", name)
}

// SentinelInfoMutation represents an operation that mutates the SentinelInfo nodes in the graph.
type SentinelInfoMutation struct {
	config
	op                            Op
	typ                           string
	id                            *model.InternalID
	url                           *string
	alternative_urls              *[]string
	appendalternative_urls        []string
	get_token_path                *string
	download_file_base_path       *string
	updated_at                    *time.Time
	created_at                    *time.Time
	library_report_sequence       *int64
	addlibrary_report_sequence    *int64
	app_binary_report_sequence    *int64
	addapp_binary_report_sequence *int64
	clearedFields                 map[string]struct{}
	sentinel_library              map[int]struct{}
	removedsentinel_library       map[int]struct{}
	clearedsentinel_library       bool
	done                          bool
	oldValue                      func(context.Context) (*SentinelInfo, error)
	predicates                    []predicate.SentinelInfo
}

var _ ent.Mutation = (*SentinelInfoMutation)(nil)

// sentinelinfoOption allows management of the mutation configuration using functional options.
type sentinelinfoOption func(*SentinelInfoMutation)

// newSentinelInfoMutation creates new mutation for the SentinelInfo entity.
func newSentinelInfoMutation(c config, op Op, opts ...sentinelinfoOption) *SentinelInfoMutation {
	m := &SentinelInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeSentinelInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSentinelInfoID sets the ID field of the mutation.
func withSentinelInfoID(id model.InternalID) sentinelinfoOption {
	return func(m *SentinelInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *SentinelInfo
		)
		m.oldValue = func(ctx context.Context) (*SentinelInfo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SentinelInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSentinelInfo sets the old SentinelInfo of the mutation.
func withSentinelInfo(node *SentinelInfo) sentinelinfoOption {
	return func(m *SentinelInfoMutation) {
		m.oldValue = func(context.Context) (*SentinelInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SentinelInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SentinelInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SentinelInfo entities.
func (m *SentinelInfoMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SentinelInfoMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SentinelInfoMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SentinelInfo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *SentinelInfoMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *SentinelInfoMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the SentinelInfo entity.
// If the SentinelInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelInfoMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *SentinelInfoMutation) ResetURL() {
	m.url = nil
}

// SetAlternativeUrls sets the "alternative_urls" field.
func (m *SentinelInfoMutation) SetAlternativeUrls(s []string) {
	m.alternative_urls = &s
	m.appendalternative_urls = nil
}

// AlternativeUrls returns the value of the "alternative_urls" field in the mutation.
func (m *SentinelInfoMutation) AlternativeUrls() (r []string, exists bool) {
	v := m.alternative_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldAlternativeUrls returns the old "alternative_urls" field's value of the SentinelInfo entity.
// If the SentinelInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelInfoMutation) OldAlternativeUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlternativeUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlternativeUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlternativeUrls: %w", err)
	}
	return oldValue.AlternativeUrls, nil
}

// AppendAlternativeUrls adds s to the "alternative_urls" field.
func (m *SentinelInfoMutation) AppendAlternativeUrls(s []string) {
	m.appendalternative_urls = append(m.appendalternative_urls, s...)
}

// AppendedAlternativeUrls returns the list of values that were appended to the "alternative_urls" field in this mutation.
func (m *SentinelInfoMutation) AppendedAlternativeUrls() ([]string, bool) {
	if len(m.appendalternative_urls) == 0 {
		return nil, false
	}
	return m.appendalternative_urls, true
}

// ClearAlternativeUrls clears the value of the "alternative_urls" field.
func (m *SentinelInfoMutation) ClearAlternativeUrls() {
	m.alternative_urls = nil
	m.appendalternative_urls = nil
	m.clearedFields[sentinelinfo.FieldAlternativeUrls] = struct{}{}
}

// AlternativeUrlsCleared returns if the "alternative_urls" field was cleared in this mutation.
func (m *SentinelInfoMutation) AlternativeUrlsCleared() bool {
	_, ok := m.clearedFields[sentinelinfo.FieldAlternativeUrls]
	return ok
}

// ResetAlternativeUrls resets all changes to the "alternative_urls" field.
func (m *SentinelInfoMutation) ResetAlternativeUrls() {
	m.alternative_urls = nil
	m.appendalternative_urls = nil
	delete(m.clearedFields, sentinelinfo.FieldAlternativeUrls)
}

// SetGetTokenPath sets the "get_token_path" field.
func (m *SentinelInfoMutation) SetGetTokenPath(s string) {
	m.get_token_path = &s
}

// GetTokenPath returns the value of the "get_token_path" field in the mutation.
func (m *SentinelInfoMutation) GetTokenPath() (r string, exists bool) {
	v := m.get_token_path
	if v == nil {
		return
	}
	return *v, true
}

// OldGetTokenPath returns the old "get_token_path" field's value of the SentinelInfo entity.
// If the SentinelInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelInfoMutation) OldGetTokenPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGetTokenPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGetTokenPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGetTokenPath: %w", err)
	}
	return oldValue.GetTokenPath, nil
}

// ClearGetTokenPath clears the value of the "get_token_path" field.
func (m *SentinelInfoMutation) ClearGetTokenPath() {
	m.get_token_path = nil
	m.clearedFields[sentinelinfo.FieldGetTokenPath] = struct{}{}
}

// GetTokenPathCleared returns if the "get_token_path" field was cleared in this mutation.
func (m *SentinelInfoMutation) GetTokenPathCleared() bool {
	_, ok := m.clearedFields[sentinelinfo.FieldGetTokenPath]
	return ok
}

// ResetGetTokenPath resets all changes to the "get_token_path" field.
func (m *SentinelInfoMutation) ResetGetTokenPath() {
	m.get_token_path = nil
	delete(m.clearedFields, sentinelinfo.FieldGetTokenPath)
}

// SetDownloadFileBasePath sets the "download_file_base_path" field.
func (m *SentinelInfoMutation) SetDownloadFileBasePath(s string) {
	m.download_file_base_path = &s
}

// DownloadFileBasePath returns the value of the "download_file_base_path" field in the mutation.
func (m *SentinelInfoMutation) DownloadFileBasePath() (r string, exists bool) {
	v := m.download_file_base_path
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadFileBasePath returns the old "download_file_base_path" field's value of the SentinelInfo entity.
// If the SentinelInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelInfoMutation) OldDownloadFileBasePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadFileBasePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadFileBasePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadFileBasePath: %w", err)
	}
	return oldValue.DownloadFileBasePath, nil
}

// ResetDownloadFileBasePath resets all changes to the "download_file_base_path" field.
func (m *SentinelInfoMutation) ResetDownloadFileBasePath() {
	m.download_file_base_path = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SentinelInfoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SentinelInfoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SentinelInfo entity.
// If the SentinelInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelInfoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SentinelInfoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SentinelInfoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SentinelInfoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SentinelInfo entity.
// If the SentinelInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelInfoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SentinelInfoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLibraryReportSequence sets the "library_report_sequence" field.
func (m *SentinelInfoMutation) SetLibraryReportSequence(i int64) {
	m.library_report_sequence = &i
	m.addlibrary_report_sequence = nil
}

// LibraryReportSequence returns the value of the "library_report_sequence" field in the mutation.
func (m *SentinelInfoMutation) LibraryReportSequence() (r int64, exists bool) {
	v := m.library_report_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldLibraryReportSequence returns the old "library_report_sequence" field's value of the SentinelInfo entity.
// If the SentinelInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelInfoMutation) OldLibraryReportSequence(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLibraryReportSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLibraryReportSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLibraryReportSequence: %w", err)
	}
	return oldValue.LibraryReportSequence, nil
}

// AddLibraryReportSequence adds i to the "library_report_sequence" field.
func (m *SentinelInfoMutation) AddLibraryReportSequence(i int64) {
	if m.addlibrary_report_sequence != nil {
		*m.addlibrary_report_sequence += i
	} else {
		m.addlibrary_report_sequence = &i
	}
}

// AddedLibraryReportSequence returns the value that was added to the "library_report_sequence" field in this mutation.
func (m *SentinelInfoMutation) AddedLibraryReportSequence() (r int64, exists bool) {
	v := m.addlibrary_report_sequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetLibraryReportSequence resets all changes to the "library_report_sequence" field.
func (m *SentinelInfoMutation) ResetLibraryReportSequence() {
	m.library_report_sequence = nil
	m.addlibrary_report_sequence = nil
}

// SetAppBinaryReportSequence sets the "app_binary_report_sequence" field.
func (m *SentinelInfoMutation) SetAppBinaryReportSequence(i int64) {
	m.app_binary_report_sequence = &i
	m.addapp_binary_report_sequence = nil
}

// AppBinaryReportSequence returns the value of the "app_binary_report_sequence" field in the mutation.
func (m *SentinelInfoMutation) AppBinaryReportSequence() (r int64, exists bool) {
	v := m.app_binary_report_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldAppBinaryReportSequence returns the old "app_binary_report_sequence" field's value of the SentinelInfo entity.
// If the SentinelInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelInfoMutation) OldAppBinaryReportSequence(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppBinaryReportSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppBinaryReportSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppBinaryReportSequence: %w", err)
	}
	return oldValue.AppBinaryReportSequence, nil
}

// AddAppBinaryReportSequence adds i to the "app_binary_report_sequence" field.
func (m *SentinelInfoMutation) AddAppBinaryReportSequence(i int64) {
	if m.addapp_binary_report_sequence != nil {
		*m.addapp_binary_report_sequence += i
	} else {
		m.addapp_binary_report_sequence = &i
	}
}

// AddedAppBinaryReportSequence returns the value that was added to the "app_binary_report_sequence" field in this mutation.
func (m *SentinelInfoMutation) AddedAppBinaryReportSequence() (r int64, exists bool) {
	v := m.addapp_binary_report_sequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetAppBinaryReportSequence resets all changes to the "app_binary_report_sequence" field.
func (m *SentinelInfoMutation) ResetAppBinaryReportSequence() {
	m.app_binary_report_sequence = nil
	m.addapp_binary_report_sequence = nil
}

// AddSentinelLibraryIDs adds the "sentinel_library" edge to the SentinelLibrary entity by ids.
func (m *SentinelInfoMutation) AddSentinelLibraryIDs(ids ...int) {
	if m.sentinel_library == nil {
		m.sentinel_library = make(map[int]struct{})
	}
	for i := range ids {
		m.sentinel_library[ids[i]] = struct{}{}
	}
}

// ClearSentinelLibrary clears the "sentinel_library" edge to the SentinelLibrary entity.
func (m *SentinelInfoMutation) ClearSentinelLibrary() {
	m.clearedsentinel_library = true
}

// SentinelLibraryCleared reports if the "sentinel_library" edge to the SentinelLibrary entity was cleared.
func (m *SentinelInfoMutation) SentinelLibraryCleared() bool {
	return m.clearedsentinel_library
}

// RemoveSentinelLibraryIDs removes the "sentinel_library" edge to the SentinelLibrary entity by IDs.
func (m *SentinelInfoMutation) RemoveSentinelLibraryIDs(ids ...int) {
	if m.removedsentinel_library == nil {
		m.removedsentinel_library = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sentinel_library, ids[i])
		m.removedsentinel_library[ids[i]] = struct{}{}
	}
}

// RemovedSentinelLibrary returns the removed IDs of the "sentinel_library" edge to the SentinelLibrary entity.
func (m *SentinelInfoMutation) RemovedSentinelLibraryIDs() (ids []int) {
	for id := range m.removedsentinel_library {
		ids = append(ids, id)
	}
	return
}

// SentinelLibraryIDs returns the "sentinel_library" edge IDs in the mutation.
func (m *SentinelInfoMutation) SentinelLibraryIDs() (ids []int) {
	for id := range m.sentinel_library {
		ids = append(ids, id)
	}
	return
}

// ResetSentinelLibrary resets all changes to the "sentinel_library" edge.
func (m *SentinelInfoMutation) ResetSentinelLibrary() {
	m.sentinel_library = nil
	m.clearedsentinel_library = false
	m.removedsentinel_library = nil
}

// Where appends a list predicates to the SentinelInfoMutation builder.
func (m *SentinelInfoMutation) Where(ps ...predicate.SentinelInfo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SentinelInfoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SentinelInfoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SentinelInfo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SentinelInfoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SentinelInfoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SentinelInfo).
func (m *SentinelInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SentinelInfoMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.url != nil {
		fields = append(fields, sentinelinfo.FieldURL)
	}
	if m.alternative_urls != nil {
		fields = append(fields, sentinelinfo.FieldAlternativeUrls)
	}
	if m.get_token_path != nil {
		fields = append(fields, sentinelinfo.FieldGetTokenPath)
	}
	if m.download_file_base_path != nil {
		fields = append(fields, sentinelinfo.FieldDownloadFileBasePath)
	}
	if m.updated_at != nil {
		fields = append(fields, sentinelinfo.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, sentinelinfo.FieldCreatedAt)
	}
	if m.library_report_sequence != nil {
		fields = append(fields, sentinelinfo.FieldLibraryReportSequence)
	}
	if m.app_binary_report_sequence != nil {
		fields = append(fields, sentinelinfo.FieldAppBinaryReportSequence)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SentinelInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sentinelinfo.FieldURL:
		return m.URL()
	case sentinelinfo.FieldAlternativeUrls:
		return m.AlternativeUrls()
	case sentinelinfo.FieldGetTokenPath:
		return m.GetTokenPath()
	case sentinelinfo.FieldDownloadFileBasePath:
		return m.DownloadFileBasePath()
	case sentinelinfo.FieldUpdatedAt:
		return m.UpdatedAt()
	case sentinelinfo.FieldCreatedAt:
		return m.CreatedAt()
	case sentinelinfo.FieldLibraryReportSequence:
		return m.LibraryReportSequence()
	case sentinelinfo.FieldAppBinaryReportSequence:
		return m.AppBinaryReportSequence()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SentinelInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sentinelinfo.FieldURL:
		return m.OldURL(ctx)
	case sentinelinfo.FieldAlternativeUrls:
		return m.OldAlternativeUrls(ctx)
	case sentinelinfo.FieldGetTokenPath:
		return m.OldGetTokenPath(ctx)
	case sentinelinfo.FieldDownloadFileBasePath:
		return m.OldDownloadFileBasePath(ctx)
	case sentinelinfo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sentinelinfo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sentinelinfo.FieldLibraryReportSequence:
		return m.OldLibraryReportSequence(ctx)
	case sentinelinfo.FieldAppBinaryReportSequence:
		return m.OldAppBinaryReportSequence(ctx)
	}
	return nil, fmt.Errorf("unknown SentinelInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SentinelInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sentinelinfo.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case sentinelinfo.FieldAlternativeUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlternativeUrls(v)
		return nil
	case sentinelinfo.FieldGetTokenPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGetTokenPath(v)
		return nil
	case sentinelinfo.FieldDownloadFileBasePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadFileBasePath(v)
		return nil
	case sentinelinfo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sentinelinfo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sentinelinfo.FieldLibraryReportSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLibraryReportSequence(v)
		return nil
	case sentinelinfo.FieldAppBinaryReportSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppBinaryReportSequence(v)
		return nil
	}
	return fmt.Errorf("unknown SentinelInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SentinelInfoMutation) AddedFields() []string {
	var fields []string
	if m.addlibrary_report_sequence != nil {
		fields = append(fields, sentinelinfo.FieldLibraryReportSequence)
	}
	if m.addapp_binary_report_sequence != nil {
		fields = append(fields, sentinelinfo.FieldAppBinaryReportSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SentinelInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sentinelinfo.FieldLibraryReportSequence:
		return m.AddedLibraryReportSequence()
	case sentinelinfo.FieldAppBinaryReportSequence:
		return m.AddedAppBinaryReportSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SentinelInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sentinelinfo.FieldLibraryReportSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLibraryReportSequence(v)
		return nil
	case sentinelinfo.FieldAppBinaryReportSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAppBinaryReportSequence(v)
		return nil
	}
	return fmt.Errorf("unknown SentinelInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SentinelInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sentinelinfo.FieldAlternativeUrls) {
		fields = append(fields, sentinelinfo.FieldAlternativeUrls)
	}
	if m.FieldCleared(sentinelinfo.FieldGetTokenPath) {
		fields = append(fields, sentinelinfo.FieldGetTokenPath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SentinelInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SentinelInfoMutation) ClearField(name string) error {
	switch name {
	case sentinelinfo.FieldAlternativeUrls:
		m.ClearAlternativeUrls()
		return nil
	case sentinelinfo.FieldGetTokenPath:
		m.ClearGetTokenPath()
		return nil
	}
	return fmt.Errorf("unknown SentinelInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SentinelInfoMutation) ResetField(name string) error {
	switch name {
	case sentinelinfo.FieldURL:
		m.ResetURL()
		return nil
	case sentinelinfo.FieldAlternativeUrls:
		m.ResetAlternativeUrls()
		return nil
	case sentinelinfo.FieldGetTokenPath:
		m.ResetGetTokenPath()
		return nil
	case sentinelinfo.FieldDownloadFileBasePath:
		m.ResetDownloadFileBasePath()
		return nil
	case sentinelinfo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sentinelinfo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sentinelinfo.FieldLibraryReportSequence:
		m.ResetLibraryReportSequence()
		return nil
	case sentinelinfo.FieldAppBinaryReportSequence:
		m.ResetAppBinaryReportSequence()
		return nil
	}
	return fmt.Errorf("unknown SentinelInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SentinelInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sentinel_library != nil {
		edges = append(edges, sentinelinfo.EdgeSentinelLibrary)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SentinelInfoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sentinelinfo.EdgeSentinelLibrary:
		ids := make([]ent.Value, 0, len(m.sentinel_library))
		for id := range m.sentinel_library {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SentinelInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsentinel_library != nil {
		edges = append(edges, sentinelinfo.EdgeSentinelLibrary)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SentinelInfoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sentinelinfo.EdgeSentinelLibrary:
		ids := make([]ent.Value, 0, len(m.removedsentinel_library))
		for id := range m.removedsentinel_library {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SentinelInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsentinel_library {
		edges = append(edges, sentinelinfo.EdgeSentinelLibrary)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SentinelInfoMutation) EdgeCleared(name string) bool {
	switch name {
	case sentinelinfo.EdgeSentinelLibrary:
		return m.clearedsentinel_library
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SentinelInfoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SentinelInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SentinelInfoMutation) ResetEdge(name string) error {
	switch name {
	case sentinelinfo.EdgeSentinelLibrary:
		m.ResetSentinelLibrary()
		return nil
	}
	return fmt.Errorf("unknown SentinelInfo edge %s", name)
}

// SentinelLibraryMutation represents an operation that mutates the SentinelLibrary nodes in the graph.
type SentinelLibraryMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	reported_id                *int64
	addreported_id             *int64
	download_base_path         *string
	updated_at                 *time.Time
	created_at                 *time.Time
	library_report_sequence    *int64
	addlibrary_report_sequence *int64
	clearedFields              map[string]struct{}
	sentinel_info              *model.InternalID
	clearedsentinel_info       bool
	done                       bool
	oldValue                   func(context.Context) (*SentinelLibrary, error)
	predicates                 []predicate.SentinelLibrary
}

var _ ent.Mutation = (*SentinelLibraryMutation)(nil)

// sentinellibraryOption allows management of the mutation configuration using functional options.
type sentinellibraryOption func(*SentinelLibraryMutation)

// newSentinelLibraryMutation creates new mutation for the SentinelLibrary entity.
func newSentinelLibraryMutation(c config, op Op, opts ...sentinellibraryOption) *SentinelLibraryMutation {
	m := &SentinelLibraryMutation{
		config:        c,
		op:            op,
		typ:           TypeSentinelLibrary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSentinelLibraryID sets the ID field of the mutation.
func withSentinelLibraryID(id int) sentinellibraryOption {
	return func(m *SentinelLibraryMutation) {
		var (
			err   error
			once  sync.Once
			value *SentinelLibrary
		)
		m.oldValue = func(ctx context.Context) (*SentinelLibrary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SentinelLibrary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSentinelLibrary sets the old SentinelLibrary of the mutation.
func withSentinelLibrary(node *SentinelLibrary) sentinellibraryOption {
	return func(m *SentinelLibraryMutation) {
		m.oldValue = func(context.Context) (*SentinelLibrary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SentinelLibraryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SentinelLibraryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SentinelLibraryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SentinelLibraryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SentinelLibrary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSentinelInfoID sets the "sentinel_info_id" field.
func (m *SentinelLibraryMutation) SetSentinelInfoID(mi model.InternalID) {
	m.sentinel_info = &mi
}

// SentinelInfoID returns the value of the "sentinel_info_id" field in the mutation.
func (m *SentinelLibraryMutation) SentinelInfoID() (r model.InternalID, exists bool) {
	v := m.sentinel_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSentinelInfoID returns the old "sentinel_info_id" field's value of the SentinelLibrary entity.
// If the SentinelLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelLibraryMutation) OldSentinelInfoID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentinelInfoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentinelInfoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentinelInfoID: %w", err)
	}
	return oldValue.SentinelInfoID, nil
}

// ResetSentinelInfoID resets all changes to the "sentinel_info_id" field.
func (m *SentinelLibraryMutation) ResetSentinelInfoID() {
	m.sentinel_info = nil
}

// SetReportedID sets the "reported_id" field.
func (m *SentinelLibraryMutation) SetReportedID(i int64) {
	m.reported_id = &i
	m.addreported_id = nil
}

// ReportedID returns the value of the "reported_id" field in the mutation.
func (m *SentinelLibraryMutation) ReportedID() (r int64, exists bool) {
	v := m.reported_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReportedID returns the old "reported_id" field's value of the SentinelLibrary entity.
// If the SentinelLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelLibraryMutation) OldReportedID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportedID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportedID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportedID: %w", err)
	}
	return oldValue.ReportedID, nil
}

// AddReportedID adds i to the "reported_id" field.
func (m *SentinelLibraryMutation) AddReportedID(i int64) {
	if m.addreported_id != nil {
		*m.addreported_id += i
	} else {
		m.addreported_id = &i
	}
}

// AddedReportedID returns the value that was added to the "reported_id" field in this mutation.
func (m *SentinelLibraryMutation) AddedReportedID() (r int64, exists bool) {
	v := m.addreported_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetReportedID resets all changes to the "reported_id" field.
func (m *SentinelLibraryMutation) ResetReportedID() {
	m.reported_id = nil
	m.addreported_id = nil
}

// SetDownloadBasePath sets the "download_base_path" field.
func (m *SentinelLibraryMutation) SetDownloadBasePath(s string) {
	m.download_base_path = &s
}

// DownloadBasePath returns the value of the "download_base_path" field in the mutation.
func (m *SentinelLibraryMutation) DownloadBasePath() (r string, exists bool) {
	v := m.download_base_path
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadBasePath returns the old "download_base_path" field's value of the SentinelLibrary entity.
// If the SentinelLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelLibraryMutation) OldDownloadBasePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadBasePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadBasePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadBasePath: %w", err)
	}
	return oldValue.DownloadBasePath, nil
}

// ResetDownloadBasePath resets all changes to the "download_base_path" field.
func (m *SentinelLibraryMutation) ResetDownloadBasePath() {
	m.download_base_path = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SentinelLibraryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SentinelLibraryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SentinelLibrary entity.
// If the SentinelLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelLibraryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SentinelLibraryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SentinelLibraryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SentinelLibraryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SentinelLibrary entity.
// If the SentinelLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelLibraryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SentinelLibraryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLibraryReportSequence sets the "library_report_sequence" field.
func (m *SentinelLibraryMutation) SetLibraryReportSequence(i int64) {
	m.library_report_sequence = &i
	m.addlibrary_report_sequence = nil
}

// LibraryReportSequence returns the value of the "library_report_sequence" field in the mutation.
func (m *SentinelLibraryMutation) LibraryReportSequence() (r int64, exists bool) {
	v := m.library_report_sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldLibraryReportSequence returns the old "library_report_sequence" field's value of the SentinelLibrary entity.
// If the SentinelLibrary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SentinelLibraryMutation) OldLibraryReportSequence(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLibraryReportSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLibraryReportSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLibraryReportSequence: %w", err)
	}
	return oldValue.LibraryReportSequence, nil
}

// AddLibraryReportSequence adds i to the "library_report_sequence" field.
func (m *SentinelLibraryMutation) AddLibraryReportSequence(i int64) {
	if m.addlibrary_report_sequence != nil {
		*m.addlibrary_report_sequence += i
	} else {
		m.addlibrary_report_sequence = &i
	}
}

// AddedLibraryReportSequence returns the value that was added to the "library_report_sequence" field in this mutation.
func (m *SentinelLibraryMutation) AddedLibraryReportSequence() (r int64, exists bool) {
	v := m.addlibrary_report_sequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetLibraryReportSequence resets all changes to the "library_report_sequence" field.
func (m *SentinelLibraryMutation) ResetLibraryReportSequence() {
	m.library_report_sequence = nil
	m.addlibrary_report_sequence = nil
}

// ClearSentinelInfo clears the "sentinel_info" edge to the SentinelInfo entity.
func (m *SentinelLibraryMutation) ClearSentinelInfo() {
	m.clearedsentinel_info = true
	m.clearedFields[sentinellibrary.FieldSentinelInfoID] = struct{}{}
}

// SentinelInfoCleared reports if the "sentinel_info" edge to the SentinelInfo entity was cleared.
func (m *SentinelLibraryMutation) SentinelInfoCleared() bool {
	return m.clearedsentinel_info
}

// SentinelInfoIDs returns the "sentinel_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SentinelInfoID instead. It exists only for internal usage by the builders.
func (m *SentinelLibraryMutation) SentinelInfoIDs() (ids []model.InternalID) {
	if id := m.sentinel_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSentinelInfo resets all changes to the "sentinel_info" edge.
func (m *SentinelLibraryMutation) ResetSentinelInfo() {
	m.sentinel_info = nil
	m.clearedsentinel_info = false
}

// Where appends a list predicates to the SentinelLibraryMutation builder.
func (m *SentinelLibraryMutation) Where(ps ...predicate.SentinelLibrary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SentinelLibraryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SentinelLibraryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SentinelLibrary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SentinelLibraryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SentinelLibraryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SentinelLibrary).
func (m *SentinelLibraryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SentinelLibraryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.sentinel_info != nil {
		fields = append(fields, sentinellibrary.FieldSentinelInfoID)
	}
	if m.reported_id != nil {
		fields = append(fields, sentinellibrary.FieldReportedID)
	}
	if m.download_base_path != nil {
		fields = append(fields, sentinellibrary.FieldDownloadBasePath)
	}
	if m.updated_at != nil {
		fields = append(fields, sentinellibrary.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, sentinellibrary.FieldCreatedAt)
	}
	if m.library_report_sequence != nil {
		fields = append(fields, sentinellibrary.FieldLibraryReportSequence)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SentinelLibraryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sentinellibrary.FieldSentinelInfoID:
		return m.SentinelInfoID()
	case sentinellibrary.FieldReportedID:
		return m.ReportedID()
	case sentinellibrary.FieldDownloadBasePath:
		return m.DownloadBasePath()
	case sentinellibrary.FieldUpdatedAt:
		return m.UpdatedAt()
	case sentinellibrary.FieldCreatedAt:
		return m.CreatedAt()
	case sentinellibrary.FieldLibraryReportSequence:
		return m.LibraryReportSequence()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SentinelLibraryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sentinellibrary.FieldSentinelInfoID:
		return m.OldSentinelInfoID(ctx)
	case sentinellibrary.FieldReportedID:
		return m.OldReportedID(ctx)
	case sentinellibrary.FieldDownloadBasePath:
		return m.OldDownloadBasePath(ctx)
	case sentinellibrary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case sentinellibrary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sentinellibrary.FieldLibraryReportSequence:
		return m.OldLibraryReportSequence(ctx)
	}
	return nil, fmt.Errorf("unknown SentinelLibrary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SentinelLibraryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sentinellibrary.FieldSentinelInfoID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentinelInfoID(v)
		return nil
	case sentinellibrary.FieldReportedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportedID(v)
		return nil
	case sentinellibrary.FieldDownloadBasePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadBasePath(v)
		return nil
	case sentinellibrary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case sentinellibrary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sentinellibrary.FieldLibraryReportSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLibraryReportSequence(v)
		return nil
	}
	return fmt.Errorf("unknown SentinelLibrary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SentinelLibraryMutation) AddedFields() []string {
	var fields []string
	if m.addreported_id != nil {
		fields = append(fields, sentinellibrary.FieldReportedID)
	}
	if m.addlibrary_report_sequence != nil {
		fields = append(fields, sentinellibrary.FieldLibraryReportSequence)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SentinelLibraryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sentinellibrary.FieldReportedID:
		return m.AddedReportedID()
	case sentinellibrary.FieldLibraryReportSequence:
		return m.AddedLibraryReportSequence()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SentinelLibraryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sentinellibrary.FieldReportedID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReportedID(v)
		return nil
	case sentinellibrary.FieldLibraryReportSequence:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLibraryReportSequence(v)
		return nil
	}
	return fmt.Errorf("unknown SentinelLibrary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SentinelLibraryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SentinelLibraryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SentinelLibraryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SentinelLibrary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SentinelLibraryMutation) ResetField(name string) error {
	switch name {
	case sentinellibrary.FieldSentinelInfoID:
		m.ResetSentinelInfoID()
		return nil
	case sentinellibrary.FieldReportedID:
		m.ResetReportedID()
		return nil
	case sentinellibrary.FieldDownloadBasePath:
		m.ResetDownloadBasePath()
		return nil
	case sentinellibrary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case sentinellibrary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sentinellibrary.FieldLibraryReportSequence:
		m.ResetLibraryReportSequence()
		return nil
	}
	return fmt.Errorf("unknown SentinelLibrary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SentinelLibraryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sentinel_info != nil {
		edges = append(edges, sentinellibrary.EdgeSentinelInfo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SentinelLibraryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sentinellibrary.EdgeSentinelInfo:
		if id := m.sentinel_info; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SentinelLibraryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SentinelLibraryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SentinelLibraryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsentinel_info {
		edges = append(edges, sentinellibrary.EdgeSentinelInfo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SentinelLibraryMutation) EdgeCleared(name string) bool {
	switch name {
	case sentinellibrary.EdgeSentinelInfo:
		return m.clearedsentinel_info
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SentinelLibraryMutation) ClearEdge(name string) error {
	switch name {
	case sentinellibrary.EdgeSentinelInfo:
		m.ClearSentinelInfo()
		return nil
	}
	return fmt.Errorf("unknown SentinelLibrary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SentinelLibraryMutation) ResetEdge(name string) error {
	switch name {
	case sentinellibrary.EdgeSentinelInfo:
		m.ResetSentinelInfo()
		return nil
	}
	return fmt.Errorf("unknown SentinelLibrary edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	refresh_token *string
	expire_at     *time.Time
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *model.InternalID
	cleareduser   bool
	device        *model.InternalID
	cleareddevice bool
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id model.InternalID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(mi model.InternalID) {
	m.user = &mi
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user = nil
}

// SetDeviceID sets the "device_id" field.
func (m *SessionMutation) SetDeviceID(mi model.InternalID) {
	m.device = &mi
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *SessionMutation) DeviceID() (r model.InternalID, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDeviceID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ClearDeviceID clears the value of the "device_id" field.
func (m *SessionMutation) ClearDeviceID() {
	m.device = nil
	m.clearedFields[session.FieldDeviceID] = struct{}{}
}

// DeviceIDCleared returns if the "device_id" field was cleared in this mutation.
func (m *SessionMutation) DeviceIDCleared() bool {
	_, ok := m.clearedFields[session.FieldDeviceID]
	return ok
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *SessionMutation) ResetDeviceID() {
	m.device = nil
	delete(m.clearedFields, session.FieldDeviceID)
}

// SetRefreshToken sets the "refresh_token" field.
func (m *SessionMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *SessionMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *SessionMutation) ResetRefreshToken() {
	m.refresh_token = nil
}

// SetExpireAt sets the "expire_at" field.
func (m *SessionMutation) SetExpireAt(t time.Time) {
	m.expire_at = &t
}

// ExpireAt returns the value of the "expire_at" field in the mutation.
func (m *SessionMutation) ExpireAt() (r time.Time, exists bool) {
	v := m.expire_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireAt returns the old "expire_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpireAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpireAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpireAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireAt: %w", err)
	}
	return oldValue.ExpireAt, nil
}

// ResetExpireAt resets all changes to the "expire_at" field.
func (m *SessionMutation) ResetExpireAt() {
	m.expire_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []model.InternalID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *SessionMutation) ClearDevice() {
	m.cleareddevice = true
	m.clearedFields[session.FieldDeviceID] = struct{}{}
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *SessionMutation) DeviceCleared() bool {
	return m.DeviceIDCleared() || m.cleareddevice
}

// DeviceIDs returns the "device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeviceID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) DeviceIDs() (ids []model.InternalID) {
	if id := m.device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *SessionMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.user != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.device != nil {
		fields = append(fields, session.FieldDeviceID)
	}
	if m.refresh_token != nil {
		fields = append(fields, session.FieldRefreshToken)
	}
	if m.expire_at != nil {
		fields = append(fields, session.FieldExpireAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUserID:
		return m.UserID()
	case session.FieldDeviceID:
		return m.DeviceID()
	case session.FieldRefreshToken:
		return m.RefreshToken()
	case session.FieldExpireAt:
		return m.ExpireAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case session.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case session.FieldExpireAt:
		return m.OldExpireAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldDeviceID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case session.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case session.FieldExpireAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldDeviceID) {
		fields = append(fields, session.FieldDeviceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldDeviceID:
		m.ClearDeviceID()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case session.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case session.FieldExpireAt:
		m.ResetExpireAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	if m.device != nil {
		edges = append(edges, session.EdgeDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case session.EdgeDevice:
		if id := m.device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	if m.cleareddevice {
		edges = append(edges, session.EdgeDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	case session.EdgeDevice:
		return m.cleareddevice
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	case session.EdgeDevice:
		m.ClearDevice()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	case session.EdgeDevice:
		m.ResetDevice()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// StoreAppMutation represents an operation that mutates the StoreApp nodes in the graph.
type StoreAppMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	name          *string
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*StoreApp, error)
	predicates    []predicate.StoreApp
}

var _ ent.Mutation = (*StoreAppMutation)(nil)

// storeappOption allows management of the mutation configuration using functional options.
type storeappOption func(*StoreAppMutation)

// newStoreAppMutation creates new mutation for the StoreApp entity.
func newStoreAppMutation(c config, op Op, opts ...storeappOption) *StoreAppMutation {
	m := &StoreAppMutation{
		config:        c,
		op:            op,
		typ:           TypeStoreApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreAppID sets the ID field of the mutation.
func withStoreAppID(id model.InternalID) storeappOption {
	return func(m *StoreAppMutation) {
		var (
			err   error
			once  sync.Once
			value *StoreApp
		)
		m.oldValue = func(ctx context.Context) (*StoreApp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoreApp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoreApp sets the old StoreApp of the mutation.
func withStoreApp(node *StoreApp) storeappOption {
	return func(m *StoreAppMutation) {
		m.oldValue = func(context.Context) (*StoreApp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreAppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreAppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StoreApp entities.
func (m *StoreAppMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreAppMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreAppMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoreApp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *StoreAppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StoreAppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StoreApp entity.
// If the StoreApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StoreAppMutation) ResetName() {
	m.name = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreAppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreAppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StoreApp entity.
// If the StoreApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreAppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StoreAppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoreAppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StoreApp entity.
// If the StoreApp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoreAppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the StoreAppMutation builder.
func (m *StoreAppMutation) Where(ps ...predicate.StoreApp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreAppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreAppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StoreApp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreAppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreAppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StoreApp).
func (m *StoreAppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreAppMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, storeapp.FieldName)
	}
	if m.updated_at != nil {
		fields = append(fields, storeapp.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, storeapp.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreAppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storeapp.FieldName:
		return m.Name()
	case storeapp.FieldUpdatedAt:
		return m.UpdatedAt()
	case storeapp.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreAppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storeapp.FieldName:
		return m.OldName(ctx)
	case storeapp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storeapp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StoreApp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreAppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storeapp.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case storeapp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storeapp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StoreApp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreAppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreAppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreAppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StoreApp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreAppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreAppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreAppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StoreApp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreAppMutation) ResetField(name string) error {
	switch name {
	case storeapp.FieldName:
		m.ResetName()
		return nil
	case storeapp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storeapp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown StoreApp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreAppMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreAppMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreAppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreAppMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreAppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreAppMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreAppMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StoreApp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreAppMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StoreApp edge %s", name)
}

// StoreAppBinaryMutation represents an operation that mutates the StoreAppBinary nodes in the graph.
type StoreAppBinaryMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	name          *string
	size_bytes    *int64
	addsize_bytes *int64
	public_url    *string
	sha256        *[]byte
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*StoreAppBinary, error)
	predicates    []predicate.StoreAppBinary
}

var _ ent.Mutation = (*StoreAppBinaryMutation)(nil)

// storeappbinaryOption allows management of the mutation configuration using functional options.
type storeappbinaryOption func(*StoreAppBinaryMutation)

// newStoreAppBinaryMutation creates new mutation for the StoreAppBinary entity.
func newStoreAppBinaryMutation(c config, op Op, opts ...storeappbinaryOption) *StoreAppBinaryMutation {
	m := &StoreAppBinaryMutation{
		config:        c,
		op:            op,
		typ:           TypeStoreAppBinary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreAppBinaryID sets the ID field of the mutation.
func withStoreAppBinaryID(id model.InternalID) storeappbinaryOption {
	return func(m *StoreAppBinaryMutation) {
		var (
			err   error
			once  sync.Once
			value *StoreAppBinary
		)
		m.oldValue = func(ctx context.Context) (*StoreAppBinary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoreAppBinary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoreAppBinary sets the old StoreAppBinary of the mutation.
func withStoreAppBinary(node *StoreAppBinary) storeappbinaryOption {
	return func(m *StoreAppBinaryMutation) {
		m.oldValue = func(context.Context) (*StoreAppBinary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreAppBinaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreAppBinaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StoreAppBinary entities.
func (m *StoreAppBinaryMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreAppBinaryMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreAppBinaryMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoreAppBinary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *StoreAppBinaryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StoreAppBinaryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the StoreAppBinary entity.
// If the StoreAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAppBinaryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *StoreAppBinaryMutation) ClearName() {
	m.name = nil
	m.clearedFields[storeappbinary.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *StoreAppBinaryMutation) NameCleared() bool {
	_, ok := m.clearedFields[storeappbinary.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *StoreAppBinaryMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, storeappbinary.FieldName)
}

// SetSizeBytes sets the "size_bytes" field.
func (m *StoreAppBinaryMutation) SetSizeBytes(i int64) {
	m.size_bytes = &i
	m.addsize_bytes = nil
}

// SizeBytes returns the value of the "size_bytes" field in the mutation.
func (m *StoreAppBinaryMutation) SizeBytes() (r int64, exists bool) {
	v := m.size_bytes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeBytes returns the old "size_bytes" field's value of the StoreAppBinary entity.
// If the StoreAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAppBinaryMutation) OldSizeBytes(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeBytes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeBytes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeBytes: %w", err)
	}
	return oldValue.SizeBytes, nil
}

// AddSizeBytes adds i to the "size_bytes" field.
func (m *StoreAppBinaryMutation) AddSizeBytes(i int64) {
	if m.addsize_bytes != nil {
		*m.addsize_bytes += i
	} else {
		m.addsize_bytes = &i
	}
}

// AddedSizeBytes returns the value that was added to the "size_bytes" field in this mutation.
func (m *StoreAppBinaryMutation) AddedSizeBytes() (r int64, exists bool) {
	v := m.addsize_bytes
	if v == nil {
		return
	}
	return *v, true
}

// ClearSizeBytes clears the value of the "size_bytes" field.
func (m *StoreAppBinaryMutation) ClearSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	m.clearedFields[storeappbinary.FieldSizeBytes] = struct{}{}
}

// SizeBytesCleared returns if the "size_bytes" field was cleared in this mutation.
func (m *StoreAppBinaryMutation) SizeBytesCleared() bool {
	_, ok := m.clearedFields[storeappbinary.FieldSizeBytes]
	return ok
}

// ResetSizeBytes resets all changes to the "size_bytes" field.
func (m *StoreAppBinaryMutation) ResetSizeBytes() {
	m.size_bytes = nil
	m.addsize_bytes = nil
	delete(m.clearedFields, storeappbinary.FieldSizeBytes)
}

// SetPublicURL sets the "public_url" field.
func (m *StoreAppBinaryMutation) SetPublicURL(s string) {
	m.public_url = &s
}

// PublicURL returns the value of the "public_url" field in the mutation.
func (m *StoreAppBinaryMutation) PublicURL() (r string, exists bool) {
	v := m.public_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicURL returns the old "public_url" field's value of the StoreAppBinary entity.
// If the StoreAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAppBinaryMutation) OldPublicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicURL: %w", err)
	}
	return oldValue.PublicURL, nil
}

// ClearPublicURL clears the value of the "public_url" field.
func (m *StoreAppBinaryMutation) ClearPublicURL() {
	m.public_url = nil
	m.clearedFields[storeappbinary.FieldPublicURL] = struct{}{}
}

// PublicURLCleared returns if the "public_url" field was cleared in this mutation.
func (m *StoreAppBinaryMutation) PublicURLCleared() bool {
	_, ok := m.clearedFields[storeappbinary.FieldPublicURL]
	return ok
}

// ResetPublicURL resets all changes to the "public_url" field.
func (m *StoreAppBinaryMutation) ResetPublicURL() {
	m.public_url = nil
	delete(m.clearedFields, storeappbinary.FieldPublicURL)
}

// SetSha256 sets the "sha256" field.
func (m *StoreAppBinaryMutation) SetSha256(b []byte) {
	m.sha256 = &b
}

// Sha256 returns the value of the "sha256" field in the mutation.
func (m *StoreAppBinaryMutation) Sha256() (r []byte, exists bool) {
	v := m.sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldSha256 returns the old "sha256" field's value of the StoreAppBinary entity.
// If the StoreAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAppBinaryMutation) OldSha256(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha256: %w", err)
	}
	return oldValue.Sha256, nil
}

// ClearSha256 clears the value of the "sha256" field.
func (m *StoreAppBinaryMutation) ClearSha256() {
	m.sha256 = nil
	m.clearedFields[storeappbinary.FieldSha256] = struct{}{}
}

// Sha256Cleared returns if the "sha256" field was cleared in this mutation.
func (m *StoreAppBinaryMutation) Sha256Cleared() bool {
	_, ok := m.clearedFields[storeappbinary.FieldSha256]
	return ok
}

// ResetSha256 resets all changes to the "sha256" field.
func (m *StoreAppBinaryMutation) ResetSha256() {
	m.sha256 = nil
	delete(m.clearedFields, storeappbinary.FieldSha256)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreAppBinaryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreAppBinaryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StoreAppBinary entity.
// If the StoreAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAppBinaryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreAppBinaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StoreAppBinaryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoreAppBinaryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StoreAppBinary entity.
// If the StoreAppBinary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreAppBinaryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoreAppBinaryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the StoreAppBinaryMutation builder.
func (m *StoreAppBinaryMutation) Where(ps ...predicate.StoreAppBinary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreAppBinaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreAppBinaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StoreAppBinary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreAppBinaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreAppBinaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StoreAppBinary).
func (m *StoreAppBinaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreAppBinaryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, storeappbinary.FieldName)
	}
	if m.size_bytes != nil {
		fields = append(fields, storeappbinary.FieldSizeBytes)
	}
	if m.public_url != nil {
		fields = append(fields, storeappbinary.FieldPublicURL)
	}
	if m.sha256 != nil {
		fields = append(fields, storeappbinary.FieldSha256)
	}
	if m.updated_at != nil {
		fields = append(fields, storeappbinary.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, storeappbinary.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreAppBinaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storeappbinary.FieldName:
		return m.Name()
	case storeappbinary.FieldSizeBytes:
		return m.SizeBytes()
	case storeappbinary.FieldPublicURL:
		return m.PublicURL()
	case storeappbinary.FieldSha256:
		return m.Sha256()
	case storeappbinary.FieldUpdatedAt:
		return m.UpdatedAt()
	case storeappbinary.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreAppBinaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storeappbinary.FieldName:
		return m.OldName(ctx)
	case storeappbinary.FieldSizeBytes:
		return m.OldSizeBytes(ctx)
	case storeappbinary.FieldPublicURL:
		return m.OldPublicURL(ctx)
	case storeappbinary.FieldSha256:
		return m.OldSha256(ctx)
	case storeappbinary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storeappbinary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown StoreAppBinary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreAppBinaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storeappbinary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case storeappbinary.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeBytes(v)
		return nil
	case storeappbinary.FieldPublicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicURL(v)
		return nil
	case storeappbinary.FieldSha256:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha256(v)
		return nil
	case storeappbinary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storeappbinary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown StoreAppBinary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreAppBinaryMutation) AddedFields() []string {
	var fields []string
	if m.addsize_bytes != nil {
		fields = append(fields, storeappbinary.FieldSizeBytes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreAppBinaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case storeappbinary.FieldSizeBytes:
		return m.AddedSizeBytes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreAppBinaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case storeappbinary.FieldSizeBytes:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeBytes(v)
		return nil
	}
	return fmt.Errorf("unknown StoreAppBinary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreAppBinaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storeappbinary.FieldName) {
		fields = append(fields, storeappbinary.FieldName)
	}
	if m.FieldCleared(storeappbinary.FieldSizeBytes) {
		fields = append(fields, storeappbinary.FieldSizeBytes)
	}
	if m.FieldCleared(storeappbinary.FieldPublicURL) {
		fields = append(fields, storeappbinary.FieldPublicURL)
	}
	if m.FieldCleared(storeappbinary.FieldSha256) {
		fields = append(fields, storeappbinary.FieldSha256)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreAppBinaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreAppBinaryMutation) ClearField(name string) error {
	switch name {
	case storeappbinary.FieldName:
		m.ClearName()
		return nil
	case storeappbinary.FieldSizeBytes:
		m.ClearSizeBytes()
		return nil
	case storeappbinary.FieldPublicURL:
		m.ClearPublicURL()
		return nil
	case storeappbinary.FieldSha256:
		m.ClearSha256()
		return nil
	}
	return fmt.Errorf("unknown StoreAppBinary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreAppBinaryMutation) ResetField(name string) error {
	switch name {
	case storeappbinary.FieldName:
		m.ResetName()
		return nil
	case storeappbinary.FieldSizeBytes:
		m.ResetSizeBytes()
		return nil
	case storeappbinary.FieldPublicURL:
		m.ResetPublicURL()
		return nil
	case storeappbinary.FieldSha256:
		m.ResetSha256()
		return nil
	case storeappbinary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storeappbinary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown StoreAppBinary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreAppBinaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreAppBinaryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreAppBinaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreAppBinaryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreAppBinaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreAppBinaryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreAppBinaryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StoreAppBinary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreAppBinaryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StoreAppBinary edge %s", name)
}

// SystemNotificationMutation represents an operation that mutates the SystemNotification nodes in the graph.
type SystemNotificationMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	user_id       *model.InternalID
	adduser_id    *model.InternalID
	_type         *systemnotification.Type
	level         *systemnotification.Level
	status        *systemnotification.Status
	title         *string
	content       *string
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SystemNotification, error)
	predicates    []predicate.SystemNotification
}

var _ ent.Mutation = (*SystemNotificationMutation)(nil)

// systemnotificationOption allows management of the mutation configuration using functional options.
type systemnotificationOption func(*SystemNotificationMutation)

// newSystemNotificationMutation creates new mutation for the SystemNotification entity.
func newSystemNotificationMutation(c config, op Op, opts ...systemnotificationOption) *SystemNotificationMutation {
	m := &SystemNotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemNotificationID sets the ID field of the mutation.
func withSystemNotificationID(id model.InternalID) systemnotificationOption {
	return func(m *SystemNotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemNotification
		)
		m.oldValue = func(ctx context.Context) (*SystemNotification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemNotification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemNotification sets the old SystemNotification of the mutation.
func withSystemNotification(node *SystemNotification) systemnotificationOption {
	return func(m *SystemNotificationMutation) {
		m.oldValue = func(context.Context) (*SystemNotification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemNotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemNotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemNotification entities.
func (m *SystemNotificationMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemNotificationMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemNotificationMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemNotification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SystemNotificationMutation) SetUserID(mi model.InternalID) {
	m.user_id = &mi
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SystemNotificationMutation) UserID() (r model.InternalID, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldUserID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds mi to the "user_id" field.
func (m *SystemNotificationMutation) AddUserID(mi model.InternalID) {
	if m.adduser_id != nil {
		*m.adduser_id += mi
	} else {
		m.adduser_id = &mi
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *SystemNotificationMutation) AddedUserID() (r model.InternalID, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *SystemNotificationMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[systemnotification.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *SystemNotificationMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[systemnotification.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SystemNotificationMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, systemnotification.FieldUserID)
}

// SetType sets the "type" field.
func (m *SystemNotificationMutation) SetType(s systemnotification.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SystemNotificationMutation) GetType() (r systemnotification.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldType(ctx context.Context) (v systemnotification.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SystemNotificationMutation) ResetType() {
	m._type = nil
}

// SetLevel sets the "level" field.
func (m *SystemNotificationMutation) SetLevel(s systemnotification.Level) {
	m.level = &s
}

// Level returns the value of the "level" field in the mutation.
func (m *SystemNotificationMutation) Level() (r systemnotification.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldLevel(ctx context.Context) (v systemnotification.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *SystemNotificationMutation) ResetLevel() {
	m.level = nil
}

// SetStatus sets the "status" field.
func (m *SystemNotificationMutation) SetStatus(s systemnotification.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SystemNotificationMutation) Status() (r systemnotification.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldStatus(ctx context.Context) (v systemnotification.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SystemNotificationMutation) ResetStatus() {
	m.status = nil
}

// SetTitle sets the "title" field.
func (m *SystemNotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SystemNotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SystemNotificationMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *SystemNotificationMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SystemNotificationMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *SystemNotificationMutation) ResetContent() {
	m.content = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemNotificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemNotificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemNotificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemNotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemNotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemNotification entity.
// If the SystemNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemNotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemNotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the SystemNotificationMutation builder.
func (m *SystemNotificationMutation) Where(ps ...predicate.SystemNotification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemNotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemNotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemNotification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemNotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemNotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemNotification).
func (m *SystemNotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemNotificationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.user_id != nil {
		fields = append(fields, systemnotification.FieldUserID)
	}
	if m._type != nil {
		fields = append(fields, systemnotification.FieldType)
	}
	if m.level != nil {
		fields = append(fields, systemnotification.FieldLevel)
	}
	if m.status != nil {
		fields = append(fields, systemnotification.FieldStatus)
	}
	if m.title != nil {
		fields = append(fields, systemnotification.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, systemnotification.FieldContent)
	}
	if m.updated_at != nil {
		fields = append(fields, systemnotification.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, systemnotification.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemNotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemnotification.FieldUserID:
		return m.UserID()
	case systemnotification.FieldType:
		return m.GetType()
	case systemnotification.FieldLevel:
		return m.Level()
	case systemnotification.FieldStatus:
		return m.Status()
	case systemnotification.FieldTitle:
		return m.Title()
	case systemnotification.FieldContent:
		return m.Content()
	case systemnotification.FieldUpdatedAt:
		return m.UpdatedAt()
	case systemnotification.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemNotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemnotification.FieldUserID:
		return m.OldUserID(ctx)
	case systemnotification.FieldType:
		return m.OldType(ctx)
	case systemnotification.FieldLevel:
		return m.OldLevel(ctx)
	case systemnotification.FieldStatus:
		return m.OldStatus(ctx)
	case systemnotification.FieldTitle:
		return m.OldTitle(ctx)
	case systemnotification.FieldContent:
		return m.OldContent(ctx)
	case systemnotification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case systemnotification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemNotification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemNotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemnotification.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case systemnotification.FieldType:
		v, ok := value.(systemnotification.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case systemnotification.FieldLevel:
		v, ok := value.(systemnotification.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case systemnotification.FieldStatus:
		v, ok := value.(systemnotification.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case systemnotification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case systemnotification.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case systemnotification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case systemnotification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemNotification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemNotificationMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, systemnotification.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemNotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case systemnotification.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemNotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case systemnotification.FieldUserID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown SystemNotification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemNotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemnotification.FieldUserID) {
		fields = append(fields, systemnotification.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemNotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemNotificationMutation) ClearField(name string) error {
	switch name {
	case systemnotification.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown SystemNotification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemNotificationMutation) ResetField(name string) error {
	switch name {
	case systemnotification.FieldUserID:
		m.ResetUserID()
		return nil
	case systemnotification.FieldType:
		m.ResetType()
		return nil
	case systemnotification.FieldLevel:
		m.ResetLevel()
		return nil
	case systemnotification.FieldStatus:
		m.ResetStatus()
		return nil
	case systemnotification.FieldTitle:
		m.ResetTitle()
		return nil
	case systemnotification.FieldContent:
		m.ResetContent()
		return nil
	case systemnotification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case systemnotification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemNotification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemNotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemNotificationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemNotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemNotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemNotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemNotificationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemNotificationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SystemNotification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemNotificationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SystemNotification edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *model.InternalID
	name          *string
	description   *string
	public        *bool
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	owner         *model.InternalID
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id model.InternalID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserTag sets the "user_tag" field.
func (m *TagMutation) SetUserTag(mi model.InternalID) {
	m.owner = &mi
}

// UserTag returns the value of the "user_tag" field in the mutation.
func (m *TagMutation) UserTag() (r model.InternalID, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserTag returns the old "user_tag" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUserTag(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserTag: %w", err)
	}
	return oldValue.UserTag, nil
}

// ResetUserTag resets all changes to the "user_tag" field.
func (m *TagMutation) ResetUserTag() {
	m.owner = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
}

// SetPublic sets the "public" field.
func (m *TagMutation) SetPublic(b bool) {
	m.public = &b
}

// Public returns the value of the "public" field in the mutation.
func (m *TagMutation) Public() (r bool, exists bool) {
	v := m.public
	if v == nil {
		return
	}
	return *v, true
}

// OldPublic returns the old "public" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldPublic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublic: %w", err)
	}
	return oldValue.Public, nil
}

// ResetPublic resets all changes to the "public" field.
func (m *TagMutation) ResetPublic() {
	m.public = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TagMutation) SetOwnerID(id model.InternalID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TagMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[tag.FieldUserTag] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TagMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TagMutation) OwnerID() (id model.InternalID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TagMutation) OwnerIDs() (ids []model.InternalID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TagMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.owner != nil {
		fields = append(fields, tag.FieldUserTag)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.public != nil {
		fields = append(fields, tag.FieldPublic)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldUserTag:
		return m.UserTag()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldPublic:
		return m.Public()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldUserTag:
		return m.OldUserTag(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldPublic:
		return m.OldPublic(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldUserTag:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserTag(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldPublic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublic(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldUserTag:
		m.ResetUserTag()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldPublic:
		m.ResetPublic()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, tag.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, tag.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *model.InternalID
	username                    *string
	password                    *string
	status                      *user.Status
	_type                       *user.Type
	updated_at                  *time.Time
	created_at                  *time.Time
	clearedFields               map[string]struct{}
	session                     map[model.InternalID]struct{}
	removedsession              map[model.InternalID]struct{}
	clearedsession              bool
	account                     map[model.InternalID]struct{}
	removedaccount              map[model.InternalID]struct{}
	clearedaccount              bool
	app                         map[model.InternalID]struct{}
	removedapp                  map[model.InternalID]struct{}
	clearedapp                  bool
	feed_config                 map[model.InternalID]struct{}
	removedfeed_config          map[model.InternalID]struct{}
	clearedfeed_config          bool
	feed_action_set             map[model.InternalID]struct{}
	removedfeed_action_set      map[model.InternalID]struct{}
	clearedfeed_action_set      bool
	feed_item_collection        map[model.InternalID]struct{}
	removedfeed_item_collection map[model.InternalID]struct{}
	clearedfeed_item_collection bool
	notify_source               map[model.InternalID]struct{}
	removednotify_source        map[model.InternalID]struct{}
	clearednotify_source        bool
	notify_target               map[model.InternalID]struct{}
	removednotify_target        map[model.InternalID]struct{}
	clearednotify_target        bool
	notify_flow                 map[model.InternalID]struct{}
	removednotify_flow          map[model.InternalID]struct{}
	clearednotify_flow          bool
	image                       map[model.InternalID]struct{}
	removedimage                map[model.InternalID]struct{}
	clearedimage                bool
	file                        map[model.InternalID]struct{}
	removedfile                 map[model.InternalID]struct{}
	clearedfile                 bool
	tag                         map[model.InternalID]struct{}
	removedtag                  map[model.InternalID]struct{}
	clearedtag                  bool
	porter_context              map[model.InternalID]struct{}
	removedporter_context       map[model.InternalID]struct{}
	clearedporter_context       bool
	creator                     *model.InternalID
	clearedcreator              bool
	created_user                map[model.InternalID]struct{}
	removedcreated_user         map[model.InternalID]struct{}
	clearedcreated_user         bool
	done                        bool
	oldValue                    func(context.Context) (*User, error)
	predicates                  []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id model.InternalID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id model.InternalID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id model.InternalID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]model.InternalID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []model.InternalID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *UserMutation) SetType(u user.Type) {
	m._type = &u
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserMutation) GetType() (r user.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldType(ctx context.Context) (v user.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserMutation) ResetType() {
	m._type = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *UserMutation) SetCreatorID(mi model.InternalID) {
	m.creator = &mi
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *UserMutation) CreatorID() (r model.InternalID, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatorID(ctx context.Context) (v model.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *UserMutation) ResetCreatorID() {
	m.creator = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddSessionIDs adds the "session" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...model.InternalID) {
	if m.session == nil {
		m.session = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.session[ids[i]] = struct{}{}
	}
}

// ClearSession clears the "session" edge to the Session entity.
func (m *UserMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the Session entity was cleared.
func (m *UserMutation) SessionCleared() bool {
	return m.clearedsession
}

// RemoveSessionIDs removes the "session" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...model.InternalID) {
	if m.removedsession == nil {
		m.removedsession = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.session, ids[i])
		m.removedsession[ids[i]] = struct{}{}
	}
}

// RemovedSession returns the removed IDs of the "session" edge to the Session entity.
func (m *UserMutation) RemovedSessionIDs() (ids []model.InternalID) {
	for id := range m.removedsession {
		ids = append(ids, id)
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
func (m *UserMutation) SessionIDs() (ids []model.InternalID) {
	for id := range m.session {
		ids = append(ids, id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *UserMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
	m.removedsession = nil
}

// AddAccountIDs adds the "account" edge to the Account entity by ids.
func (m *UserMutation) AddAccountIDs(ids ...model.InternalID) {
	if m.account == nil {
		m.account = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.account[ids[i]] = struct{}{}
	}
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *UserMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *UserMutation) AccountCleared() bool {
	return m.clearedaccount
}

// RemoveAccountIDs removes the "account" edge to the Account entity by IDs.
func (m *UserMutation) RemoveAccountIDs(ids ...model.InternalID) {
	if m.removedaccount == nil {
		m.removedaccount = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.account, ids[i])
		m.removedaccount[ids[i]] = struct{}{}
	}
}

// RemovedAccount returns the removed IDs of the "account" edge to the Account entity.
func (m *UserMutation) RemovedAccountIDs() (ids []model.InternalID) {
	for id := range m.removedaccount {
		ids = append(ids, id)
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
func (m *UserMutation) AccountIDs() (ids []model.InternalID) {
	for id := range m.account {
		ids = append(ids, id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *UserMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
	m.removedaccount = nil
}

// AddAppIDs adds the "app" edge to the App entity by ids.
func (m *UserMutation) AddAppIDs(ids ...model.InternalID) {
	if m.app == nil {
		m.app = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.app[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "app" edge to the App entity.
func (m *UserMutation) ClearApp() {
	m.clearedapp = true
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *UserMutation) AppCleared() bool {
	return m.clearedapp
}

// RemoveAppIDs removes the "app" edge to the App entity by IDs.
func (m *UserMutation) RemoveAppIDs(ids ...model.InternalID) {
	if m.removedapp == nil {
		m.removedapp = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.app, ids[i])
		m.removedapp[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "app" edge to the App entity.
func (m *UserMutation) RemovedAppIDs() (ids []model.InternalID) {
	for id := range m.removedapp {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "app" edge IDs in the mutation.
func (m *UserMutation) AppIDs() (ids []model.InternalID) {
	for id := range m.app {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *UserMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
	m.removedapp = nil
}

// AddFeedConfigIDs adds the "feed_config" edge to the FeedConfig entity by ids.
func (m *UserMutation) AddFeedConfigIDs(ids ...model.InternalID) {
	if m.feed_config == nil {
		m.feed_config = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_config[ids[i]] = struct{}{}
	}
}

// ClearFeedConfig clears the "feed_config" edge to the FeedConfig entity.
func (m *UserMutation) ClearFeedConfig() {
	m.clearedfeed_config = true
}

// FeedConfigCleared reports if the "feed_config" edge to the FeedConfig entity was cleared.
func (m *UserMutation) FeedConfigCleared() bool {
	return m.clearedfeed_config
}

// RemoveFeedConfigIDs removes the "feed_config" edge to the FeedConfig entity by IDs.
func (m *UserMutation) RemoveFeedConfigIDs(ids ...model.InternalID) {
	if m.removedfeed_config == nil {
		m.removedfeed_config = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_config, ids[i])
		m.removedfeed_config[ids[i]] = struct{}{}
	}
}

// RemovedFeedConfig returns the removed IDs of the "feed_config" edge to the FeedConfig entity.
func (m *UserMutation) RemovedFeedConfigIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_config {
		ids = append(ids, id)
	}
	return
}

// FeedConfigIDs returns the "feed_config" edge IDs in the mutation.
func (m *UserMutation) FeedConfigIDs() (ids []model.InternalID) {
	for id := range m.feed_config {
		ids = append(ids, id)
	}
	return
}

// ResetFeedConfig resets all changes to the "feed_config" edge.
func (m *UserMutation) ResetFeedConfig() {
	m.feed_config = nil
	m.clearedfeed_config = false
	m.removedfeed_config = nil
}

// AddFeedActionSetIDs adds the "feed_action_set" edge to the FeedActionSet entity by ids.
func (m *UserMutation) AddFeedActionSetIDs(ids ...model.InternalID) {
	if m.feed_action_set == nil {
		m.feed_action_set = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_action_set[ids[i]] = struct{}{}
	}
}

// ClearFeedActionSet clears the "feed_action_set" edge to the FeedActionSet entity.
func (m *UserMutation) ClearFeedActionSet() {
	m.clearedfeed_action_set = true
}

// FeedActionSetCleared reports if the "feed_action_set" edge to the FeedActionSet entity was cleared.
func (m *UserMutation) FeedActionSetCleared() bool {
	return m.clearedfeed_action_set
}

// RemoveFeedActionSetIDs removes the "feed_action_set" edge to the FeedActionSet entity by IDs.
func (m *UserMutation) RemoveFeedActionSetIDs(ids ...model.InternalID) {
	if m.removedfeed_action_set == nil {
		m.removedfeed_action_set = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_action_set, ids[i])
		m.removedfeed_action_set[ids[i]] = struct{}{}
	}
}

// RemovedFeedActionSet returns the removed IDs of the "feed_action_set" edge to the FeedActionSet entity.
func (m *UserMutation) RemovedFeedActionSetIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_action_set {
		ids = append(ids, id)
	}
	return
}

// FeedActionSetIDs returns the "feed_action_set" edge IDs in the mutation.
func (m *UserMutation) FeedActionSetIDs() (ids []model.InternalID) {
	for id := range m.feed_action_set {
		ids = append(ids, id)
	}
	return
}

// ResetFeedActionSet resets all changes to the "feed_action_set" edge.
func (m *UserMutation) ResetFeedActionSet() {
	m.feed_action_set = nil
	m.clearedfeed_action_set = false
	m.removedfeed_action_set = nil
}

// AddFeedItemCollectionIDs adds the "feed_item_collection" edge to the FeedItemCollection entity by ids.
func (m *UserMutation) AddFeedItemCollectionIDs(ids ...model.InternalID) {
	if m.feed_item_collection == nil {
		m.feed_item_collection = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.feed_item_collection[ids[i]] = struct{}{}
	}
}

// ClearFeedItemCollection clears the "feed_item_collection" edge to the FeedItemCollection entity.
func (m *UserMutation) ClearFeedItemCollection() {
	m.clearedfeed_item_collection = true
}

// FeedItemCollectionCleared reports if the "feed_item_collection" edge to the FeedItemCollection entity was cleared.
func (m *UserMutation) FeedItemCollectionCleared() bool {
	return m.clearedfeed_item_collection
}

// RemoveFeedItemCollectionIDs removes the "feed_item_collection" edge to the FeedItemCollection entity by IDs.
func (m *UserMutation) RemoveFeedItemCollectionIDs(ids ...model.InternalID) {
	if m.removedfeed_item_collection == nil {
		m.removedfeed_item_collection = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.feed_item_collection, ids[i])
		m.removedfeed_item_collection[ids[i]] = struct{}{}
	}
}

// RemovedFeedItemCollection returns the removed IDs of the "feed_item_collection" edge to the FeedItemCollection entity.
func (m *UserMutation) RemovedFeedItemCollectionIDs() (ids []model.InternalID) {
	for id := range m.removedfeed_item_collection {
		ids = append(ids, id)
	}
	return
}

// FeedItemCollectionIDs returns the "feed_item_collection" edge IDs in the mutation.
func (m *UserMutation) FeedItemCollectionIDs() (ids []model.InternalID) {
	for id := range m.feed_item_collection {
		ids = append(ids, id)
	}
	return
}

// ResetFeedItemCollection resets all changes to the "feed_item_collection" edge.
func (m *UserMutation) ResetFeedItemCollection() {
	m.feed_item_collection = nil
	m.clearedfeed_item_collection = false
	m.removedfeed_item_collection = nil
}

// AddNotifySourceIDs adds the "notify_source" edge to the NotifySource entity by ids.
func (m *UserMutation) AddNotifySourceIDs(ids ...model.InternalID) {
	if m.notify_source == nil {
		m.notify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_source[ids[i]] = struct{}{}
	}
}

// ClearNotifySource clears the "notify_source" edge to the NotifySource entity.
func (m *UserMutation) ClearNotifySource() {
	m.clearednotify_source = true
}

// NotifySourceCleared reports if the "notify_source" edge to the NotifySource entity was cleared.
func (m *UserMutation) NotifySourceCleared() bool {
	return m.clearednotify_source
}

// RemoveNotifySourceIDs removes the "notify_source" edge to the NotifySource entity by IDs.
func (m *UserMutation) RemoveNotifySourceIDs(ids ...model.InternalID) {
	if m.removednotify_source == nil {
		m.removednotify_source = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_source, ids[i])
		m.removednotify_source[ids[i]] = struct{}{}
	}
}

// RemovedNotifySource returns the removed IDs of the "notify_source" edge to the NotifySource entity.
func (m *UserMutation) RemovedNotifySourceIDs() (ids []model.InternalID) {
	for id := range m.removednotify_source {
		ids = append(ids, id)
	}
	return
}

// NotifySourceIDs returns the "notify_source" edge IDs in the mutation.
func (m *UserMutation) NotifySourceIDs() (ids []model.InternalID) {
	for id := range m.notify_source {
		ids = append(ids, id)
	}
	return
}

// ResetNotifySource resets all changes to the "notify_source" edge.
func (m *UserMutation) ResetNotifySource() {
	m.notify_source = nil
	m.clearednotify_source = false
	m.removednotify_source = nil
}

// AddNotifyTargetIDs adds the "notify_target" edge to the NotifyTarget entity by ids.
func (m *UserMutation) AddNotifyTargetIDs(ids ...model.InternalID) {
	if m.notify_target == nil {
		m.notify_target = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_target[ids[i]] = struct{}{}
	}
}

// ClearNotifyTarget clears the "notify_target" edge to the NotifyTarget entity.
func (m *UserMutation) ClearNotifyTarget() {
	m.clearednotify_target = true
}

// NotifyTargetCleared reports if the "notify_target" edge to the NotifyTarget entity was cleared.
func (m *UserMutation) NotifyTargetCleared() bool {
	return m.clearednotify_target
}

// RemoveNotifyTargetIDs removes the "notify_target" edge to the NotifyTarget entity by IDs.
func (m *UserMutation) RemoveNotifyTargetIDs(ids ...model.InternalID) {
	if m.removednotify_target == nil {
		m.removednotify_target = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_target, ids[i])
		m.removednotify_target[ids[i]] = struct{}{}
	}
}

// RemovedNotifyTarget returns the removed IDs of the "notify_target" edge to the NotifyTarget entity.
func (m *UserMutation) RemovedNotifyTargetIDs() (ids []model.InternalID) {
	for id := range m.removednotify_target {
		ids = append(ids, id)
	}
	return
}

// NotifyTargetIDs returns the "notify_target" edge IDs in the mutation.
func (m *UserMutation) NotifyTargetIDs() (ids []model.InternalID) {
	for id := range m.notify_target {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyTarget resets all changes to the "notify_target" edge.
func (m *UserMutation) ResetNotifyTarget() {
	m.notify_target = nil
	m.clearednotify_target = false
	m.removednotify_target = nil
}

// AddNotifyFlowIDs adds the "notify_flow" edge to the NotifyFlow entity by ids.
func (m *UserMutation) AddNotifyFlowIDs(ids ...model.InternalID) {
	if m.notify_flow == nil {
		m.notify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.notify_flow[ids[i]] = struct{}{}
	}
}

// ClearNotifyFlow clears the "notify_flow" edge to the NotifyFlow entity.
func (m *UserMutation) ClearNotifyFlow() {
	m.clearednotify_flow = true
}

// NotifyFlowCleared reports if the "notify_flow" edge to the NotifyFlow entity was cleared.
func (m *UserMutation) NotifyFlowCleared() bool {
	return m.clearednotify_flow
}

// RemoveNotifyFlowIDs removes the "notify_flow" edge to the NotifyFlow entity by IDs.
func (m *UserMutation) RemoveNotifyFlowIDs(ids ...model.InternalID) {
	if m.removednotify_flow == nil {
		m.removednotify_flow = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.notify_flow, ids[i])
		m.removednotify_flow[ids[i]] = struct{}{}
	}
}

// RemovedNotifyFlow returns the removed IDs of the "notify_flow" edge to the NotifyFlow entity.
func (m *UserMutation) RemovedNotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.removednotify_flow {
		ids = append(ids, id)
	}
	return
}

// NotifyFlowIDs returns the "notify_flow" edge IDs in the mutation.
func (m *UserMutation) NotifyFlowIDs() (ids []model.InternalID) {
	for id := range m.notify_flow {
		ids = append(ids, id)
	}
	return
}

// ResetNotifyFlow resets all changes to the "notify_flow" edge.
func (m *UserMutation) ResetNotifyFlow() {
	m.notify_flow = nil
	m.clearednotify_flow = false
	m.removednotify_flow = nil
}

// AddImageIDs adds the "image" edge to the Image entity by ids.
func (m *UserMutation) AddImageIDs(ids ...model.InternalID) {
	if m.image == nil {
		m.image = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.image[ids[i]] = struct{}{}
	}
}

// ClearImage clears the "image" edge to the Image entity.
func (m *UserMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Image entity was cleared.
func (m *UserMutation) ImageCleared() bool {
	return m.clearedimage
}

// RemoveImageIDs removes the "image" edge to the Image entity by IDs.
func (m *UserMutation) RemoveImageIDs(ids ...model.InternalID) {
	if m.removedimage == nil {
		m.removedimage = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.image, ids[i])
		m.removedimage[ids[i]] = struct{}{}
	}
}

// RemovedImage returns the removed IDs of the "image" edge to the Image entity.
func (m *UserMutation) RemovedImageIDs() (ids []model.InternalID) {
	for id := range m.removedimage {
		ids = append(ids, id)
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
func (m *UserMutation) ImageIDs() (ids []model.InternalID) {
	for id := range m.image {
		ids = append(ids, id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *UserMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
	m.removedimage = nil
}

// AddFileIDs adds the "file" edge to the File entity by ids.
func (m *UserMutation) AddFileIDs(ids ...model.InternalID) {
	if m.file == nil {
		m.file = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.file[ids[i]] = struct{}{}
	}
}

// ClearFile clears the "file" edge to the File entity.
func (m *UserMutation) ClearFile() {
	m.clearedfile = true
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *UserMutation) FileCleared() bool {
	return m.clearedfile
}

// RemoveFileIDs removes the "file" edge to the File entity by IDs.
func (m *UserMutation) RemoveFileIDs(ids ...model.InternalID) {
	if m.removedfile == nil {
		m.removedfile = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.file, ids[i])
		m.removedfile[ids[i]] = struct{}{}
	}
}

// RemovedFile returns the removed IDs of the "file" edge to the File entity.
func (m *UserMutation) RemovedFileIDs() (ids []model.InternalID) {
	for id := range m.removedfile {
		ids = append(ids, id)
	}
	return
}

// FileIDs returns the "file" edge IDs in the mutation.
func (m *UserMutation) FileIDs() (ids []model.InternalID) {
	for id := range m.file {
		ids = append(ids, id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *UserMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
	m.removedfile = nil
}

// AddTagIDs adds the "tag" edge to the Tag entity by ids.
func (m *UserMutation) AddTagIDs(ids ...model.InternalID) {
	if m.tag == nil {
		m.tag = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *UserMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *UserMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the "tag" edge to the Tag entity by IDs.
func (m *UserMutation) RemoveTagIDs(ids ...model.InternalID) {
	if m.removedtag == nil {
		m.removedtag = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.tag, ids[i])
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed IDs of the "tag" edge to the Tag entity.
func (m *UserMutation) RemovedTagIDs() (ids []model.InternalID) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
func (m *UserMutation) TagIDs() (ids []model.InternalID) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *UserMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// AddPorterContextIDs adds the "porter_context" edge to the PorterContext entity by ids.
func (m *UserMutation) AddPorterContextIDs(ids ...model.InternalID) {
	if m.porter_context == nil {
		m.porter_context = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.porter_context[ids[i]] = struct{}{}
	}
}

// ClearPorterContext clears the "porter_context" edge to the PorterContext entity.
func (m *UserMutation) ClearPorterContext() {
	m.clearedporter_context = true
}

// PorterContextCleared reports if the "porter_context" edge to the PorterContext entity was cleared.
func (m *UserMutation) PorterContextCleared() bool {
	return m.clearedporter_context
}

// RemovePorterContextIDs removes the "porter_context" edge to the PorterContext entity by IDs.
func (m *UserMutation) RemovePorterContextIDs(ids ...model.InternalID) {
	if m.removedporter_context == nil {
		m.removedporter_context = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.porter_context, ids[i])
		m.removedporter_context[ids[i]] = struct{}{}
	}
}

// RemovedPorterContext returns the removed IDs of the "porter_context" edge to the PorterContext entity.
func (m *UserMutation) RemovedPorterContextIDs() (ids []model.InternalID) {
	for id := range m.removedporter_context {
		ids = append(ids, id)
	}
	return
}

// PorterContextIDs returns the "porter_context" edge IDs in the mutation.
func (m *UserMutation) PorterContextIDs() (ids []model.InternalID) {
	for id := range m.porter_context {
		ids = append(ids, id)
	}
	return
}

// ResetPorterContext resets all changes to the "porter_context" edge.
func (m *UserMutation) ResetPorterContext() {
	m.porter_context = nil
	m.clearedporter_context = false
	m.removedporter_context = nil
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *UserMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[user.FieldCreatorID] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *UserMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *UserMutation) CreatorIDs() (ids []model.InternalID) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *UserMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddCreatedUserIDs adds the "created_user" edge to the User entity by ids.
func (m *UserMutation) AddCreatedUserIDs(ids ...model.InternalID) {
	if m.created_user == nil {
		m.created_user = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		m.created_user[ids[i]] = struct{}{}
	}
}

// ClearCreatedUser clears the "created_user" edge to the User entity.
func (m *UserMutation) ClearCreatedUser() {
	m.clearedcreated_user = true
}

// CreatedUserCleared reports if the "created_user" edge to the User entity was cleared.
func (m *UserMutation) CreatedUserCleared() bool {
	return m.clearedcreated_user
}

// RemoveCreatedUserIDs removes the "created_user" edge to the User entity by IDs.
func (m *UserMutation) RemoveCreatedUserIDs(ids ...model.InternalID) {
	if m.removedcreated_user == nil {
		m.removedcreated_user = make(map[model.InternalID]struct{})
	}
	for i := range ids {
		delete(m.created_user, ids[i])
		m.removedcreated_user[ids[i]] = struct{}{}
	}
}

// RemovedCreatedUser returns the removed IDs of the "created_user" edge to the User entity.
func (m *UserMutation) RemovedCreatedUserIDs() (ids []model.InternalID) {
	for id := range m.removedcreated_user {
		ids = append(ids, id)
	}
	return
}

// CreatedUserIDs returns the "created_user" edge IDs in the mutation.
func (m *UserMutation) CreatedUserIDs() (ids []model.InternalID) {
	for id := range m.created_user {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedUser resets all changes to the "created_user" edge.
func (m *UserMutation) ResetCreatedUser() {
	m.created_user = nil
	m.clearedcreated_user = false
	m.removedcreated_user = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, user.FieldType)
	}
	if m.creator != nil {
		fields = append(fields, user.FieldCreatorID)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldStatus:
		return m.Status()
	case user.FieldType:
		return m.GetType()
	case user.FieldCreatorID:
		return m.CreatorID()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldType:
		return m.OldType(ctx)
	case user.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldType:
		v, ok := value.(user.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case user.FieldCreatorID:
		v, ok := value.(model.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldType:
		m.ResetType()
		return nil
	case user.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.session != nil {
		edges = append(edges, user.EdgeSession)
	}
	if m.account != nil {
		edges = append(edges, user.EdgeAccount)
	}
	if m.app != nil {
		edges = append(edges, user.EdgeApp)
	}
	if m.feed_config != nil {
		edges = append(edges, user.EdgeFeedConfig)
	}
	if m.feed_action_set != nil {
		edges = append(edges, user.EdgeFeedActionSet)
	}
	if m.feed_item_collection != nil {
		edges = append(edges, user.EdgeFeedItemCollection)
	}
	if m.notify_source != nil {
		edges = append(edges, user.EdgeNotifySource)
	}
	if m.notify_target != nil {
		edges = append(edges, user.EdgeNotifyTarget)
	}
	if m.notify_flow != nil {
		edges = append(edges, user.EdgeNotifyFlow)
	}
	if m.image != nil {
		edges = append(edges, user.EdgeImage)
	}
	if m.file != nil {
		edges = append(edges, user.EdgeFile)
	}
	if m.tag != nil {
		edges = append(edges, user.EdgeTag)
	}
	if m.porter_context != nil {
		edges = append(edges, user.EdgePorterContext)
	}
	if m.creator != nil {
		edges = append(edges, user.EdgeCreator)
	}
	if m.created_user != nil {
		edges = append(edges, user.EdgeCreatedUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSession:
		ids := make([]ent.Value, 0, len(m.session))
		for id := range m.session {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAccount:
		ids := make([]ent.Value, 0, len(m.account))
		for id := range m.account {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApp:
		ids := make([]ent.Value, 0, len(m.app))
		for id := range m.app {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedConfig:
		ids := make([]ent.Value, 0, len(m.feed_config))
		for id := range m.feed_config {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedActionSet:
		ids := make([]ent.Value, 0, len(m.feed_action_set))
		for id := range m.feed_action_set {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedItemCollection:
		ids := make([]ent.Value, 0, len(m.feed_item_collection))
		for id := range m.feed_item_collection {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.notify_source))
		for id := range m.notify_source {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifyTarget:
		ids := make([]ent.Value, 0, len(m.notify_target))
		for id := range m.notify_target {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.notify_flow))
		for id := range m.notify_flow {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImage:
		ids := make([]ent.Value, 0, len(m.image))
		for id := range m.image {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFile:
		ids := make([]ent.Value, 0, len(m.file))
		for id := range m.file {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePorterContext:
		ids := make([]ent.Value, 0, len(m.porter_context))
		for id := range m.porter_context {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeCreatedUser:
		ids := make([]ent.Value, 0, len(m.created_user))
		for id := range m.created_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedsession != nil {
		edges = append(edges, user.EdgeSession)
	}
	if m.removedaccount != nil {
		edges = append(edges, user.EdgeAccount)
	}
	if m.removedapp != nil {
		edges = append(edges, user.EdgeApp)
	}
	if m.removedfeed_config != nil {
		edges = append(edges, user.EdgeFeedConfig)
	}
	if m.removedfeed_action_set != nil {
		edges = append(edges, user.EdgeFeedActionSet)
	}
	if m.removedfeed_item_collection != nil {
		edges = append(edges, user.EdgeFeedItemCollection)
	}
	if m.removednotify_source != nil {
		edges = append(edges, user.EdgeNotifySource)
	}
	if m.removednotify_target != nil {
		edges = append(edges, user.EdgeNotifyTarget)
	}
	if m.removednotify_flow != nil {
		edges = append(edges, user.EdgeNotifyFlow)
	}
	if m.removedimage != nil {
		edges = append(edges, user.EdgeImage)
	}
	if m.removedfile != nil {
		edges = append(edges, user.EdgeFile)
	}
	if m.removedtag != nil {
		edges = append(edges, user.EdgeTag)
	}
	if m.removedporter_context != nil {
		edges = append(edges, user.EdgePorterContext)
	}
	if m.removedcreated_user != nil {
		edges = append(edges, user.EdgeCreatedUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSession:
		ids := make([]ent.Value, 0, len(m.removedsession))
		for id := range m.removedsession {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAccount:
		ids := make([]ent.Value, 0, len(m.removedaccount))
		for id := range m.removedaccount {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removedapp))
		for id := range m.removedapp {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedConfig:
		ids := make([]ent.Value, 0, len(m.removedfeed_config))
		for id := range m.removedfeed_config {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedActionSet:
		ids := make([]ent.Value, 0, len(m.removedfeed_action_set))
		for id := range m.removedfeed_action_set {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedItemCollection:
		ids := make([]ent.Value, 0, len(m.removedfeed_item_collection))
		for id := range m.removedfeed_item_collection {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifySource:
		ids := make([]ent.Value, 0, len(m.removednotify_source))
		for id := range m.removednotify_source {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifyTarget:
		ids := make([]ent.Value, 0, len(m.removednotify_target))
		for id := range m.removednotify_target {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotifyFlow:
		ids := make([]ent.Value, 0, len(m.removednotify_flow))
		for id := range m.removednotify_flow {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeImage:
		ids := make([]ent.Value, 0, len(m.removedimage))
		for id := range m.removedimage {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFile:
		ids := make([]ent.Value, 0, len(m.removedfile))
		for id := range m.removedfile {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePorterContext:
		ids := make([]ent.Value, 0, len(m.removedporter_context))
		for id := range m.removedporter_context {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedUser:
		ids := make([]ent.Value, 0, len(m.removedcreated_user))
		for id := range m.removedcreated_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedsession {
		edges = append(edges, user.EdgeSession)
	}
	if m.clearedaccount {
		edges = append(edges, user.EdgeAccount)
	}
	if m.clearedapp {
		edges = append(edges, user.EdgeApp)
	}
	if m.clearedfeed_config {
		edges = append(edges, user.EdgeFeedConfig)
	}
	if m.clearedfeed_action_set {
		edges = append(edges, user.EdgeFeedActionSet)
	}
	if m.clearedfeed_item_collection {
		edges = append(edges, user.EdgeFeedItemCollection)
	}
	if m.clearednotify_source {
		edges = append(edges, user.EdgeNotifySource)
	}
	if m.clearednotify_target {
		edges = append(edges, user.EdgeNotifyTarget)
	}
	if m.clearednotify_flow {
		edges = append(edges, user.EdgeNotifyFlow)
	}
	if m.clearedimage {
		edges = append(edges, user.EdgeImage)
	}
	if m.clearedfile {
		edges = append(edges, user.EdgeFile)
	}
	if m.clearedtag {
		edges = append(edges, user.EdgeTag)
	}
	if m.clearedporter_context {
		edges = append(edges, user.EdgePorterContext)
	}
	if m.clearedcreator {
		edges = append(edges, user.EdgeCreator)
	}
	if m.clearedcreated_user {
		edges = append(edges, user.EdgeCreatedUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSession:
		return m.clearedsession
	case user.EdgeAccount:
		return m.clearedaccount
	case user.EdgeApp:
		return m.clearedapp
	case user.EdgeFeedConfig:
		return m.clearedfeed_config
	case user.EdgeFeedActionSet:
		return m.clearedfeed_action_set
	case user.EdgeFeedItemCollection:
		return m.clearedfeed_item_collection
	case user.EdgeNotifySource:
		return m.clearednotify_source
	case user.EdgeNotifyTarget:
		return m.clearednotify_target
	case user.EdgeNotifyFlow:
		return m.clearednotify_flow
	case user.EdgeImage:
		return m.clearedimage
	case user.EdgeFile:
		return m.clearedfile
	case user.EdgeTag:
		return m.clearedtag
	case user.EdgePorterContext:
		return m.clearedporter_context
	case user.EdgeCreator:
		return m.clearedcreator
	case user.EdgeCreatedUser:
		return m.clearedcreated_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSession:
		m.ResetSession()
		return nil
	case user.EdgeAccount:
		m.ResetAccount()
		return nil
	case user.EdgeApp:
		m.ResetApp()
		return nil
	case user.EdgeFeedConfig:
		m.ResetFeedConfig()
		return nil
	case user.EdgeFeedActionSet:
		m.ResetFeedActionSet()
		return nil
	case user.EdgeFeedItemCollection:
		m.ResetFeedItemCollection()
		return nil
	case user.EdgeNotifySource:
		m.ResetNotifySource()
		return nil
	case user.EdgeNotifyTarget:
		m.ResetNotifyTarget()
		return nil
	case user.EdgeNotifyFlow:
		m.ResetNotifyFlow()
		return nil
	case user.EdgeImage:
		m.ResetImage()
		return nil
	case user.EdgeFile:
		m.ResetFile()
		return nil
	case user.EdgeTag:
		m.ResetTag()
		return nil
	case user.EdgePorterContext:
		m.ResetPorterContext()
		return nil
	case user.EdgeCreator:
		m.ResetCreator()
		return nil
	case user.EdgeCreatedUser:
		m.ResetCreatedUser()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
