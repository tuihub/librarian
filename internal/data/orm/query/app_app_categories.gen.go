// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"github.com/tuihub/librarian/internal/data/orm/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newAppAppCategory(db *gorm.DB, opts ...gen.DOOption) appAppCategory {
	_appAppCategory := appAppCategory{}

	_appAppCategory.appAppCategoryDo.UseDB(db, opts...)
	_appAppCategory.appAppCategoryDo.UseModel(&model.AppAppCategory{})

	tableName := _appAppCategory.appAppCategoryDo.TableName()
	_appAppCategory.ALL = field.NewAsterisk(tableName)
	_appAppCategory.AppCategoryID = field.NewInt64(tableName, "app_category_id")
	_appAppCategory.AppID = field.NewInt64(tableName, "app_id")

	_appAppCategory.fillFieldMap()

	return _appAppCategory
}

type appAppCategory struct {
	appAppCategoryDo appAppCategoryDo

	ALL           field.Asterisk
	AppCategoryID field.Int64
	AppID         field.Int64

	fieldMap map[string]field.Expr
}

func (a appAppCategory) Table(newTableName string) *appAppCategory {
	a.appAppCategoryDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a appAppCategory) As(alias string) *appAppCategory {
	a.appAppCategoryDo.DO = *(a.appAppCategoryDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *appAppCategory) updateTableName(table string) *appAppCategory {
	a.ALL = field.NewAsterisk(table)
	a.AppCategoryID = field.NewInt64(table, "app_category_id")
	a.AppID = field.NewInt64(table, "app_id")

	a.fillFieldMap()

	return a
}

func (a *appAppCategory) WithContext(ctx context.Context) IAppAppCategoryDo {
	return a.appAppCategoryDo.WithContext(ctx)
}

func (a appAppCategory) TableName() string { return a.appAppCategoryDo.TableName() }

func (a appAppCategory) Alias() string { return a.appAppCategoryDo.Alias() }

func (a appAppCategory) Columns(cols ...field.Expr) gen.Columns {
	return a.appAppCategoryDo.Columns(cols...)
}

func (a *appAppCategory) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *appAppCategory) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 2)
	a.fieldMap["app_category_id"] = a.AppCategoryID
	a.fieldMap["app_id"] = a.AppID
}

func (a appAppCategory) clone(db *gorm.DB) appAppCategory {
	a.appAppCategoryDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a appAppCategory) replaceDB(db *gorm.DB) appAppCategory {
	a.appAppCategoryDo.ReplaceDB(db)
	return a
}

type appAppCategoryDo struct{ gen.DO }

type IAppAppCategoryDo interface {
	gen.SubQuery
	Debug() IAppAppCategoryDo
	WithContext(ctx context.Context) IAppAppCategoryDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IAppAppCategoryDo
	WriteDB() IAppAppCategoryDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IAppAppCategoryDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IAppAppCategoryDo
	Not(conds ...gen.Condition) IAppAppCategoryDo
	Or(conds ...gen.Condition) IAppAppCategoryDo
	Select(conds ...field.Expr) IAppAppCategoryDo
	Where(conds ...gen.Condition) IAppAppCategoryDo
	Order(conds ...field.Expr) IAppAppCategoryDo
	Distinct(cols ...field.Expr) IAppAppCategoryDo
	Omit(cols ...field.Expr) IAppAppCategoryDo
	Join(table schema.Tabler, on ...field.Expr) IAppAppCategoryDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IAppAppCategoryDo
	RightJoin(table schema.Tabler, on ...field.Expr) IAppAppCategoryDo
	Group(cols ...field.Expr) IAppAppCategoryDo
	Having(conds ...gen.Condition) IAppAppCategoryDo
	Limit(limit int) IAppAppCategoryDo
	Offset(offset int) IAppAppCategoryDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IAppAppCategoryDo
	Unscoped() IAppAppCategoryDo
	Create(values ...*model.AppAppCategory) error
	CreateInBatches(values []*model.AppAppCategory, batchSize int) error
	Save(values ...*model.AppAppCategory) error
	First() (*model.AppAppCategory, error)
	Take() (*model.AppAppCategory, error)
	Last() (*model.AppAppCategory, error)
	Find() ([]*model.AppAppCategory, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AppAppCategory, err error)
	FindInBatches(result *[]*model.AppAppCategory, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.AppAppCategory) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IAppAppCategoryDo
	Assign(attrs ...field.AssignExpr) IAppAppCategoryDo
	Joins(fields ...field.RelationField) IAppAppCategoryDo
	Preload(fields ...field.RelationField) IAppAppCategoryDo
	FirstOrInit() (*model.AppAppCategory, error)
	FirstOrCreate() (*model.AppAppCategory, error)
	FindByPage(offset int, limit int) (result []*model.AppAppCategory, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IAppAppCategoryDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a appAppCategoryDo) Debug() IAppAppCategoryDo {
	return a.withDO(a.DO.Debug())
}

func (a appAppCategoryDo) WithContext(ctx context.Context) IAppAppCategoryDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a appAppCategoryDo) ReadDB() IAppAppCategoryDo {
	return a.Clauses(dbresolver.Read)
}

func (a appAppCategoryDo) WriteDB() IAppAppCategoryDo {
	return a.Clauses(dbresolver.Write)
}

func (a appAppCategoryDo) Session(config *gorm.Session) IAppAppCategoryDo {
	return a.withDO(a.DO.Session(config))
}

func (a appAppCategoryDo) Clauses(conds ...clause.Expression) IAppAppCategoryDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a appAppCategoryDo) Returning(value interface{}, columns ...string) IAppAppCategoryDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a appAppCategoryDo) Not(conds ...gen.Condition) IAppAppCategoryDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a appAppCategoryDo) Or(conds ...gen.Condition) IAppAppCategoryDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a appAppCategoryDo) Select(conds ...field.Expr) IAppAppCategoryDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a appAppCategoryDo) Where(conds ...gen.Condition) IAppAppCategoryDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a appAppCategoryDo) Order(conds ...field.Expr) IAppAppCategoryDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a appAppCategoryDo) Distinct(cols ...field.Expr) IAppAppCategoryDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a appAppCategoryDo) Omit(cols ...field.Expr) IAppAppCategoryDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a appAppCategoryDo) Join(table schema.Tabler, on ...field.Expr) IAppAppCategoryDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a appAppCategoryDo) LeftJoin(table schema.Tabler, on ...field.Expr) IAppAppCategoryDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a appAppCategoryDo) RightJoin(table schema.Tabler, on ...field.Expr) IAppAppCategoryDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a appAppCategoryDo) Group(cols ...field.Expr) IAppAppCategoryDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a appAppCategoryDo) Having(conds ...gen.Condition) IAppAppCategoryDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a appAppCategoryDo) Limit(limit int) IAppAppCategoryDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a appAppCategoryDo) Offset(offset int) IAppAppCategoryDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a appAppCategoryDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IAppAppCategoryDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a appAppCategoryDo) Unscoped() IAppAppCategoryDo {
	return a.withDO(a.DO.Unscoped())
}

func (a appAppCategoryDo) Create(values ...*model.AppAppCategory) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a appAppCategoryDo) CreateInBatches(values []*model.AppAppCategory, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a appAppCategoryDo) Save(values ...*model.AppAppCategory) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a appAppCategoryDo) First() (*model.AppAppCategory, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.AppAppCategory), nil
	}
}

func (a appAppCategoryDo) Take() (*model.AppAppCategory, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.AppAppCategory), nil
	}
}

func (a appAppCategoryDo) Last() (*model.AppAppCategory, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.AppAppCategory), nil
	}
}

func (a appAppCategoryDo) Find() ([]*model.AppAppCategory, error) {
	result, err := a.DO.Find()
	return result.([]*model.AppAppCategory), err
}

func (a appAppCategoryDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.AppAppCategory, err error) {
	buf := make([]*model.AppAppCategory, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a appAppCategoryDo) FindInBatches(result *[]*model.AppAppCategory, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a appAppCategoryDo) Attrs(attrs ...field.AssignExpr) IAppAppCategoryDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a appAppCategoryDo) Assign(attrs ...field.AssignExpr) IAppAppCategoryDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a appAppCategoryDo) Joins(fields ...field.RelationField) IAppAppCategoryDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a appAppCategoryDo) Preload(fields ...field.RelationField) IAppAppCategoryDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a appAppCategoryDo) FirstOrInit() (*model.AppAppCategory, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.AppAppCategory), nil
	}
}

func (a appAppCategoryDo) FirstOrCreate() (*model.AppAppCategory, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.AppAppCategory), nil
	}
}

func (a appAppCategoryDo) FindByPage(offset int, limit int) (result []*model.AppAppCategory, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a appAppCategoryDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a appAppCategoryDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a appAppCategoryDo) Delete(models ...*model.AppAppCategory) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *appAppCategoryDo) withDO(do gen.Dao) *appAppCategoryDo {
	a.DO = *do.(*gen.DO)
	return a
}
