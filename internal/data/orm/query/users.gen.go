// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"
	"database/sql"

	"github.com/tuihub/librarian/internal/data/orm/model"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"
)

func newUser(db *gorm.DB, opts ...gen.DOOption) user {
	_user := user{}

	_user.userDo.UseDB(db, opts...)
	_user.userDo.UseModel(&model.User{})

	tableName := _user.userDo.TableName()
	_user.ALL = field.NewAsterisk(tableName)
	_user.ID = field.NewInt64(tableName, "id")
	_user.Username = field.NewString(tableName, "username")
	_user.Password = field.NewString(tableName, "password")
	_user.Status = field.NewString(tableName, "status")
	_user.Type = field.NewString(tableName, "type")
	_user.CreatorID = field.NewInt64(tableName, "creator_id")
	_user.UpdatedAt = field.NewTime(tableName, "updated_at")
	_user.CreatedAt = field.NewTime(tableName, "created_at")
	_user.Sessions = userHasManySessions{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Sessions", "model.Session"),
		User: struct {
			field.RelationField
			Creator struct {
				field.RelationField
			}
			Sessions struct {
				field.RelationField
			}
			Account struct {
				field.RelationField
				BoundUser struct {
					field.RelationField
				}
			}
			App struct {
				field.RelationField
				User struct {
					field.RelationField
				}
				Device struct {
					field.RelationField
					Sessions struct {
						field.RelationField
					}
					App struct {
						field.RelationField
					}
				}
				AppRunTime struct {
					field.RelationField
					App struct {
						field.RelationField
					}
				}
				AppCategories struct {
					field.RelationField
					AppAppCategories struct {
						field.RelationField
					}
					Apps struct {
						field.RelationField
					}
				}
			}
			FeedConfig struct {
				field.RelationField
				Owner struct {
					field.RelationField
				}
				Feed struct {
					field.RelationField
					Config struct {
						field.RelationField
					}
					Item struct {
						field.RelationField
						Feed struct {
							field.RelationField
						}
						FeedItemCollections struct {
							field.RelationField
							Owner struct {
								field.RelationField
							}
							NotifySource struct {
								field.RelationField
								Owner struct {
									field.RelationField
								}
								FeedConfig struct {
									field.RelationField
								}
								FeedItemCollection struct {
									field.RelationField
								}
								NotifyFlows struct {
									field.RelationField
									Owner struct {
										field.RelationField
									}
									NotifyFlowTargets struct {
										field.RelationField
									}
									NotifyFlowSources struct {
										field.RelationField
									}
									NotifyTargets struct {
										field.RelationField
										Owner struct {
											field.RelationField
										}
										NotifyFlows struct {
											field.RelationField
										}
									}
									NotifySources struct {
										field.RelationField
									}
								}
							}
							FeedItems struct {
								field.RelationField
							}
						}
					}
				}
				NotifySource struct {
					field.RelationField
				}
				FeedActionSets struct {
					field.RelationField
					Owner struct {
						field.RelationField
					}
					FeedConfigs struct {
						field.RelationField
					}
				}
			}
			NotifySource struct {
				field.RelationField
			}
			NotifyTarget struct {
				field.RelationField
			}
			NotifyFlow struct {
				field.RelationField
			}
			Image struct {
				field.RelationField
				Owner struct {
					field.RelationField
				}
				File struct {
					field.RelationField
					Owner struct {
						field.RelationField
					}
					Image struct {
						field.RelationField
					}
				}
			}
			File struct {
				field.RelationField
			}
			Tag struct {
				field.RelationField
				Owner struct {
					field.RelationField
				}
			}
			PorterContext struct {
				field.RelationField
				Owner struct {
					field.RelationField
				}
			}
			CreatedUser struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Sessions.User", "model.User"),
			Creator: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Sessions.User.Creator", "model.User"),
			},
			Sessions: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Sessions.User.Sessions", "model.Session"),
			},
			Account: struct {
				field.RelationField
				BoundUser struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Sessions.User.Account", "model.Account"),
				BoundUser: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Sessions.User.Account.BoundUser", "model.User"),
				},
			},
			App: struct {
				field.RelationField
				User struct {
					field.RelationField
				}
				Device struct {
					field.RelationField
					Sessions struct {
						field.RelationField
					}
					App struct {
						field.RelationField
					}
				}
				AppRunTime struct {
					field.RelationField
					App struct {
						field.RelationField
					}
				}
				AppCategories struct {
					field.RelationField
					AppAppCategories struct {
						field.RelationField
					}
					Apps struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("Sessions.User.App", "model.App"),
				User: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Sessions.User.App.User", "model.User"),
				},
				Device: struct {
					field.RelationField
					Sessions struct {
						field.RelationField
					}
					App struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Sessions.User.App.Device", "model.Device"),
					Sessions: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Sessions.User.App.Device.Sessions", "model.Session"),
					},
					App: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Sessions.User.App.Device.App", "model.App"),
					},
				},
				AppRunTime: struct {
					field.RelationField
					App struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Sessions.User.App.AppRunTime", "model.AppRunTime"),
					App: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Sessions.User.App.AppRunTime.App", "model.App"),
					},
				},
				AppCategories: struct {
					field.RelationField
					AppAppCategories struct {
						field.RelationField
					}
					Apps struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Sessions.User.App.AppCategories", "model.AppCategory"),
					AppAppCategories: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Sessions.User.App.AppCategories.AppAppCategories", "model.AppAppCategory"),
					},
					Apps: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Sessions.User.App.AppCategories.Apps", "model.App"),
					},
				},
			},
			FeedConfig: struct {
				field.RelationField
				Owner struct {
					field.RelationField
				}
				Feed struct {
					field.RelationField
					Config struct {
						field.RelationField
					}
					Item struct {
						field.RelationField
						Feed struct {
							field.RelationField
						}
						FeedItemCollections struct {
							field.RelationField
							Owner struct {
								field.RelationField
							}
							NotifySource struct {
								field.RelationField
								Owner struct {
									field.RelationField
								}
								FeedConfig struct {
									field.RelationField
								}
								FeedItemCollection struct {
									field.RelationField
								}
								NotifyFlows struct {
									field.RelationField
									Owner struct {
										field.RelationField
									}
									NotifyFlowTargets struct {
										field.RelationField
									}
									NotifyFlowSources struct {
										field.RelationField
									}
									NotifyTargets struct {
										field.RelationField
										Owner struct {
											field.RelationField
										}
										NotifyFlows struct {
											field.RelationField
										}
									}
									NotifySources struct {
										field.RelationField
									}
								}
							}
							FeedItems struct {
								field.RelationField
							}
						}
					}
				}
				NotifySource struct {
					field.RelationField
				}
				FeedActionSets struct {
					field.RelationField
					Owner struct {
						field.RelationField
					}
					FeedConfigs struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("Sessions.User.FeedConfig", "model.FeedConfig"),
				Owner: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Sessions.User.FeedConfig.Owner", "model.User"),
				},
				Feed: struct {
					field.RelationField
					Config struct {
						field.RelationField
					}
					Item struct {
						field.RelationField
						Feed struct {
							field.RelationField
						}
						FeedItemCollections struct {
							field.RelationField
							Owner struct {
								field.RelationField
							}
							NotifySource struct {
								field.RelationField
								Owner struct {
									field.RelationField
								}
								FeedConfig struct {
									field.RelationField
								}
								FeedItemCollection struct {
									field.RelationField
								}
								NotifyFlows struct {
									field.RelationField
									Owner struct {
										field.RelationField
									}
									NotifyFlowTargets struct {
										field.RelationField
									}
									NotifyFlowSources struct {
										field.RelationField
									}
									NotifyTargets struct {
										field.RelationField
										Owner struct {
											field.RelationField
										}
										NotifyFlows struct {
											field.RelationField
										}
									}
									NotifySources struct {
										field.RelationField
									}
								}
							}
							FeedItems struct {
								field.RelationField
							}
						}
					}
				}{
					RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed", "model.Feed"),
					Config: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Config", "model.FeedConfig"),
					},
					Item: struct {
						field.RelationField
						Feed struct {
							field.RelationField
						}
						FeedItemCollections struct {
							field.RelationField
							Owner struct {
								field.RelationField
							}
							NotifySource struct {
								field.RelationField
								Owner struct {
									field.RelationField
								}
								FeedConfig struct {
									field.RelationField
								}
								FeedItemCollection struct {
									field.RelationField
								}
								NotifyFlows struct {
									field.RelationField
									Owner struct {
										field.RelationField
									}
									NotifyFlowTargets struct {
										field.RelationField
									}
									NotifyFlowSources struct {
										field.RelationField
									}
									NotifyTargets struct {
										field.RelationField
										Owner struct {
											field.RelationField
										}
										NotifyFlows struct {
											field.RelationField
										}
									}
									NotifySources struct {
										field.RelationField
									}
								}
							}
							FeedItems struct {
								field.RelationField
							}
						}
					}{
						RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item", "model.FeedItem"),
						Feed: struct {
							field.RelationField
						}{
							RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.Feed", "model.Feed"),
						},
						FeedItemCollections: struct {
							field.RelationField
							Owner struct {
								field.RelationField
							}
							NotifySource struct {
								field.RelationField
								Owner struct {
									field.RelationField
								}
								FeedConfig struct {
									field.RelationField
								}
								FeedItemCollection struct {
									field.RelationField
								}
								NotifyFlows struct {
									field.RelationField
									Owner struct {
										field.RelationField
									}
									NotifyFlowTargets struct {
										field.RelationField
									}
									NotifyFlowSources struct {
										field.RelationField
									}
									NotifyTargets struct {
										field.RelationField
										Owner struct {
											field.RelationField
										}
										NotifyFlows struct {
											field.RelationField
										}
									}
									NotifySources struct {
										field.RelationField
									}
								}
							}
							FeedItems struct {
								field.RelationField
							}
						}{
							RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections", "model.FeedItemCollection"),
							Owner: struct {
								field.RelationField
							}{
								RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.Owner", "model.User"),
							},
							NotifySource: struct {
								field.RelationField
								Owner struct {
									field.RelationField
								}
								FeedConfig struct {
									field.RelationField
								}
								FeedItemCollection struct {
									field.RelationField
								}
								NotifyFlows struct {
									field.RelationField
									Owner struct {
										field.RelationField
									}
									NotifyFlowTargets struct {
										field.RelationField
									}
									NotifyFlowSources struct {
										field.RelationField
									}
									NotifyTargets struct {
										field.RelationField
										Owner struct {
											field.RelationField
										}
										NotifyFlows struct {
											field.RelationField
										}
									}
									NotifySources struct {
										field.RelationField
									}
								}
							}{
								RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.NotifySource", "model.NotifySource"),
								Owner: struct {
									field.RelationField
								}{
									RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.NotifySource.Owner", "model.User"),
								},
								FeedConfig: struct {
									field.RelationField
								}{
									RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.NotifySource.FeedConfig", "model.FeedConfig"),
								},
								FeedItemCollection: struct {
									field.RelationField
								}{
									RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.NotifySource.FeedItemCollection", "model.FeedItemCollection"),
								},
								NotifyFlows: struct {
									field.RelationField
									Owner struct {
										field.RelationField
									}
									NotifyFlowTargets struct {
										field.RelationField
									}
									NotifyFlowSources struct {
										field.RelationField
									}
									NotifyTargets struct {
										field.RelationField
										Owner struct {
											field.RelationField
										}
										NotifyFlows struct {
											field.RelationField
										}
									}
									NotifySources struct {
										field.RelationField
									}
								}{
									RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.NotifySource.NotifyFlows", "model.NotifyFlow"),
									Owner: struct {
										field.RelationField
									}{
										RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.NotifySource.NotifyFlows.Owner", "model.User"),
									},
									NotifyFlowTargets: struct {
										field.RelationField
									}{
										RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.NotifySource.NotifyFlows.NotifyFlowTargets", "model.NotifyFlowTarget"),
									},
									NotifyFlowSources: struct {
										field.RelationField
									}{
										RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.NotifySource.NotifyFlows.NotifyFlowSources", "model.NotifyFlowSource"),
									},
									NotifyTargets: struct {
										field.RelationField
										Owner struct {
											field.RelationField
										}
										NotifyFlows struct {
											field.RelationField
										}
									}{
										RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.NotifySource.NotifyFlows.NotifyTargets", "model.NotifyTarget"),
										Owner: struct {
											field.RelationField
										}{
											RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.NotifySource.NotifyFlows.NotifyTargets.Owner", "model.User"),
										},
										NotifyFlows: struct {
											field.RelationField
										}{
											RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.NotifySource.NotifyFlows.NotifyTargets.NotifyFlows", "model.NotifyFlow"),
										},
									},
									NotifySources: struct {
										field.RelationField
									}{
										RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.NotifySource.NotifyFlows.NotifySources", "model.NotifySource"),
									},
								},
							},
							FeedItems: struct {
								field.RelationField
							}{
								RelationField: field.NewRelation("Sessions.User.FeedConfig.Feed.Item.FeedItemCollections.FeedItems", "model.FeedItem"),
							},
						},
					},
				},
				NotifySource: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Sessions.User.FeedConfig.NotifySource", "model.NotifySource"),
				},
				FeedActionSets: struct {
					field.RelationField
					Owner struct {
						field.RelationField
					}
					FeedConfigs struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Sessions.User.FeedConfig.FeedActionSets", "model.FeedActionSet"),
					Owner: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Sessions.User.FeedConfig.FeedActionSets.Owner", "model.User"),
					},
					FeedConfigs: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Sessions.User.FeedConfig.FeedActionSets.FeedConfigs", "model.FeedConfig"),
					},
				},
			},
			NotifySource: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Sessions.User.NotifySource", "model.NotifySource"),
			},
			NotifyTarget: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Sessions.User.NotifyTarget", "model.NotifyTarget"),
			},
			NotifyFlow: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Sessions.User.NotifyFlow", "model.NotifyFlow"),
			},
			Image: struct {
				field.RelationField
				Owner struct {
					field.RelationField
				}
				File struct {
					field.RelationField
					Owner struct {
						field.RelationField
					}
					Image struct {
						field.RelationField
					}
				}
			}{
				RelationField: field.NewRelation("Sessions.User.Image", "model.Image"),
				Owner: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Sessions.User.Image.Owner", "model.User"),
				},
				File: struct {
					field.RelationField
					Owner struct {
						field.RelationField
					}
					Image struct {
						field.RelationField
					}
				}{
					RelationField: field.NewRelation("Sessions.User.Image.File", "model.File"),
					Owner: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Sessions.User.Image.File.Owner", "model.User"),
					},
					Image: struct {
						field.RelationField
					}{
						RelationField: field.NewRelation("Sessions.User.Image.File.Image", "model.Image"),
					},
				},
			},
			File: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Sessions.User.File", "model.File"),
			},
			Tag: struct {
				field.RelationField
				Owner struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Sessions.User.Tag", "model.Tag"),
				Owner: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Sessions.User.Tag.Owner", "model.User"),
				},
			},
			PorterContext: struct {
				field.RelationField
				Owner struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Sessions.User.PorterContext", "model.PorterContext"),
				Owner: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Sessions.User.PorterContext.Owner", "model.User"),
				},
			},
			CreatedUser: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Sessions.User.CreatedUser", "model.User"),
			},
		},
		Device: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Sessions.Device", "model.Device"),
		},
	}

	_user.Account = userHasManyAccount{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Account", "model.Account"),
	}

	_user.App = userHasManyApp{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("App", "model.App"),
	}

	_user.FeedConfig = userHasManyFeedConfig{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("FeedConfig", "model.FeedConfig"),
	}

	_user.NotifySource = userHasManyNotifySource{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("NotifySource", "model.NotifySource"),
	}

	_user.NotifyTarget = userHasManyNotifyTarget{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("NotifyTarget", "model.NotifyTarget"),
	}

	_user.NotifyFlow = userHasManyNotifyFlow{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("NotifyFlow", "model.NotifyFlow"),
	}

	_user.Image = userHasManyImage{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Image", "model.Image"),
	}

	_user.File = userHasManyFile{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("File", "model.File"),
	}

	_user.Tag = userHasManyTag{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Tag", "model.Tag"),
	}

	_user.PorterContext = userHasManyPorterContext{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("PorterContext", "model.PorterContext"),
	}

	_user.CreatedUser = userHasManyCreatedUser{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("CreatedUser", "model.User"),
	}

	_user.Creator = userBelongsToCreator{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Creator", "model.User"),
	}

	_user.fillFieldMap()

	return _user
}

type user struct {
	userDo userDo

	ALL       field.Asterisk
	ID        field.Int64
	Username  field.String
	Password  field.String
	Status    field.String
	Type      field.String
	CreatorID field.Int64
	UpdatedAt field.Time
	CreatedAt field.Time
	Sessions  userHasManySessions

	Account userHasManyAccount

	App userHasManyApp

	FeedConfig userHasManyFeedConfig

	NotifySource userHasManyNotifySource

	NotifyTarget userHasManyNotifyTarget

	NotifyFlow userHasManyNotifyFlow

	Image userHasManyImage

	File userHasManyFile

	Tag userHasManyTag

	PorterContext userHasManyPorterContext

	CreatedUser userHasManyCreatedUser

	Creator userBelongsToCreator

	fieldMap map[string]field.Expr
}

func (u user) Table(newTableName string) *user {
	u.userDo.UseTable(newTableName)
	return u.updateTableName(newTableName)
}

func (u user) As(alias string) *user {
	u.userDo.DO = *(u.userDo.As(alias).(*gen.DO))
	return u.updateTableName(alias)
}

func (u *user) updateTableName(table string) *user {
	u.ALL = field.NewAsterisk(table)
	u.ID = field.NewInt64(table, "id")
	u.Username = field.NewString(table, "username")
	u.Password = field.NewString(table, "password")
	u.Status = field.NewString(table, "status")
	u.Type = field.NewString(table, "type")
	u.CreatorID = field.NewInt64(table, "creator_id")
	u.UpdatedAt = field.NewTime(table, "updated_at")
	u.CreatedAt = field.NewTime(table, "created_at")

	u.fillFieldMap()

	return u
}

func (u *user) WithContext(ctx context.Context) IUserDo { return u.userDo.WithContext(ctx) }

func (u user) TableName() string { return u.userDo.TableName() }

func (u user) Alias() string { return u.userDo.Alias() }

func (u user) Columns(cols ...field.Expr) gen.Columns { return u.userDo.Columns(cols...) }

func (u *user) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := u.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (u *user) fillFieldMap() {
	u.fieldMap = make(map[string]field.Expr, 21)
	u.fieldMap["id"] = u.ID
	u.fieldMap["username"] = u.Username
	u.fieldMap["password"] = u.Password
	u.fieldMap["status"] = u.Status
	u.fieldMap["type"] = u.Type
	u.fieldMap["creator_id"] = u.CreatorID
	u.fieldMap["updated_at"] = u.UpdatedAt
	u.fieldMap["created_at"] = u.CreatedAt

}

func (u user) clone(db *gorm.DB) user {
	u.userDo.ReplaceConnPool(db.Statement.ConnPool)
	u.Sessions.db = db.Session(&gorm.Session{Initialized: true})
	u.Sessions.db.Statement.ConnPool = db.Statement.ConnPool
	u.Account.db = db.Session(&gorm.Session{Initialized: true})
	u.Account.db.Statement.ConnPool = db.Statement.ConnPool
	u.App.db = db.Session(&gorm.Session{Initialized: true})
	u.App.db.Statement.ConnPool = db.Statement.ConnPool
	u.FeedConfig.db = db.Session(&gorm.Session{Initialized: true})
	u.FeedConfig.db.Statement.ConnPool = db.Statement.ConnPool
	u.NotifySource.db = db.Session(&gorm.Session{Initialized: true})
	u.NotifySource.db.Statement.ConnPool = db.Statement.ConnPool
	u.NotifyTarget.db = db.Session(&gorm.Session{Initialized: true})
	u.NotifyTarget.db.Statement.ConnPool = db.Statement.ConnPool
	u.NotifyFlow.db = db.Session(&gorm.Session{Initialized: true})
	u.NotifyFlow.db.Statement.ConnPool = db.Statement.ConnPool
	u.Image.db = db.Session(&gorm.Session{Initialized: true})
	u.Image.db.Statement.ConnPool = db.Statement.ConnPool
	u.File.db = db.Session(&gorm.Session{Initialized: true})
	u.File.db.Statement.ConnPool = db.Statement.ConnPool
	u.Tag.db = db.Session(&gorm.Session{Initialized: true})
	u.Tag.db.Statement.ConnPool = db.Statement.ConnPool
	u.PorterContext.db = db.Session(&gorm.Session{Initialized: true})
	u.PorterContext.db.Statement.ConnPool = db.Statement.ConnPool
	u.CreatedUser.db = db.Session(&gorm.Session{Initialized: true})
	u.CreatedUser.db.Statement.ConnPool = db.Statement.ConnPool
	u.Creator.db = db.Session(&gorm.Session{Initialized: true})
	u.Creator.db.Statement.ConnPool = db.Statement.ConnPool
	return u
}

func (u user) replaceDB(db *gorm.DB) user {
	u.userDo.ReplaceDB(db)
	u.Sessions.db = db.Session(&gorm.Session{})
	u.Account.db = db.Session(&gorm.Session{})
	u.App.db = db.Session(&gorm.Session{})
	u.FeedConfig.db = db.Session(&gorm.Session{})
	u.NotifySource.db = db.Session(&gorm.Session{})
	u.NotifyTarget.db = db.Session(&gorm.Session{})
	u.NotifyFlow.db = db.Session(&gorm.Session{})
	u.Image.db = db.Session(&gorm.Session{})
	u.File.db = db.Session(&gorm.Session{})
	u.Tag.db = db.Session(&gorm.Session{})
	u.PorterContext.db = db.Session(&gorm.Session{})
	u.CreatedUser.db = db.Session(&gorm.Session{})
	u.Creator.db = db.Session(&gorm.Session{})
	return u
}

type userHasManySessions struct {
	db *gorm.DB

	field.RelationField

	User struct {
		field.RelationField
		Creator struct {
			field.RelationField
		}
		Sessions struct {
			field.RelationField
		}
		Account struct {
			field.RelationField
			BoundUser struct {
				field.RelationField
			}
		}
		App struct {
			field.RelationField
			User struct {
				field.RelationField
			}
			Device struct {
				field.RelationField
				Sessions struct {
					field.RelationField
				}
				App struct {
					field.RelationField
				}
			}
			AppRunTime struct {
				field.RelationField
				App struct {
					field.RelationField
				}
			}
			AppCategories struct {
				field.RelationField
				AppAppCategories struct {
					field.RelationField
				}
				Apps struct {
					field.RelationField
				}
			}
		}
		FeedConfig struct {
			field.RelationField
			Owner struct {
				field.RelationField
			}
			Feed struct {
				field.RelationField
				Config struct {
					field.RelationField
				}
				Item struct {
					field.RelationField
					Feed struct {
						field.RelationField
					}
					FeedItemCollections struct {
						field.RelationField
						Owner struct {
							field.RelationField
						}
						NotifySource struct {
							field.RelationField
							Owner struct {
								field.RelationField
							}
							FeedConfig struct {
								field.RelationField
							}
							FeedItemCollection struct {
								field.RelationField
							}
							NotifyFlows struct {
								field.RelationField
								Owner struct {
									field.RelationField
								}
								NotifyFlowTargets struct {
									field.RelationField
								}
								NotifyFlowSources struct {
									field.RelationField
								}
								NotifyTargets struct {
									field.RelationField
									Owner struct {
										field.RelationField
									}
									NotifyFlows struct {
										field.RelationField
									}
								}
								NotifySources struct {
									field.RelationField
								}
							}
						}
						FeedItems struct {
							field.RelationField
						}
					}
				}
			}
			NotifySource struct {
				field.RelationField
			}
			FeedActionSets struct {
				field.RelationField
				Owner struct {
					field.RelationField
				}
				FeedConfigs struct {
					field.RelationField
				}
			}
		}
		NotifySource struct {
			field.RelationField
		}
		NotifyTarget struct {
			field.RelationField
		}
		NotifyFlow struct {
			field.RelationField
		}
		Image struct {
			field.RelationField
			Owner struct {
				field.RelationField
			}
			File struct {
				field.RelationField
				Owner struct {
					field.RelationField
				}
				Image struct {
					field.RelationField
				}
			}
		}
		File struct {
			field.RelationField
		}
		Tag struct {
			field.RelationField
			Owner struct {
				field.RelationField
			}
		}
		PorterContext struct {
			field.RelationField
			Owner struct {
				field.RelationField
			}
		}
		CreatedUser struct {
			field.RelationField
		}
	}
	Device struct {
		field.RelationField
	}
}

func (a userHasManySessions) Where(conds ...field.Expr) *userHasManySessions {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userHasManySessions) WithContext(ctx context.Context) *userHasManySessions {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userHasManySessions) Session(session *gorm.Session) *userHasManySessions {
	a.db = a.db.Session(session)
	return &a
}

func (a userHasManySessions) Model(m *model.User) *userHasManySessionsTx {
	return &userHasManySessionsTx{a.db.Model(m).Association(a.Name())}
}

func (a userHasManySessions) Unscoped() *userHasManySessions {
	a.db = a.db.Unscoped()
	return &a
}

type userHasManySessionsTx struct{ tx *gorm.Association }

func (a userHasManySessionsTx) Find() (result []*model.Session, err error) {
	return result, a.tx.Find(&result)
}

func (a userHasManySessionsTx) Append(values ...*model.Session) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userHasManySessionsTx) Replace(values ...*model.Session) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userHasManySessionsTx) Delete(values ...*model.Session) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userHasManySessionsTx) Clear() error {
	return a.tx.Clear()
}

func (a userHasManySessionsTx) Count() int64 {
	return a.tx.Count()
}

func (a userHasManySessionsTx) Unscoped() *userHasManySessionsTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userHasManyAccount struct {
	db *gorm.DB

	field.RelationField
}

func (a userHasManyAccount) Where(conds ...field.Expr) *userHasManyAccount {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userHasManyAccount) WithContext(ctx context.Context) *userHasManyAccount {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userHasManyAccount) Session(session *gorm.Session) *userHasManyAccount {
	a.db = a.db.Session(session)
	return &a
}

func (a userHasManyAccount) Model(m *model.User) *userHasManyAccountTx {
	return &userHasManyAccountTx{a.db.Model(m).Association(a.Name())}
}

func (a userHasManyAccount) Unscoped() *userHasManyAccount {
	a.db = a.db.Unscoped()
	return &a
}

type userHasManyAccountTx struct{ tx *gorm.Association }

func (a userHasManyAccountTx) Find() (result []*model.Account, err error) {
	return result, a.tx.Find(&result)
}

func (a userHasManyAccountTx) Append(values ...*model.Account) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userHasManyAccountTx) Replace(values ...*model.Account) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userHasManyAccountTx) Delete(values ...*model.Account) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userHasManyAccountTx) Clear() error {
	return a.tx.Clear()
}

func (a userHasManyAccountTx) Count() int64 {
	return a.tx.Count()
}

func (a userHasManyAccountTx) Unscoped() *userHasManyAccountTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userHasManyApp struct {
	db *gorm.DB

	field.RelationField
}

func (a userHasManyApp) Where(conds ...field.Expr) *userHasManyApp {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userHasManyApp) WithContext(ctx context.Context) *userHasManyApp {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userHasManyApp) Session(session *gorm.Session) *userHasManyApp {
	a.db = a.db.Session(session)
	return &a
}

func (a userHasManyApp) Model(m *model.User) *userHasManyAppTx {
	return &userHasManyAppTx{a.db.Model(m).Association(a.Name())}
}

func (a userHasManyApp) Unscoped() *userHasManyApp {
	a.db = a.db.Unscoped()
	return &a
}

type userHasManyAppTx struct{ tx *gorm.Association }

func (a userHasManyAppTx) Find() (result []*model.App, err error) {
	return result, a.tx.Find(&result)
}

func (a userHasManyAppTx) Append(values ...*model.App) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userHasManyAppTx) Replace(values ...*model.App) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userHasManyAppTx) Delete(values ...*model.App) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userHasManyAppTx) Clear() error {
	return a.tx.Clear()
}

func (a userHasManyAppTx) Count() int64 {
	return a.tx.Count()
}

func (a userHasManyAppTx) Unscoped() *userHasManyAppTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userHasManyFeedConfig struct {
	db *gorm.DB

	field.RelationField
}

func (a userHasManyFeedConfig) Where(conds ...field.Expr) *userHasManyFeedConfig {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userHasManyFeedConfig) WithContext(ctx context.Context) *userHasManyFeedConfig {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userHasManyFeedConfig) Session(session *gorm.Session) *userHasManyFeedConfig {
	a.db = a.db.Session(session)
	return &a
}

func (a userHasManyFeedConfig) Model(m *model.User) *userHasManyFeedConfigTx {
	return &userHasManyFeedConfigTx{a.db.Model(m).Association(a.Name())}
}

func (a userHasManyFeedConfig) Unscoped() *userHasManyFeedConfig {
	a.db = a.db.Unscoped()
	return &a
}

type userHasManyFeedConfigTx struct{ tx *gorm.Association }

func (a userHasManyFeedConfigTx) Find() (result []*model.FeedConfig, err error) {
	return result, a.tx.Find(&result)
}

func (a userHasManyFeedConfigTx) Append(values ...*model.FeedConfig) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userHasManyFeedConfigTx) Replace(values ...*model.FeedConfig) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userHasManyFeedConfigTx) Delete(values ...*model.FeedConfig) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userHasManyFeedConfigTx) Clear() error {
	return a.tx.Clear()
}

func (a userHasManyFeedConfigTx) Count() int64 {
	return a.tx.Count()
}

func (a userHasManyFeedConfigTx) Unscoped() *userHasManyFeedConfigTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userHasManyNotifySource struct {
	db *gorm.DB

	field.RelationField
}

func (a userHasManyNotifySource) Where(conds ...field.Expr) *userHasManyNotifySource {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userHasManyNotifySource) WithContext(ctx context.Context) *userHasManyNotifySource {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userHasManyNotifySource) Session(session *gorm.Session) *userHasManyNotifySource {
	a.db = a.db.Session(session)
	return &a
}

func (a userHasManyNotifySource) Model(m *model.User) *userHasManyNotifySourceTx {
	return &userHasManyNotifySourceTx{a.db.Model(m).Association(a.Name())}
}

func (a userHasManyNotifySource) Unscoped() *userHasManyNotifySource {
	a.db = a.db.Unscoped()
	return &a
}

type userHasManyNotifySourceTx struct{ tx *gorm.Association }

func (a userHasManyNotifySourceTx) Find() (result []*model.NotifySource, err error) {
	return result, a.tx.Find(&result)
}

func (a userHasManyNotifySourceTx) Append(values ...*model.NotifySource) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userHasManyNotifySourceTx) Replace(values ...*model.NotifySource) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userHasManyNotifySourceTx) Delete(values ...*model.NotifySource) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userHasManyNotifySourceTx) Clear() error {
	return a.tx.Clear()
}

func (a userHasManyNotifySourceTx) Count() int64 {
	return a.tx.Count()
}

func (a userHasManyNotifySourceTx) Unscoped() *userHasManyNotifySourceTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userHasManyNotifyTarget struct {
	db *gorm.DB

	field.RelationField
}

func (a userHasManyNotifyTarget) Where(conds ...field.Expr) *userHasManyNotifyTarget {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userHasManyNotifyTarget) WithContext(ctx context.Context) *userHasManyNotifyTarget {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userHasManyNotifyTarget) Session(session *gorm.Session) *userHasManyNotifyTarget {
	a.db = a.db.Session(session)
	return &a
}

func (a userHasManyNotifyTarget) Model(m *model.User) *userHasManyNotifyTargetTx {
	return &userHasManyNotifyTargetTx{a.db.Model(m).Association(a.Name())}
}

func (a userHasManyNotifyTarget) Unscoped() *userHasManyNotifyTarget {
	a.db = a.db.Unscoped()
	return &a
}

type userHasManyNotifyTargetTx struct{ tx *gorm.Association }

func (a userHasManyNotifyTargetTx) Find() (result []*model.NotifyTarget, err error) {
	return result, a.tx.Find(&result)
}

func (a userHasManyNotifyTargetTx) Append(values ...*model.NotifyTarget) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userHasManyNotifyTargetTx) Replace(values ...*model.NotifyTarget) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userHasManyNotifyTargetTx) Delete(values ...*model.NotifyTarget) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userHasManyNotifyTargetTx) Clear() error {
	return a.tx.Clear()
}

func (a userHasManyNotifyTargetTx) Count() int64 {
	return a.tx.Count()
}

func (a userHasManyNotifyTargetTx) Unscoped() *userHasManyNotifyTargetTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userHasManyNotifyFlow struct {
	db *gorm.DB

	field.RelationField
}

func (a userHasManyNotifyFlow) Where(conds ...field.Expr) *userHasManyNotifyFlow {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userHasManyNotifyFlow) WithContext(ctx context.Context) *userHasManyNotifyFlow {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userHasManyNotifyFlow) Session(session *gorm.Session) *userHasManyNotifyFlow {
	a.db = a.db.Session(session)
	return &a
}

func (a userHasManyNotifyFlow) Model(m *model.User) *userHasManyNotifyFlowTx {
	return &userHasManyNotifyFlowTx{a.db.Model(m).Association(a.Name())}
}

func (a userHasManyNotifyFlow) Unscoped() *userHasManyNotifyFlow {
	a.db = a.db.Unscoped()
	return &a
}

type userHasManyNotifyFlowTx struct{ tx *gorm.Association }

func (a userHasManyNotifyFlowTx) Find() (result []*model.NotifyFlow, err error) {
	return result, a.tx.Find(&result)
}

func (a userHasManyNotifyFlowTx) Append(values ...*model.NotifyFlow) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userHasManyNotifyFlowTx) Replace(values ...*model.NotifyFlow) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userHasManyNotifyFlowTx) Delete(values ...*model.NotifyFlow) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userHasManyNotifyFlowTx) Clear() error {
	return a.tx.Clear()
}

func (a userHasManyNotifyFlowTx) Count() int64 {
	return a.tx.Count()
}

func (a userHasManyNotifyFlowTx) Unscoped() *userHasManyNotifyFlowTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userHasManyImage struct {
	db *gorm.DB

	field.RelationField
}

func (a userHasManyImage) Where(conds ...field.Expr) *userHasManyImage {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userHasManyImage) WithContext(ctx context.Context) *userHasManyImage {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userHasManyImage) Session(session *gorm.Session) *userHasManyImage {
	a.db = a.db.Session(session)
	return &a
}

func (a userHasManyImage) Model(m *model.User) *userHasManyImageTx {
	return &userHasManyImageTx{a.db.Model(m).Association(a.Name())}
}

func (a userHasManyImage) Unscoped() *userHasManyImage {
	a.db = a.db.Unscoped()
	return &a
}

type userHasManyImageTx struct{ tx *gorm.Association }

func (a userHasManyImageTx) Find() (result []*model.Image, err error) {
	return result, a.tx.Find(&result)
}

func (a userHasManyImageTx) Append(values ...*model.Image) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userHasManyImageTx) Replace(values ...*model.Image) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userHasManyImageTx) Delete(values ...*model.Image) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userHasManyImageTx) Clear() error {
	return a.tx.Clear()
}

func (a userHasManyImageTx) Count() int64 {
	return a.tx.Count()
}

func (a userHasManyImageTx) Unscoped() *userHasManyImageTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userHasManyFile struct {
	db *gorm.DB

	field.RelationField
}

func (a userHasManyFile) Where(conds ...field.Expr) *userHasManyFile {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userHasManyFile) WithContext(ctx context.Context) *userHasManyFile {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userHasManyFile) Session(session *gorm.Session) *userHasManyFile {
	a.db = a.db.Session(session)
	return &a
}

func (a userHasManyFile) Model(m *model.User) *userHasManyFileTx {
	return &userHasManyFileTx{a.db.Model(m).Association(a.Name())}
}

func (a userHasManyFile) Unscoped() *userHasManyFile {
	a.db = a.db.Unscoped()
	return &a
}

type userHasManyFileTx struct{ tx *gorm.Association }

func (a userHasManyFileTx) Find() (result []*model.File, err error) {
	return result, a.tx.Find(&result)
}

func (a userHasManyFileTx) Append(values ...*model.File) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userHasManyFileTx) Replace(values ...*model.File) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userHasManyFileTx) Delete(values ...*model.File) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userHasManyFileTx) Clear() error {
	return a.tx.Clear()
}

func (a userHasManyFileTx) Count() int64 {
	return a.tx.Count()
}

func (a userHasManyFileTx) Unscoped() *userHasManyFileTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userHasManyTag struct {
	db *gorm.DB

	field.RelationField
}

func (a userHasManyTag) Where(conds ...field.Expr) *userHasManyTag {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userHasManyTag) WithContext(ctx context.Context) *userHasManyTag {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userHasManyTag) Session(session *gorm.Session) *userHasManyTag {
	a.db = a.db.Session(session)
	return &a
}

func (a userHasManyTag) Model(m *model.User) *userHasManyTagTx {
	return &userHasManyTagTx{a.db.Model(m).Association(a.Name())}
}

func (a userHasManyTag) Unscoped() *userHasManyTag {
	a.db = a.db.Unscoped()
	return &a
}

type userHasManyTagTx struct{ tx *gorm.Association }

func (a userHasManyTagTx) Find() (result []*model.Tag, err error) {
	return result, a.tx.Find(&result)
}

func (a userHasManyTagTx) Append(values ...*model.Tag) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userHasManyTagTx) Replace(values ...*model.Tag) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userHasManyTagTx) Delete(values ...*model.Tag) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userHasManyTagTx) Clear() error {
	return a.tx.Clear()
}

func (a userHasManyTagTx) Count() int64 {
	return a.tx.Count()
}

func (a userHasManyTagTx) Unscoped() *userHasManyTagTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userHasManyPorterContext struct {
	db *gorm.DB

	field.RelationField
}

func (a userHasManyPorterContext) Where(conds ...field.Expr) *userHasManyPorterContext {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userHasManyPorterContext) WithContext(ctx context.Context) *userHasManyPorterContext {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userHasManyPorterContext) Session(session *gorm.Session) *userHasManyPorterContext {
	a.db = a.db.Session(session)
	return &a
}

func (a userHasManyPorterContext) Model(m *model.User) *userHasManyPorterContextTx {
	return &userHasManyPorterContextTx{a.db.Model(m).Association(a.Name())}
}

func (a userHasManyPorterContext) Unscoped() *userHasManyPorterContext {
	a.db = a.db.Unscoped()
	return &a
}

type userHasManyPorterContextTx struct{ tx *gorm.Association }

func (a userHasManyPorterContextTx) Find() (result []*model.PorterContext, err error) {
	return result, a.tx.Find(&result)
}

func (a userHasManyPorterContextTx) Append(values ...*model.PorterContext) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userHasManyPorterContextTx) Replace(values ...*model.PorterContext) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userHasManyPorterContextTx) Delete(values ...*model.PorterContext) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userHasManyPorterContextTx) Clear() error {
	return a.tx.Clear()
}

func (a userHasManyPorterContextTx) Count() int64 {
	return a.tx.Count()
}

func (a userHasManyPorterContextTx) Unscoped() *userHasManyPorterContextTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userHasManyCreatedUser struct {
	db *gorm.DB

	field.RelationField
}

func (a userHasManyCreatedUser) Where(conds ...field.Expr) *userHasManyCreatedUser {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userHasManyCreatedUser) WithContext(ctx context.Context) *userHasManyCreatedUser {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userHasManyCreatedUser) Session(session *gorm.Session) *userHasManyCreatedUser {
	a.db = a.db.Session(session)
	return &a
}

func (a userHasManyCreatedUser) Model(m *model.User) *userHasManyCreatedUserTx {
	return &userHasManyCreatedUserTx{a.db.Model(m).Association(a.Name())}
}

func (a userHasManyCreatedUser) Unscoped() *userHasManyCreatedUser {
	a.db = a.db.Unscoped()
	return &a
}

type userHasManyCreatedUserTx struct{ tx *gorm.Association }

func (a userHasManyCreatedUserTx) Find() (result []*model.User, err error) {
	return result, a.tx.Find(&result)
}

func (a userHasManyCreatedUserTx) Append(values ...*model.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userHasManyCreatedUserTx) Replace(values ...*model.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userHasManyCreatedUserTx) Delete(values ...*model.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userHasManyCreatedUserTx) Clear() error {
	return a.tx.Clear()
}

func (a userHasManyCreatedUserTx) Count() int64 {
	return a.tx.Count()
}

func (a userHasManyCreatedUserTx) Unscoped() *userHasManyCreatedUserTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userBelongsToCreator struct {
	db *gorm.DB

	field.RelationField
}

func (a userBelongsToCreator) Where(conds ...field.Expr) *userBelongsToCreator {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a userBelongsToCreator) WithContext(ctx context.Context) *userBelongsToCreator {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a userBelongsToCreator) Session(session *gorm.Session) *userBelongsToCreator {
	a.db = a.db.Session(session)
	return &a
}

func (a userBelongsToCreator) Model(m *model.User) *userBelongsToCreatorTx {
	return &userBelongsToCreatorTx{a.db.Model(m).Association(a.Name())}
}

func (a userBelongsToCreator) Unscoped() *userBelongsToCreator {
	a.db = a.db.Unscoped()
	return &a
}

type userBelongsToCreatorTx struct{ tx *gorm.Association }

func (a userBelongsToCreatorTx) Find() (result *model.User, err error) {
	return result, a.tx.Find(&result)
}

func (a userBelongsToCreatorTx) Append(values ...*model.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a userBelongsToCreatorTx) Replace(values ...*model.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a userBelongsToCreatorTx) Delete(values ...*model.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a userBelongsToCreatorTx) Clear() error {
	return a.tx.Clear()
}

func (a userBelongsToCreatorTx) Count() int64 {
	return a.tx.Count()
}

func (a userBelongsToCreatorTx) Unscoped() *userBelongsToCreatorTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type userDo struct{ gen.DO }

type IUserDo interface {
	gen.SubQuery
	Debug() IUserDo
	WithContext(ctx context.Context) IUserDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IUserDo
	WriteDB() IUserDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IUserDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IUserDo
	Not(conds ...gen.Condition) IUserDo
	Or(conds ...gen.Condition) IUserDo
	Select(conds ...field.Expr) IUserDo
	Where(conds ...gen.Condition) IUserDo
	Order(conds ...field.Expr) IUserDo
	Distinct(cols ...field.Expr) IUserDo
	Omit(cols ...field.Expr) IUserDo
	Join(table schema.Tabler, on ...field.Expr) IUserDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IUserDo
	RightJoin(table schema.Tabler, on ...field.Expr) IUserDo
	Group(cols ...field.Expr) IUserDo
	Having(conds ...gen.Condition) IUserDo
	Limit(limit int) IUserDo
	Offset(offset int) IUserDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IUserDo
	Unscoped() IUserDo
	Create(values ...*model.User) error
	CreateInBatches(values []*model.User, batchSize int) error
	Save(values ...*model.User) error
	First() (*model.User, error)
	Take() (*model.User, error)
	Last() (*model.User, error)
	Find() ([]*model.User, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.User, err error)
	FindInBatches(result *[]*model.User, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.User) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IUserDo
	Assign(attrs ...field.AssignExpr) IUserDo
	Joins(fields ...field.RelationField) IUserDo
	Preload(fields ...field.RelationField) IUserDo
	FirstOrInit() (*model.User, error)
	FirstOrCreate() (*model.User, error)
	FindByPage(offset int, limit int) (result []*model.User, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IUserDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (u userDo) Debug() IUserDo {
	return u.withDO(u.DO.Debug())
}

func (u userDo) WithContext(ctx context.Context) IUserDo {
	return u.withDO(u.DO.WithContext(ctx))
}

func (u userDo) ReadDB() IUserDo {
	return u.Clauses(dbresolver.Read)
}

func (u userDo) WriteDB() IUserDo {
	return u.Clauses(dbresolver.Write)
}

func (u userDo) Session(config *gorm.Session) IUserDo {
	return u.withDO(u.DO.Session(config))
}

func (u userDo) Clauses(conds ...clause.Expression) IUserDo {
	return u.withDO(u.DO.Clauses(conds...))
}

func (u userDo) Returning(value interface{}, columns ...string) IUserDo {
	return u.withDO(u.DO.Returning(value, columns...))
}

func (u userDo) Not(conds ...gen.Condition) IUserDo {
	return u.withDO(u.DO.Not(conds...))
}

func (u userDo) Or(conds ...gen.Condition) IUserDo {
	return u.withDO(u.DO.Or(conds...))
}

func (u userDo) Select(conds ...field.Expr) IUserDo {
	return u.withDO(u.DO.Select(conds...))
}

func (u userDo) Where(conds ...gen.Condition) IUserDo {
	return u.withDO(u.DO.Where(conds...))
}

func (u userDo) Order(conds ...field.Expr) IUserDo {
	return u.withDO(u.DO.Order(conds...))
}

func (u userDo) Distinct(cols ...field.Expr) IUserDo {
	return u.withDO(u.DO.Distinct(cols...))
}

func (u userDo) Omit(cols ...field.Expr) IUserDo {
	return u.withDO(u.DO.Omit(cols...))
}

func (u userDo) Join(table schema.Tabler, on ...field.Expr) IUserDo {
	return u.withDO(u.DO.Join(table, on...))
}

func (u userDo) LeftJoin(table schema.Tabler, on ...field.Expr) IUserDo {
	return u.withDO(u.DO.LeftJoin(table, on...))
}

func (u userDo) RightJoin(table schema.Tabler, on ...field.Expr) IUserDo {
	return u.withDO(u.DO.RightJoin(table, on...))
}

func (u userDo) Group(cols ...field.Expr) IUserDo {
	return u.withDO(u.DO.Group(cols...))
}

func (u userDo) Having(conds ...gen.Condition) IUserDo {
	return u.withDO(u.DO.Having(conds...))
}

func (u userDo) Limit(limit int) IUserDo {
	return u.withDO(u.DO.Limit(limit))
}

func (u userDo) Offset(offset int) IUserDo {
	return u.withDO(u.DO.Offset(offset))
}

func (u userDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IUserDo {
	return u.withDO(u.DO.Scopes(funcs...))
}

func (u userDo) Unscoped() IUserDo {
	return u.withDO(u.DO.Unscoped())
}

func (u userDo) Create(values ...*model.User) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Create(values)
}

func (u userDo) CreateInBatches(values []*model.User, batchSize int) error {
	return u.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (u userDo) Save(values ...*model.User) error {
	if len(values) == 0 {
		return nil
	}
	return u.DO.Save(values)
}

func (u userDo) First() (*model.User, error) {
	if result, err := u.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) Take() (*model.User, error) {
	if result, err := u.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) Last() (*model.User, error) {
	if result, err := u.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) Find() ([]*model.User, error) {
	result, err := u.DO.Find()
	return result.([]*model.User), err
}

func (u userDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.User, err error) {
	buf := make([]*model.User, 0, batchSize)
	err = u.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (u userDo) FindInBatches(result *[]*model.User, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return u.DO.FindInBatches(result, batchSize, fc)
}

func (u userDo) Attrs(attrs ...field.AssignExpr) IUserDo {
	return u.withDO(u.DO.Attrs(attrs...))
}

func (u userDo) Assign(attrs ...field.AssignExpr) IUserDo {
	return u.withDO(u.DO.Assign(attrs...))
}

func (u userDo) Joins(fields ...field.RelationField) IUserDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Joins(_f))
	}
	return &u
}

func (u userDo) Preload(fields ...field.RelationField) IUserDo {
	for _, _f := range fields {
		u = *u.withDO(u.DO.Preload(_f))
	}
	return &u
}

func (u userDo) FirstOrInit() (*model.User, error) {
	if result, err := u.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) FirstOrCreate() (*model.User, error) {
	if result, err := u.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.User), nil
	}
}

func (u userDo) FindByPage(offset int, limit int) (result []*model.User, count int64, err error) {
	result, err = u.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = u.Offset(-1).Limit(-1).Count()
	return
}

func (u userDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = u.Count()
	if err != nil {
		return
	}

	err = u.Offset(offset).Limit(limit).Scan(result)
	return
}

func (u userDo) Scan(result interface{}) (err error) {
	return u.DO.Scan(result)
}

func (u userDo) Delete(models ...*model.User) (result gen.ResultInfo, err error) {
	return u.DO.Delete(models)
}

func (u *userDo) withDO(do gen.Dao) *userDo {
	u.DO = *do.(*gen.DO)
	return u
}
