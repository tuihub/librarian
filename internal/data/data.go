package data

import (
	"context"
	stdsql "database/sql"
	"errors"
	"fmt"
	"os"
	"path"
	"strings"
	"time"

	"github.com/tuihub/librarian/internal/conf"
	"github.com/tuihub/librarian/internal/data/orm/query"
	"github.com/tuihub/librarian/internal/lib/libapp"
	"github.com/tuihub/librarian/internal/lib/logger"

	"github.com/google/wire"
	"gorm.io/driver/postgres"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

var ProviderSet = wire.NewSet(
	NewData,
	GetDB,
	NewAngelaRepo,
	NewTipherethRepo,
	NewGeburaRepo,
	NewYesodRepo,
	NewNetzachRepo,
	NewChesedRepo,
	NewKetherRepo,
	NewBinahRepo,
	NewSupervisorRepo,
)

type Data struct {
	stdDB *stdsql.DB
	db    *gorm.DB
}

func NewData(c *conf.Database, app *libapp.Settings) (*Data, func(), error) {
	if c == nil {
		return nil, func() {}, errors.New("database config is nil")
	}
	var (
		dialector  gorm.Dialector
		schemaPath string
	)
	switch c.Driver {
	case conf.DatabaseDriverMemory:
		dialector = sqlite.Open("file::memory:?cache=shared")
		schemaPath = "internal/data/schema/sqlite/schema.sql"
	case conf.DatabaseDriverSqlite:
		dialector = sqlite.Open(fmt.Sprintf(
			"file:%s?cache=shared&_journal=WAL&_busy_timeout=30000",
			path.Join(app.DataPath, "librarian.db"),
		))
		schemaPath = "internal/data/schema/sqlite/schema.sql"
	case conf.DatabaseDriverPostgres:
		dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%d sslmode=disable TimeZone=UTC",
			c.Host, c.Username, c.Password, c.DBName, c.Port)
		dialector = postgres.Open(dsn)
		schemaPath = "internal/data/schema/postgres/schema.sql"
	default:
		return nil, func() {}, fmt.Errorf("unsupported database driver %s", c.Driver)
	}

	db, err := gorm.Open(dialector, &gorm.Config{
		SkipDefaultTransaction: true,
	})
	if err != nil {
		logger.Errorf("failed opening connection to database: %v", err)
		return nil, func() {}, fmt.Errorf("failed opening connection to database: %w", err)
	}

	sqlDB, err := db.DB()
	if err != nil {
		return nil, func() {}, err
	}
	sqlDB.SetMaxIdleConns(10)  //nolint:mnd // default
	sqlDB.SetMaxOpenConns(100) //nolint:mnd // default
	sqlDB.SetConnMaxIdleTime(time.Hour)

	// Load Schema
	if schemaPath != "" {
		if err = applySchema(db, schemaPath); err != nil {
			logger.Errorf("failed applying schema: %v", err)
			return nil, func() {}, err
		}
	}

	query.SetDefault(db)

	return &Data{
			stdDB: sqlDB,
			db:    db,
		}, func() {
			_ = sqlDB.Close()
		}, nil
}

func applySchema(db *gorm.DB, schemaPath string) error {
	content, err := os.ReadFile(schemaPath)
	if err != nil {
		if os.IsNotExist(err) {
			logger.Infof("schema file not found at %s, skipping", schemaPath)
			return nil
		}
		return err
	}

	// Split by semicolon? Or execute line by line?
	// SQLite schema generated by GORM usually has statements separated by newlines/semicolons.
	// But `db.Exec` usually takes one statement.
	// We can split by ";\n" or just exec the whole thing if the driver supports it.
	// SQLite supports multiple statements in Exec if enabled? GORM might not.
	// Let's try splitting.

	statements := strings.Split(string(content), ";\n")
	for _, stmt := range statements {
		stmt = strings.TrimSpace(stmt)
		if stmt == "" {
			continue
		}
		// Basic check to see if table exists?
		// Since we want to use SQL definition, we should probably ignore "table exists" errors
		// or use "CREATE TABLE IF NOT EXISTS".
		// But the generated SQL uses "CREATE TABLE".
		// We can wrap in try-catch or check if table exists.
		// For now, let's just try to execute and ignore specific errors or let it fail if not exists.
		// Actually, standard migration usually checks `schema_migrations` table.
		// Here we are doing a simplified "Apply Schema on Start".
		// If tables exist, CREATE TABLE will fail.
		// We should probably check if *any* table exists and skip if so?
		// Or try to execute and ignore "already exists" error.
		if execErr := db.Exec(stmt).Error; execErr != nil {
			// Check error content for "already exists"
			// This is driver specific.
			// Simplified approach: Just log error and continue (risky but matches "ensure schema" if we assume idempotency or fresh start)
			// But for "CREATE TABLE", it fails.
			// Let's assume we only run this if we detect empty DB?
			// Or modify SQL to use IF NOT EXISTS.
			logger.Debugf("executing schema stmt failed (might be exists): %v", execErr)
		}
	}
	return nil
}

func GetDB(d *Data) *stdsql.DB {
	return d.stdDB
}

func (d *Data) WithTx(ctx context.Context, fn func(tx *query.Query) error) error {
	return d.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
		return fn(query.Use(tx))
	})
}

func ErrorIsNotFound(err error) bool {
	return errors.Is(err, gorm.ErrRecordNotFound)
}
